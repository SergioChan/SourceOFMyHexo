{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/vno/source/js/main.js","path":"js/main.js","modified":0},{"_id":"themes/vno/source/images/show/page.png","path":"images/show/page.png","modified":0},{"_id":"themes/vno/source/images/show/list.png","path":"images/show/list.png","modified":0},{"_id":"themes/vno/source/images/show/home.png","path":"images/show/home.png","modified":0},{"_id":"themes/vno/source/images/logo2.jpg","path":"images/logo2.jpg","modified":0},{"_id":"themes/vno/source/images/logo.jpg","path":"images/logo.jpg","modified":0},{"_id":"themes/vno/source/images/favicon.png","path":"images/favicon.png","modified":0},{"_id":"themes/vno/source/images/background-cover.jpg","path":"images/background-cover.jpg","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0},{"_id":"themes/vno/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0},{"_id":"themes/vno/source/css/vno.styl","path":"css/vno.styl","modified":0},{"_id":"source/CNAME","path":"CNAME","modified":0},{"_id":"source/music/test.mp3","path":"music/test.mp3","modified":0},{"_id":"source/image/sodoku.png","path":"image/sodoku.png","modified":0},{"_id":"source/image/photon_1.png","path":"image/photon_1.png","modified":0},{"_id":"source/image/cover.png","path":"image/cover.png","modified":0},{"_id":"source/image/background-cover.jpg","path":"image/background-cover.jpg","modified":0},{"_id":"source/image/background-cover-small.jpg","path":"image/background-cover-small.jpg","modified":0},{"_id":"source/image/TrelloNavigation.png","path":"image/TrelloNavigation.png","modified":0},{"_id":"source/image/STPreview.png","path":"image/STPreview.png","modified":0},{"_id":"source/image/PRPreview.jpg","path":"image/PRPreview.jpg","modified":0},{"_id":"source/image/NavigationControlCenter.png","path":"image/NavigationControlCenter.png","modified":0},{"_id":"source/image/NavLogo.png","path":"image/NavLogo.png","modified":0},{"_id":"source/image/LineImg.png","path":"image/LineImg.png","modified":0},{"_id":"source/image/FIXPreview.jpg","path":"image/FIXPreview.jpg","modified":0},{"_id":"source/image/CinemaAnimation.png","path":"image/CinemaAnimation.png","modified":0},{"_id":"source/image/CatWaitingHUD.png","path":"image/CatWaitingHUD.png","modified":0},{"_id":"source/image/ActivityIndicator.jpg","path":"image/ActivityIndicator.jpg","modified":0},{"_id":"source/image/2016-gayhub.png","path":"image/2016-gayhub.png","modified":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0}],"Cache":[{"_id":"source/_posts/2016-03-15.md","shasum":"caaf387d196cb33241dafeb613be87819badd094","modified":1458036170000},{"_id":"source/CNAME","shasum":"7f17f1abc6cc7bee5d79b462cc845cf88dd9f264","modified":1450444394000},{"_id":"source/_posts/2015.md","shasum":"a81752ca4aa5fb8ef3d5ba9ae69fd8e472cfb68e","modified":1451397837000},{"_id":"source/_posts/ADB-两三事-残.md","shasum":"0659f13079be63405b3edc07fa557566425fe84d","modified":1477319383000},{"_id":"source/_posts/How-to-draw-a-Wireframe-Shader-for-a-Cube-in-Rajawali-under-OpenGL-ES-2-0.md","shasum":"4d47c0bc92f450310e49754f19013e33a98b1a56","modified":1478685138000},{"_id":"source/_posts/2016-04-11-去战斗.md","shasum":"fac54c863dec6128aa9e13f3b0048ae50a5722d2","modified":1471588503000},{"_id":"source/_posts/Multi-Touch-Bar-UI-开发入门指南.md","shasum":"1564fbabe2c2c32662c43e3baf5ef807281cda9d","modified":1478084906000},{"_id":"source/_posts/AVAudioPlayer的几个细节.md","shasum":"629ffb7bad887c028bd7d880c2f6a81013d2ac96","modified":1471051539000},{"_id":"source/_posts/2016-09-05-基督山伯爵.md","shasum":"f419b9fa5123617e0186cc9241947908b01dfe3e","modified":1473059599000},{"_id":"source/_posts/Leetcode-Database-刷题记录.md","shasum":"130a3ed70766a4d5d2732cb4005dc3a073102d34","modified":1472202994000},{"_id":"source/_posts/PHP图片处理-透明水印的处理和添加.md","shasum":"e0a62510b0a87ee63a5abfffbd9f31eb32c227e1","modified":1471590658000},{"_id":"source/_posts/UIColor-colorWithRed-green-blue-alpha-的正确用法.md","shasum":"f8116157bcac938f0c0d8abed2774320d4212384","modified":1450444394000},{"_id":"source/_posts/Python利用深度优先搜索解数独程序的实现.md","shasum":"cb6e8ce821965242ca25333900ad2f4f63194432","modified":1454984790000},{"_id":"source/_posts/Ubuntu下重置MySQL的root密码.md","shasum":"a7d6cd7c7c27bae0d02ef1dd7541919bb20400e8","modified":1450444394000},{"_id":"source/_posts/iOS-Airplay-中的-Airtunes-Server-服务协议和机制详解以及-Android-Demo-的实现.md","shasum":"49973c6dc30928deff06148d089879184a87bd83","modified":1472540531000},{"_id":"source/_posts/objective-c-runtime是什么.md","shasum":"6b216153d688984072105fa7cca3b3aa26f85440","modified":1450444394000},{"_id":"source/_posts/runloop初窥.md","shasum":"673349bd36401bc9599514a79843bfe33973fe70","modified":1450444394000},{"_id":"source/_posts/iOS-静态库封装和使用方法.md","shasum":"a9bdadfe6a5700b2c6ca2f2ba21056a50d895a00","modified":1450444394000},{"_id":"source/_posts/tornado-TCP服务器间内部通讯TCP服务器性能验证.md","shasum":"aad45ad54501d5bdc47ce6b42900af9ca3ca8088","modified":1450487986000},{"_id":"source/_posts/“人工智能”邪教.md","shasum":"6fd378d0576a24a823b50c58919a98cf9b43bb92","modified":1472089880000},{"_id":"source/_posts/三件小事.md","shasum":"c873454fcbc7d5cdba16d72a3addecdb4198aa1b","modified":1472089857000},{"_id":"source/_posts/不要想当然的就使用UITableView.md","shasum":"e434489df4589e61dab763c48d2bf0e78e6e6d4f","modified":1455689259000},{"_id":"source/_posts/使用-Photon-在-Unity-里快速搭建一个多人联机游戏.md","shasum":"45a9c2e86647ccd09535f4cacbffbd937fae883d","modified":1472053182000},{"_id":"source/_posts/我是怎么踩过在-OSX-上录屏的坑的.md","shasum":"054dfcc518651fc51c5ab84ac9038c2fdcee40fa","modified":1458749020000},{"_id":"source/_posts/如何在-WKWebView-中实现-Safari-原生的阅读模式.md","shasum":"fd8d45a80b9138e7819fb1e176532f13baf4a664","modified":1477033703000},{"_id":"source/_posts/怎么设计和实现一个Newsfeed系统.md","shasum":"918ccb3cb991eb631e17a116552057ff9a935c6b","modified":1450487968000},{"_id":"source/_posts/我的-GayHub-2016.md","shasum":"cbb7a498b3857e1697f416b1becfb7ffa7f66da1","modified":1468494488000},{"_id":"source/_posts/无题-20160120.md","shasum":"e77fd5e1617220fa324006dde989a809bb85813e","modified":1453281442000},{"_id":"source/_posts/知乎-Hackathon-之前对于知乎产品形态的一些疯狂想法.md","shasum":"87ac3d50f47420a6019473d89b195266a21814f7","modified":1457431224000},{"_id":"source/_posts/语.md","shasum":"013b02b0a83eedbb3903fc40dfbf47305ad120b5","modified":1450670048000},{"_id":"source/_posts/谈谈我对Hackathon的理解.md","shasum":"4bd325cadfef41616fb66101b5a9f6eea5f7cb52","modified":1450487293000},{"_id":"source/_posts/过年.md","shasum":"044ddf1b9ad90551d6a2c0ee49363e77db19a2bc","modified":1472094838000},{"_id":"source/about/index.md","shasum":"79532adede1779bfed30a65f08d89f0b3ddbb447","modified":1472545964000},{"_id":"source/favicon.ico","shasum":"8e2f1ece0b64bc8fd00c1a7beb1b4c6aa7b1ecb3","modified":1453956100000},{"_id":"source/categories/index.md","shasum":"dd21c2757a9a209e61420a56d43b098f8be939f9","modified":1450444394000},{"_id":"source/bio/index.md","shasum":"0c26430b945daadeb6f4a3292c5c201eedb38f14","modified":1450444394000},{"_id":"source/image/ActivityIndicator.jpg","shasum":"23f3facbf8b71e88dd3eb38143e5a91fefc82066","modified":1453955686000},{"_id":"source/image/CatWaitingHUD.png","shasum":"b882dbb892143f96d00f743a618c75b15475b890","modified":1453955707000},{"_id":"source/image/NavLogo.png","shasum":"550b3c6c0de0f1ce456b3209555d6d1e0b0ed035","modified":1457145936000},{"_id":"source/image/LineImg.png","shasum":"198e014ce2f3f4244c3b7731b470a7cd81029e41","modified":1457187203000},{"_id":"source/image/sodoku.png","shasum":"fa07d58c01385b9f96c1da7926bbbbc46b6bbc8a","modified":1454984708000},{"_id":"source/image/photon_1.png","shasum":"7822d4a009d35dd557b27545d1e96ca6a7be241a","modified":1471508737000},{"_id":"source/tags/index.md","shasum":"10b20c72c2ff5380a35fdd1dbdd24c0f0e5f7c71","modified":1450444394000},{"_id":"source/portfolio/index.md","shasum":"0ccc50f7fd64f562c90d7d11b7f4a86aab2da50c","modified":1477322299000},{"_id":"source/image/2016-gayhub.png","shasum":"31fabef76e50f15f40a7127f4f1b81245ca21d3f","modified":1468494191000},{"_id":"source/image/PRPreview.jpg","shasum":"becca840272d0a711160f2c44d2e1fcbfe62ece4","modified":1453955798000},{"_id":"source/image/background-cover-small.jpg","shasum":"99597a9add574dd10e903dad65abcdd250cf5082","modified":1472108903000},{"_id":"source/image/cover.png","shasum":"be2d06c319066dbed50a7d8777c1ea76bb43dd13","modified":1471580358000},{"_id":"source/image/STPreview.png","shasum":"b7eb5cd561fdb2e60eb2451304647fd572048f79","modified":1453955786000},{"_id":"source/image/FIXPreview.jpg","shasum":"721d3f76b3f703883621f6d601c165eb52409d97","modified":1453955811000},{"_id":"themes/vno/LICENSE","shasum":"8c84b7a07cef17ed42b549a47eefd71bb97ae698","modified":1472050039000},{"_id":"themes/vno/_config.yml","shasum":"5c593105b0717d3f9e6dee3f659eecb6eaedd7da","modified":1472117381000},{"_id":"themes/vno/README.md","shasum":"8e2f82fb55ab34802d0b4348a729c1a641f39643","modified":1472050039000},{"_id":"themes/vno/layout/_partial/comments.ejs","shasum":"fae4605bc74b0ace145e5a11fcf449ae414d720a","modified":1472050039000},{"_id":"themes/vno/layout/_partial/date.ejs","shasum":"7acd28543c62c6a4cdd9a3e49bd1fb77f0e9ab78","modified":1472050039000},{"_id":"themes/vno/layout/_partial/footer.ejs","shasum":"ec4e866ba2d9c9b530365cbd7ff2d501fab40ff7","modified":1472052699000},{"_id":"themes/vno/layout/_partial/side-panel.ejs","shasum":"37ecb5d56354dd3040c15ae53d05631316354532","modified":1472111427000},{"_id":"themes/vno/layout/_partial/google_analytics.ejs","shasum":"eddc6b239bf82409856431d8f0bb5ad8d52ab464","modified":1472050039000},{"_id":"themes/vno/layout/_partial/head.ejs","shasum":"2acbb71294652d2a7343a202ac5b5da5bc3467bb","modified":1477633833000},{"_id":"themes/vno/layout/_partial/social.ejs","shasum":"62c01993c9c1de975c2cf5ab506c7b4a23efe78b","modified":1472052438000},{"_id":"themes/vno/layout/index.ejs","shasum":"83826a3ffe99bc46e129cb52f5c5d4f16883cbb7","modified":1472050039000},{"_id":"themes/vno/layout/layout.ejs","shasum":"b23c2e74b536dd7f9d5db826cb9ab0854ca35b06","modified":1472050039000},{"_id":"themes/vno/layout/_partial/tags.ejs","shasum":"ffcc2844bf1fae8a766e807c316129774bd4ad43","modified":1472050039000},{"_id":"themes/vno/layout/page.ejs","shasum":"24ae0f52dca582d4f76524c928da59d3500b40ff","modified":1472050039000},{"_id":"themes/vno/layout/post.ejs","shasum":"daad9eb35cdd336860200bd16120af098b709175","modified":1472079663000},{"_id":"themes/vno/source/css/_my.styl","shasum":"d3b519fbf615e92ad0821c73fccc502efdb7a642","modified":1472104250000},{"_id":"themes/vno/source/css/_variables.styl","shasum":"8d7e3e75cf2e2806ba2aacde9ef9c3626929e3e2","modified":1472050039000},{"_id":"themes/vno/source/css/_animate.styl","shasum":"a2f854fbdc52a5657dd5e2b95cc96c0da32f3ea2","modified":1472050039000},{"_id":"themes/vno/source/css/_partial/highlight.styl","shasum":"8b2080cb428c55ab54c866bb49372530fd1c8c54","modified":1472443387000},{"_id":"themes/vno/source/css/vno.styl","shasum":"0a8c41378580598adfc0d695e4b6c0fb4f525de9","modified":1472182345000},{"_id":"themes/vno/source/fonts/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1472050039000},{"_id":"themes/vno/source/fonts/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1472050039000},{"_id":"themes/vno/source/fonts/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1472050039000},{"_id":"themes/vno/source/images/favicon.png","shasum":"cd06cda3e017dec9d62179047f9c0340b601a839","modified":1472050039000},{"_id":"themes/vno/source/images/logo.jpg","shasum":"5dcd7e4b99b1fc4c6014772949177a0d22044b5f","modified":1472050039000},{"_id":"themes/vno/source/images/logo2.jpg","shasum":"463b1b42133e7ef7a0d175bf762edd7bc442c1bd","modified":1472050039000},{"_id":"themes/vno/source/js/main.js","shasum":"16837953132cafb52a0c13adae6d016485c7a6c9","modified":1472209590000},{"_id":"source/image/NavigationControlCenter.png","shasum":"2e22eab6da215c5ad0ded0fc5202ea049bfc8a30","modified":1453955731000},{"_id":"themes/vno/source/fonts/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1472050039000},{"_id":"source/image/TrelloNavigation.png","shasum":"b732f90638ba505bc691fe2a8e77778b500635e2","modified":1453955349000},{"_id":"themes/vno/source/fonts/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1472050039000},{"_id":"themes/vno/source/images/show/page.png","shasum":"ae17211d3c6670460caf0eea6ccb9123f16643bf","modified":1472050039000},{"_id":"source/image/background-cover.jpg","shasum":"559148a8837774989e61c474d225bff08186b6e4","modified":1472108560000},{"_id":"themes/vno/source/images/show/list.png","shasum":"450b5d1d886e424dc9479758c9b647db237a6912","modified":1472050039000},{"_id":"source/image/CinemaAnimation.png","shasum":"d0d56b0130a7724af3119c00e45804bae5e52cc4","modified":1453955742000},{"_id":"themes/vno/source/images/background-cover.jpg","shasum":"d71ece107bd5160e713457c8628a78bb723e8da0","modified":1472051155000},{"_id":"themes/vno/source/images/show/home.png","shasum":"3ba70f75a8219791bb743e0551a0197d76db64c2","modified":1472050039000},{"_id":"source/music/test.mp3","shasum":"912bd438c03ab6e879a647b563c314a20f9f3352","modified":1471579285000},{"_id":"public/js/main.js","modified":1478684660563,"shasum":"16837953132cafb52a0c13adae6d016485c7a6c9"},{"_id":"public/images/show/page.png","modified":1478684660581,"shasum":"ae17211d3c6670460caf0eea6ccb9123f16643bf"},{"_id":"public/images/show/list.png","modified":1478684660588,"shasum":"450b5d1d886e424dc9479758c9b647db237a6912"},{"_id":"public/images/show/home.png","modified":1478684660597,"shasum":"3ba70f75a8219791bb743e0551a0197d76db64c2"},{"_id":"public/images/logo2.jpg","modified":1478684660601,"shasum":"463b1b42133e7ef7a0d175bf762edd7bc442c1bd"},{"_id":"public/images/logo.jpg","modified":1478684660603,"shasum":"5dcd7e4b99b1fc4c6014772949177a0d22044b5f"},{"_id":"public/images/favicon.png","modified":1478684660608,"shasum":"cd06cda3e017dec9d62179047f9c0340b601a839"},{"_id":"public/images/background-cover.jpg","modified":1478684660612,"shasum":"d71ece107bd5160e713457c8628a78bb723e8da0"},{"_id":"public/fonts/fontawesome-webfont.woff","modified":1478684660618,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/fonts/fontawesome-webfont.ttf","modified":1478684660620,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/fonts/fontawesome-webfont.svg","modified":1478684660630,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/fonts/fontawesome-webfont.eot","modified":1478684660634,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/fonts/FontAwesome.otf","modified":1478684660638,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/css/vno.css","modified":1478684661326,"shasum":"595c92829e172038073ab3fa7419d198f8c3765f"},{"_id":"public/CNAME","modified":1478684661519,"shasum":"7f17f1abc6cc7bee5d79b462cc845cf88dd9f264"},{"_id":"public/music/test.mp3","modified":1478684661560,"shasum":"912bd438c03ab6e879a647b563c314a20f9f3352"},{"_id":"public/image/sodoku.png","modified":1478684661605,"shasum":"fa07d58c01385b9f96c1da7926bbbbc46b6bbc8a"},{"_id":"public/image/photon_1.png","modified":1478684661608,"shasum":"7822d4a009d35dd557b27545d1e96ca6a7be241a"},{"_id":"public/image/cover.png","modified":1478684661610,"shasum":"be2d06c319066dbed50a7d8777c1ea76bb43dd13"},{"_id":"public/image/background-cover.jpg","modified":1478684661614,"shasum":"559148a8837774989e61c474d225bff08186b6e4"},{"_id":"public/image/background-cover-small.jpg","modified":1478684661621,"shasum":"99597a9add574dd10e903dad65abcdd250cf5082"},{"_id":"public/image/TrelloNavigation.png","modified":1478684661627,"shasum":"b732f90638ba505bc691fe2a8e77778b500635e2"},{"_id":"public/image/STPreview.png","modified":1478684661635,"shasum":"b7eb5cd561fdb2e60eb2451304647fd572048f79"},{"_id":"public/image/PRPreview.jpg","modified":1478684661650,"shasum":"becca840272d0a711160f2c44d2e1fcbfe62ece4"},{"_id":"public/image/NavigationControlCenter.png","modified":1478684661670,"shasum":"2e22eab6da215c5ad0ded0fc5202ea049bfc8a30"},{"_id":"public/image/NavLogo.png","modified":1478684661680,"shasum":"550b3c6c0de0f1ce456b3209555d6d1e0b0ed035"},{"_id":"public/image/LineImg.png","modified":1478684661683,"shasum":"198e014ce2f3f4244c3b7731b470a7cd81029e41"},{"_id":"public/image/FIXPreview.jpg","modified":1478684661687,"shasum":"721d3f76b3f703883621f6d601c165eb52409d97"},{"_id":"public/image/CinemaAnimation.png","modified":1478684661696,"shasum":"d0d56b0130a7724af3119c00e45804bae5e52cc4"},{"_id":"public/image/CatWaitingHUD.png","modified":1478684661702,"shasum":"b882dbb892143f96d00f743a618c75b15475b890"},{"_id":"public/image/ActivityIndicator.jpg","modified":1478684661704,"shasum":"23f3facbf8b71e88dd3eb38143e5a91fefc82066"},{"_id":"public/image/2016-gayhub.png","modified":1478684661710,"shasum":"31fabef76e50f15f40a7127f4f1b81245ca21d3f"},{"_id":"public/favicon.ico","modified":1478684661714,"shasum":"8e2f1ece0b64bc8fd00c1a7beb1b4c6aa7b1ecb3"},{"_id":"public/tags/index.html","modified":1478684661783,"shasum":"5184680b1d9a143d5cb255f5948d0c6f7785304e"},{"_id":"public/portfolio/index.html","modified":1478684661808,"shasum":"46953e465c75e79f544d69133b8c870ba711202a"},{"_id":"public/categories/index.html","modified":1478684661833,"shasum":"f6a4354970a3979f2ae2ef5ec1f63b292842d737"},{"_id":"public/bio/index.html","modified":1478684661862,"shasum":"e64790d832a255dcef67ec1460cddb017eef5ea5"},{"_id":"public/about/index.html","modified":1478684661883,"shasum":"bbe8316ec16d8c7d3852e95f271b4ee5e8c064c2"},{"_id":"public/2016/11/09/How-to-draw-a-Wireframe-Shader-for-a-Cube-in-Rajawali-under-OpenGL-ES-2-0/index.html","modified":1478685153257,"shasum":"2fb20949057cc82459655d6504e2feda1f20fbff"},{"_id":"public/2016/11/02/Multi-Touch-Bar-UI-开发入门指南/index.html","modified":1478684661950,"shasum":"39515f96272f9d6e5829d16f75dbd7219ee98c05"},{"_id":"public/2016/10/24/ADB-两三事-残/index.html","modified":1478684661988,"shasum":"95c0db09ae24ec440f2472c01793d1873762c918"},{"_id":"public/2016/10/21/如何在-WKWebView-中实现-Safari-原生的阅读模式/index.html","modified":1478684662017,"shasum":"ef0c7d4441b7d1cb28bcebb09d629b0ac11c4794"},{"_id":"public/2016/09/05/2016-09-05-基督山伯爵/index.html","modified":1478684662045,"shasum":"85f7f74e6be347626091b23e0acc19db621204c7"},{"_id":"public/2016/08/29/iOS-Airplay-中的-Airtunes-Server-服务协议和机制详解以及-Android-Demo-的实现/index.html","modified":1478684662078,"shasum":"5d5fde892a168b287a75ae1903fbb3c39f3aa31c"},{"_id":"public/2016/08/26/Leetcode-Database-刷题记录/index.html","modified":1478684662112,"shasum":"89f8f3621a451df9abcb49a924293c347b412cb6"},{"_id":"public/2016/08/18/使用-Photon-在-Unity-里快速搭建一个多人联机游戏/index.html","modified":1478684662139,"shasum":"c31350d7c4e4b5d57a797b2f8c8009320a522142"},{"_id":"public/2016/08/13/AVAudioPlayer的几个细节/index.html","modified":1478684662160,"shasum":"25e6506b55abf2e3bbdf3ab9d06e880c3af7914d"},{"_id":"public/2016/07/14/我的-GayHub-2016/index.html","modified":1478684662201,"shasum":"23880843451c1c44894a4c388d01fd8d79a658c9"},{"_id":"public/2016/05/28/“人工智能”邪教/index.html","modified":1478684662241,"shasum":"2f08ec3cd7fa775041095a4ebb79a63d31505d26"},{"_id":"public/2016/04/11/2016-04-11-去战斗/index.html","modified":1478684662303,"shasum":"c8d2b27eda316168ea49187b1ac347bcfebb799a"},{"_id":"public/2016/03/23/我是怎么踩过在-OSX-上录屏的坑的/index.html","modified":1478684662330,"shasum":"ed5d2ffc2fe4c2c8a09c096d8117a0cf2d51ea55"},{"_id":"public/2016/03/15/2016-03-15/index.html","modified":1478684662359,"shasum":"1abc9b05b1e7d7c63fd184c2543fdba5ae2838a6"},{"_id":"public/2016/03/08/知乎-Hackathon-之前对于知乎产品形态的一些疯狂想法/index.html","modified":1478684662391,"shasum":"da67427c6aacbca5383201e769d603a77d727bfc"},{"_id":"public/2016/02/16/不要想当然的就使用UITableView/index.html","modified":1478684662420,"shasum":"9063f57d6d739d5103d362f66f65eb00dcad234a"},{"_id":"public/2016/02/06/过年/index.html","modified":1478684662445,"shasum":"9197ac6311290fdc45fa746890c21e2ee2c79136"},{"_id":"public/2016/01/27/三件小事/index.html","modified":1478684662486,"shasum":"b255a132bbd7a711da411f17c5a58ff985fd7990"},{"_id":"public/2016/01/20/无题-20160120/index.html","modified":1478684662506,"shasum":"56051e88fbb2e362df3d323c97c6bbf4949ebf70"},{"_id":"public/2015/12/21/2015/index.html","modified":1478684662535,"shasum":"7bea5c78c2d619b62ff5f2dfc212c18d0c2dfa4a"},{"_id":"public/2015/12/21/语/index.html","modified":1478684662561,"shasum":"9a972a956589d536c7c36f14dd0190f6b7cb9bf8"},{"_id":"public/2015/12/19/谈谈我对Hackathon的理解/index.html","modified":1478684662584,"shasum":"b38f969b199430eb5e302fc48b9f7769f8ecf082"},{"_id":"public/2015/10/22/runloop初窥/index.html","modified":1478684662606,"shasum":"0a73fdf2d5a75912ebdf5a945a5dc7447480732c"},{"_id":"public/2015/10/22/objective-c-runtime是什么/index.html","modified":1478684662632,"shasum":"fe50091d4bc157154bea9f5a003f0c2e95e1e574"},{"_id":"public/2015/07/19/tornado-TCP服务器间内部通讯TCP服务器性能验证/index.html","modified":1478684662677,"shasum":"8d7425c1e5f9132173977f68391514beb74ba756"},{"_id":"public/2015/05/19/Python利用深度优先搜索解数独程序的实现/index.html","modified":1478684662698,"shasum":"b6f8e2bb0a00a83b96d017438398b72d1d162d32"},{"_id":"public/2015/04/01/怎么设计和实现一个Newsfeed系统/index.html","modified":1478684662717,"shasum":"48dca523ce38f8328200661da5710592043df2a2"},{"_id":"public/2015/02/02/UIColor-colorWithRed-green-blue-alpha-的正确用法/index.html","modified":1478684662743,"shasum":"030c10b96e5106f0be5139d493dc3697fcc25d0e"},{"_id":"public/2014/12/26/PHP图片处理-透明水印的处理和添加/index.html","modified":1478684662769,"shasum":"0a42496ca7381a7c0b819628f2c1bb0c870fb5f7"},{"_id":"public/2014/12/12/Ubuntu下重置MySQL的root密码/index.html","modified":1478684662795,"shasum":"795ca75b610383df1dd75ea65dee6e8af1b1f8b7"},{"_id":"public/2014/12/10/iOS-静态库封装和使用方法/index.html","modified":1478684662826,"shasum":"4d12d420325a82e41edc6cc68064c63e3a21dd16"},{"_id":"public/archives/index.html","modified":1478684662943,"shasum":"b7ca544e598d20fe2518d1111ce6a9c53ac64553"},{"_id":"public/archives/page/2/index.html","modified":1478684663022,"shasum":"76fdb91c13af0020a500b43c21c3e322eaa31115"},{"_id":"public/archives/page/3/index.html","modified":1478684663106,"shasum":"ae61d7dc10a3e5ef9436e46c06c1fcaa35b6e766"},{"_id":"public/archives/page/4/index.html","modified":1478684663128,"shasum":"9c4eccee9c93a7ec7d45de38bc88d3972e771ce2"},{"_id":"public/archives/2014/index.html","modified":1478684663161,"shasum":"e283a621dfa0abc123061874adfd6e91a93247a8"},{"_id":"public/archives/2014/12/index.html","modified":1478684663197,"shasum":"e283a621dfa0abc123061874adfd6e91a93247a8"},{"_id":"public/archives/2015/index.html","modified":1478684663283,"shasum":"08f68dcb67b5d63d88c8d99059c4dea8e1242ffe"},{"_id":"public/archives/2015/02/index.html","modified":1478684663311,"shasum":"f179b325d5100ed73afe4d1a87a47048a5a89de4"},{"_id":"public/archives/2015/04/index.html","modified":1478684663351,"shasum":"e63f5534e8f9eeda70069e286becf4820d9aeb27"},{"_id":"public/archives/2015/05/index.html","modified":1478684663376,"shasum":"9401eea1427981c9a12eaf9fd4ab66111e2ac6de"},{"_id":"public/archives/2015/07/index.html","modified":1478684663399,"shasum":"86e0872610fee2fb4f219f8a612eceff554f31c4"},{"_id":"public/archives/2015/10/index.html","modified":1478684663438,"shasum":"43ebb54843402e6877317aef403b38347b9cc1e0"},{"_id":"public/archives/2015/12/index.html","modified":1478684663481,"shasum":"e5c21b289261ef02e375fdade77fb8525b4a786f"},{"_id":"public/archives/2016/index.html","modified":1478684663618,"shasum":"403e167e4edd7aa5676deb911fa58878eeec85f2"},{"_id":"public/archives/2016/page/2/index.html","modified":1478684663704,"shasum":"e25f2fb1ff13b1cafe27e9165554b17f0c640c9a"},{"_id":"public/archives/2016/01/index.html","modified":1478684663783,"shasum":"54995145edbf754f09d2e49c38c743c22661e916"},{"_id":"public/archives/2016/02/index.html","modified":1478684663791,"shasum":"ef86b58e4ca2f76d6ffcd1e4d274db9952239253"},{"_id":"public/archives/2016/03/index.html","modified":1478684663802,"shasum":"e2b4bc71ec9018a21856a117c1fadc374c32eac3"},{"_id":"public/archives/2016/04/index.html","modified":1478684663806,"shasum":"7ac88dbb675a101fdf0fb033170ba9aac095ca65"},{"_id":"public/archives/2016/05/index.html","modified":1478684663810,"shasum":"36c0606a3b0d7a3797ce5b10f0813c3c4eccf834"},{"_id":"public/archives/2016/07/index.html","modified":1478684663814,"shasum":"fc0bedf89856225e3a3b0342a64791d60dda4bce"},{"_id":"public/archives/2016/08/index.html","modified":1478684663828,"shasum":"5775e527af900c075ebd60e078367c87220956e4"},{"_id":"public/archives/2016/09/index.html","modified":1478684663835,"shasum":"4628bed29b3ac5066c8e233e7632cd978b2775f2"},{"_id":"public/archives/2016/10/index.html","modified":1478684663842,"shasum":"70203be2bc3a6343ffd5888822fc65a02458dde4"},{"_id":"public/archives/2016/11/index.html","modified":1478684663854,"shasum":"210d829dfa2a376d8b2ddb6af9d3cb3b2395b668"},{"_id":"public/categories/闲言碎语/index.html","modified":1478684663878,"shasum":"d707529e241dfc67f765cd4025df35ae6acbd581"},{"_id":"public/categories/闲言碎语/page/2/index.html","modified":1478684663887,"shasum":"13e38e5d752a55baa540cfd971a830538379fd89"},{"_id":"public/categories/Hacker/index.html","modified":1478684663892,"shasum":"fa0ad09b96cd619b864ac308168c9b028da01a8f"},{"_id":"public/categories/Cocoa入门？/index.html","modified":1478684663898,"shasum":"51be41efcdd6d80b21234c54f0445435a0fe4f0b"},{"_id":"public/categories/Python学习笔记/index.html","modified":1478684663903,"shasum":"e630a3c343d6e00d3d7e0efc87e2cd6f20b66ab0"},{"_id":"public/categories/iOS菜鸟心得/index.html","modified":1478684663921,"shasum":"e90fa8b1ab84724f2a4ab77c855ebc6b06ae6db7"},{"_id":"public/categories/细心写的技术博客/index.html","modified":1478684663927,"shasum":"2a2e43deb4d1dc630ff28fd3b72e621a11a6436b"},{"_id":"public/categories/Linux服务器笔记/index.html","modified":1478684663931,"shasum":"7c626c71510a5744d223cb5bff86d9e4ca8fd57e"},{"_id":"public/categories/Python学习/index.html","modified":1478684663937,"shasum":"9401eea1427981c9a12eaf9fd4ab66111e2ac6de"},{"_id":"public/categories/PHP大神养成/index.html","modified":1478684663944,"shasum":"920797be483177f6e26503408f4985cbd1252136"},{"_id":"public/categories/安卓菜鸟心得/index.html","modified":1478684663951,"shasum":"e2b19f5c447a790945f3bd783a85e5a64ce29070"},{"_id":"public/atom.xml","modified":1478685153678,"shasum":"8062bb28c41b13a11e5fd15ed7ff993cbe876317"},{"_id":"public/index.html","modified":1478684663984,"shasum":"0b5dcb9f8171e3539987c4b087b44225672a74ab"},{"_id":"public/page/2/index.html","modified":1478684664014,"shasum":"3358054784d5d7e1764f0dcb6320ee33e84ff0f3"},{"_id":"public/page/3/index.html","modified":1478684664049,"shasum":"485bc7c2d58b3097443452e616547caea4405ba0"},{"_id":"public/page/4/index.html","modified":1478684664056,"shasum":"754278517191d5c90548de7809dec143d263d8da"},{"_id":"public/tags/Hackathon/index.html","modified":1478684664068,"shasum":"0e5c072e76a7f401ef04698812b56597d280d8d4"},{"_id":"public/tags/Cocoa/index.html","modified":1478684664078,"shasum":"61124d6f3a2a8a870cdaa0e071ec6d8408a72809"},{"_id":"public/tags/AVFoundation/index.html","modified":1478684664090,"shasum":"71d84dccc581ba9896fe56452401efdb38cd82ff"},{"_id":"public/tags/Newsfeed/index.html","modified":1478684664100,"shasum":"e63f5534e8f9eeda70069e286becf4820d9aeb27"},{"_id":"public/tags/celery/index.html","modified":1478684664105,"shasum":"e63f5534e8f9eeda70069e286becf4820d9aeb27"},{"_id":"public/tags/djcelery/index.html","modified":1478684664113,"shasum":"e63f5534e8f9eeda70069e286becf4820d9aeb27"},{"_id":"public/tags/redis/index.html","modified":1478684664119,"shasum":"e63f5534e8f9eeda70069e286becf4820d9aeb27"},{"_id":"public/tags/stream-framework/index.html","modified":1478684664126,"shasum":"e63f5534e8f9eeda70069e286becf4820d9aeb27"},{"_id":"public/tags/WKWebView/index.html","modified":1478684664133,"shasum":"ac11868c2633c417160891cbfbca1ed33fe72fd3"},{"_id":"public/tags/WebKit/index.html","modified":1478684664141,"shasum":"ac11868c2633c417160891cbfbca1ed33fe72fd3"},{"_id":"public/tags/Safari-阅读模式/index.html","modified":1478684664145,"shasum":"ac11868c2633c417160891cbfbca1ed33fe72fd3"},{"_id":"public/tags/Unity/index.html","modified":1478684664150,"shasum":"94928265fd67905f2f463986763bb8d12f097ccd"},{"_id":"public/tags/Photon/index.html","modified":1478684664154,"shasum":"94928265fd67905f2f463986763bb8d12f097ccd"},{"_id":"public/tags/UITableView/index.html","modified":1478684664160,"shasum":"55e5a495ae15feec3613c99d8abf8e4bed5956e0"},{"_id":"public/tags/NSObject/index.html","modified":1478684664171,"shasum":"80f55a1c2d30db14b3ce10331761af69dae74c78"},{"_id":"public/tags/id/index.html","modified":1478684664179,"shasum":"80f55a1c2d30db14b3ce10331761af69dae74c78"},{"_id":"public/tags/weak/index.html","modified":1478684664188,"shasum":"80f55a1c2d30db14b3ce10331761af69dae74c78"},{"_id":"public/tags/assign/index.html","modified":1478684664191,"shasum":"80f55a1c2d30db14b3ce10331761af69dae74c78"},{"_id":"public/tags/NS-DESIGNATED-INITIALIZER/index.html","modified":1478684664195,"shasum":"80f55a1c2d30db14b3ce10331761af69dae74c78"},{"_id":"public/tags/哲学/index.html","modified":1478684664200,"shasum":"36c0606a3b0d7a3797ce5b10f0813c3c4eccf834"},{"_id":"public/tags/扯淡/index.html","modified":1478684664205,"shasum":"36c0606a3b0d7a3797ce5b10f0813c3c4eccf834"},{"_id":"public/tags/tornado/index.html","modified":1478684664213,"shasum":"86e0872610fee2fb4f219f8a612eceff554f31c4"},{"_id":"public/tags/TCP/index.html","modified":1478684664224,"shasum":"86e0872610fee2fb4f219f8a612eceff554f31c4"},{"_id":"public/tags/iOS/index.html","modified":1478684664235,"shasum":"635f001e44db9322a2f7c66dcb782fb98f6fd896"},{"_id":"public/tags/runloop/index.html","modified":1478684664240,"shasum":"da0ff5de2027de0b6a4a66009565039c4326bc92"},{"_id":"public/tags/NSThread/index.html","modified":1478684664248,"shasum":"da0ff5de2027de0b6a4a66009565039c4326bc92"},{"_id":"public/tags/runtime/index.html","modified":1478684664252,"shasum":"1c7b212bcd8cf07c55464490561539024b8b1c12"},{"_id":"public/tags/Objective-C/index.html","modified":1478684664256,"shasum":"1c7b212bcd8cf07c55464490561539024b8b1c12"},{"_id":"public/tags/objc-msgSend/index.html","modified":1478684664260,"shasum":"1c7b212bcd8cf07c55464490561539024b8b1c12"},{"_id":"public/tags/iOS静态库/index.html","modified":1478684664268,"shasum":"1d455d99deef11e9c03e01508346357c1bd2e7c1"},{"_id":"public/tags/Airplay/index.html","modified":1478684664274,"shasum":"2a2e43deb4d1dc630ff28fd3b72e621a11a6436b"},{"_id":"public/tags/Android/index.html","modified":1478684664284,"shasum":"11e193ee3dff65022e12e70d1878887b2d2705ff"},{"_id":"public/tags/Ubuntu/index.html","modified":1478684664289,"shasum":"7c626c71510a5744d223cb5bff86d9e4ca8fd57e"},{"_id":"public/tags/MySQL/index.html","modified":1478684664299,"shasum":"7736f6f869ca0e03d5b95eaed5bdf942d9de5681"},{"_id":"public/tags/UIColor/index.html","modified":1478684664303,"shasum":"f179b325d5100ed73afe4d1a87a47048a5a89de4"},{"_id":"public/tags/python/index.html","modified":1478684664307,"shasum":"9401eea1427981c9a12eaf9fd4ab66111e2ac6de"},{"_id":"public/tags/python数独，-深度优先搜索/index.html","modified":1478684664313,"shasum":"9401eea1427981c9a12eaf9fd4ab66111e2ac6de"},{"_id":"public/tags/PHP图片处理，水印/index.html","modified":1478684664319,"shasum":"920797be483177f6e26503408f4985cbd1252136"},{"_id":"public/tags/Leetcode/index.html","modified":1478684664326,"shasum":"a99f8fb07fb93953f694a4bac8f2f237b0c17206"},{"_id":"public/tags/OpenGL-ES/index.html","modified":1478684664333,"shasum":"df66a04846d8d944039d4e132154fd240634e7f8"},{"_id":"public/tags/GLSL/index.html","modified":1478684664338,"shasum":"df66a04846d8d944039d4e132154fd240634e7f8"},{"_id":"public/tags/Shader/index.html","modified":1478684664348,"shasum":"df66a04846d8d944039d4e132154fd240634e7f8"},{"_id":"public/tags/Wireframe/index.html","modified":1478684664354,"shasum":"df66a04846d8d944039d4e132154fd240634e7f8"},{"_id":"public/tags/AVAudioPlayer/index.html","modified":1478684664358,"shasum":"b9b8f1ebcd99097846bead69180bbe2641f9006a"},{"_id":"public/tags/ADB/index.html","modified":1478684664361,"shasum":"76ccdb8d9e6936b5cc96b5762282bfb03f14547b"},{"_id":"public/tags/Android-Debug-Bridge/index.html","modified":1478684664364,"shasum":"76ccdb8d9e6936b5cc96b5762282bfb03f14547b"},{"_id":"public/tags/残念/index.html","modified":1478684664370,"shasum":"76ccdb8d9e6936b5cc96b5762282bfb03f14547b"},{"_id":"public/tags/智障/index.html","modified":1478684664377,"shasum":"76ccdb8d9e6936b5cc96b5762282bfb03f14547b"},{"_id":"public/tags/闲言碎语/index.html","modified":1478684664385,"shasum":"b776a02d28d632d36a9b6ea00fd01cd6193fd51b"},{"_id":"public/assets/js/APlayer.min.js","modified":1478684664388,"shasum":"3d85f0089e50226467642c1ecadd1aa7b2a47972"}],"Category":[{"name":"闲言碎语","_id":"civaqnytw0006j4rbg7cdf9r0"},{"name":"Hacker","_id":"civaqnyu50009j4rb38g31okf"},{"name":"Cocoa入门？","_id":"civaqnyuo000nj4rbab48yccg"},{"name":"Python学习笔记","_id":"civaqnyut000uj4rbmakhk9hc"},{"name":"iOS菜鸟心得","_id":"civaqnyuy0017j4rb1wft54fd"},{"name":"细心写的技术博客","_id":"civaqnywc002yj4rbcr4yk5vn"},{"name":"Linux服务器笔记","_id":"civaqnywj0036j4rb7uolmt8i"},{"name":"Python学习","_id":"civaqnywr003hj4rb2dn7b42j"},{"name":"PHP大神养成","_id":"civaqnywx003oj4rbhzfj6xvz"},{"name":"安卓菜鸟心得","_id":"civaqnyx90040j4rbq08pw9ws"}],"Data":[],"Page":[{"title":"TagCloud","date":"2015-10-22T08:51:37.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"title: TagCloud\ndate: 2015-10-22 16:51:37\ntype: \"tags\"\ncomments: false\n---\n","updated":"2015-12-18T13:13:14.000Z","path":"tags/index.html","layout":"page","_id":"civaqnysy0000j4rb2e8fjdvu"},{"title":"Portfolio","date":"2015-10-22T09:04:18.000Z","type":"bio","comments":1,"_content":"\n\n### Hackathon Projects\n\n成立了 **hACKbUSTER黑客松团队**。  \n这个团队是以我和小萌为核心，召集了一大群各路小伙伴一起组建的。\n\n目前为止参与的比赛以及所获奖项如下：\n\n- **#RANK 1#** 2015 Dorahack Beihang University \n- **#RANK 1#** 2015 Segmentfault Beijing Hackathon\n- **#RANK 1#** 2015 中国美院 China Art Hackathon\n- **#RANK 3#** 2016 Uber China Hackathon\n- **#RANK 1#** 2016 Segmentfault Shenzhen Hackathon\n- **#RANK 1#** 2016 Segmentfault Beijing Hackathon\n- **#RANK 1#** 2016 HackerX Tsinghua University\n- **#RANK 3#** 2016 Shanghai i-Lab Hackathon\n- **#NORANK#** 2016 Shanghai HACKxFDU\n\n这个组织的 Github 主页在[这里](https://github.com/hACKbUSTER)，我们坚持每次比赛的代码和设计稿都会在 Github 上开源。\n\n### Connect ++\n\n[仓库地址](https://github.com/hACKbUSTER/ConnectPlusPlus) \n\nConnect ++ is a LBS information sharing platform. Simple click to share your information and simple click to view the information shared by others, we connect the citizens in this city together to build a smarter city. Furthermore, we could provide open API for public service and utilities to upload their information onto our platform, with more latest and location-related information. It could be the fundamental platform to build smarter city.\n\n<img src=\"https://ooo.0o0.ooo/2016/10/24/580e247fc5033.jpg\" width = \"60%\" style = \"text-align:center\"/>\n\n### Project M\n\n[仓库地址](https://github.com/hACKbUSTER/ProjectM-SafariExtension)\n\n**A live video chat room based on Browser Extension**. Right now we only developed extension for Safaris, but further we definitely will develop versions for Chrome and Firefox.\n\nUsing this extension, you will be randomly distributed into a chat room with some audiences who were watching the same web page or video as you were, these videos could be the NBA Finals, World Cup Finals, any Sports Live Video or some important live events such as WWDC. With Project M, you can easily connect with other people who were watching the same thing at almost the same time, even more faster and better than the older Danmaku. You can find some friends to watch the sport games together, find some developers all around the world to expect the Apple WWDC together, even more you can criticize your favorite TV series with other people who are also interested.\n\n### Smart Traveller\n[仓库地址](https://github.com/hACKbUSTER/UberGuide-iOS)  \nObjective-C / Swift / leancloud NodeJS \n\n<img src=\"https://ooo.0o0.ooo/2016/10/24/580e1bf7998d3.png\" width = \"40%\" style = \"text-align:center\"/>\n\n### Periscope\n[仓库地址](https://github.com/hACKbUSTER/Renaissance)\nScenekit / Max Msp音乐编程 / 基于UDP协议的OSC协议  \n\n<img src=\"https://ooo.0o0.ooo/2016/10/24/580e1bf774a2d.jpg\" width = \"60%\" style = \"text-align:center\"/>\n\n### Fix++\n[仓库地址](https://github.com/hACKbUSTER/FixPlusPlus)\nUnity AR /  3DMax & MODO\n\n<img src=\"https://ooo.0o0.ooo/2016/10/24/580e1bf7bdd02.jpg\" width = \"60%\" text-align = \"center\"/>\n\n## Open Source\n成立了**Animatious一起动画开源组**。  \n这个团队以很多优秀的年轻开发者和年轻设计师为主力，已经贡献了一些高质量的开源项目，技术分享和设计原稿。我在成立之前和之后写了一些开源的动效控件库。  \n这个组织的 Github 主页在[这里](https://github.com/Animatious)。\n\n### SCActivityIndicator\n[仓库地址](https://github.com/SergioChan/SCActivityIndicatorView  )\n\n![image](/image/ActivityIndicator.jpg)\n\n\n### SCCatWaitingHUD\n[仓库地址](https://github.com/SergioChan/SCCatWaitingHUD)\n\n![image](/image/CatWaitingHUD.png)\n\n### SCCinemaAnimation\n[仓库地址](https://github.com/SergioChan/SCCinemaAnimation)\n\n![image](/image/CinemaAnimation.png)\n\n### SCNavigationControlCenter\n[仓库地址](https://github.com/SergioChan/SCNavigationControlCenter)\n\n![image](/image/NavigationControlCenter.png)\n\n### SCTrelloNavigation\n[仓库地址](https://github.com/SergioChan/SCTrelloNavigation) \n\n![image](/image/TrelloNavigation.png)\n\n### SCAwesomeNetworking\n[仓库地址](https://github.com/SergioChan/SCAwesomeNetworking)\n\n\n## 其他项目","source":"portfolio/index.md","raw":"title: Portfolio\ndate: 2015-10-22 17:04:18\ntype: \"bio\"\ncomments: true\n---\n\n\n### Hackathon Projects\n\n成立了 **hACKbUSTER黑客松团队**。  \n这个团队是以我和小萌为核心，召集了一大群各路小伙伴一起组建的。\n\n目前为止参与的比赛以及所获奖项如下：\n\n- **#RANK 1#** 2015 Dorahack Beihang University \n- **#RANK 1#** 2015 Segmentfault Beijing Hackathon\n- **#RANK 1#** 2015 中国美院 China Art Hackathon\n- **#RANK 3#** 2016 Uber China Hackathon\n- **#RANK 1#** 2016 Segmentfault Shenzhen Hackathon\n- **#RANK 1#** 2016 Segmentfault Beijing Hackathon\n- **#RANK 1#** 2016 HackerX Tsinghua University\n- **#RANK 3#** 2016 Shanghai i-Lab Hackathon\n- **#NORANK#** 2016 Shanghai HACKxFDU\n\n这个组织的 Github 主页在[这里](https://github.com/hACKbUSTER)，我们坚持每次比赛的代码和设计稿都会在 Github 上开源。\n\n### Connect ++\n\n[仓库地址](https://github.com/hACKbUSTER/ConnectPlusPlus) \n\nConnect ++ is a LBS information sharing platform. Simple click to share your information and simple click to view the information shared by others, we connect the citizens in this city together to build a smarter city. Furthermore, we could provide open API for public service and utilities to upload their information onto our platform, with more latest and location-related information. It could be the fundamental platform to build smarter city.\n\n<img src=\"https://ooo.0o0.ooo/2016/10/24/580e247fc5033.jpg\" width = \"60%\" style = \"text-align:center\"/>\n\n### Project M\n\n[仓库地址](https://github.com/hACKbUSTER/ProjectM-SafariExtension)\n\n**A live video chat room based on Browser Extension**. Right now we only developed extension for Safaris, but further we definitely will develop versions for Chrome and Firefox.\n\nUsing this extension, you will be randomly distributed into a chat room with some audiences who were watching the same web page or video as you were, these videos could be the NBA Finals, World Cup Finals, any Sports Live Video or some important live events such as WWDC. With Project M, you can easily connect with other people who were watching the same thing at almost the same time, even more faster and better than the older Danmaku. You can find some friends to watch the sport games together, find some developers all around the world to expect the Apple WWDC together, even more you can criticize your favorite TV series with other people who are also interested.\n\n### Smart Traveller\n[仓库地址](https://github.com/hACKbUSTER/UberGuide-iOS)  \nObjective-C / Swift / leancloud NodeJS \n\n<img src=\"https://ooo.0o0.ooo/2016/10/24/580e1bf7998d3.png\" width = \"40%\" style = \"text-align:center\"/>\n\n### Periscope\n[仓库地址](https://github.com/hACKbUSTER/Renaissance)\nScenekit / Max Msp音乐编程 / 基于UDP协议的OSC协议  \n\n<img src=\"https://ooo.0o0.ooo/2016/10/24/580e1bf774a2d.jpg\" width = \"60%\" style = \"text-align:center\"/>\n\n### Fix++\n[仓库地址](https://github.com/hACKbUSTER/FixPlusPlus)\nUnity AR /  3DMax & MODO\n\n<img src=\"https://ooo.0o0.ooo/2016/10/24/580e1bf7bdd02.jpg\" width = \"60%\" text-align = \"center\"/>\n\n## Open Source\n成立了**Animatious一起动画开源组**。  \n这个团队以很多优秀的年轻开发者和年轻设计师为主力，已经贡献了一些高质量的开源项目，技术分享和设计原稿。我在成立之前和之后写了一些开源的动效控件库。  \n这个组织的 Github 主页在[这里](https://github.com/Animatious)。\n\n### SCActivityIndicator\n[仓库地址](https://github.com/SergioChan/SCActivityIndicatorView  )\n\n![image](/image/ActivityIndicator.jpg)\n\n\n### SCCatWaitingHUD\n[仓库地址](https://github.com/SergioChan/SCCatWaitingHUD)\n\n![image](/image/CatWaitingHUD.png)\n\n### SCCinemaAnimation\n[仓库地址](https://github.com/SergioChan/SCCinemaAnimation)\n\n![image](/image/CinemaAnimation.png)\n\n### SCNavigationControlCenter\n[仓库地址](https://github.com/SergioChan/SCNavigationControlCenter)\n\n![image](/image/NavigationControlCenter.png)\n\n### SCTrelloNavigation\n[仓库地址](https://github.com/SergioChan/SCTrelloNavigation) \n\n![image](/image/TrelloNavigation.png)\n\n### SCAwesomeNetworking\n[仓库地址](https://github.com/SergioChan/SCAwesomeNetworking)\n\n\n## 其他项目","updated":"2016-10-24T15:18:19.000Z","path":"portfolio/index.html","layout":"page","_id":"civaqnyt50001j4rbuzk4pqkl"},{"title":"categories","date":"2015-10-22T08:48:30.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"title: categories\ndate: 2015-10-22 16:48:30\ntype: \"categories\"\ncomments: false\n---\n","updated":"2015-12-18T13:13:14.000Z","path":"categories/index.html","layout":"page","_id":"civaqnytg0002j4rbiqbsdjcq"},{"title":"自传","date":"2015-10-22T09:04:18.000Z","type":"bio","comments":1,"_content":"\n\n\n大三上学期的我 2013-11-24\n我明白也许这个时候就对大学生活做个总结之类的有点不自量力，但鉴于我也是个心怀梦想希望走的更远的小屌丝，有时候坐在图书馆周日午后的阳光里看着满阅览室的汉子和零星的女汉子，也不免心生悲凉和感慨希望写下点什么。所以，我还是先从大学之前说起吧。如果，正在看的你是一个高富帅，也许我们的经历无法产生共鸣，若是觉得无聊，看官们随意。\n\n大学之前\n所有人在刚进入大学的时候，就知识来说，也许大多数人是站在同一起跑线上的，特别是来到我们软院的，我想也有那么一部分人都是一起苦逼的被调剂来的。但是，其实每个人在人生的道路上，不是说上了大学就重新开始人生了，而是继续前行，所以我们每个人又是在不同的位置和方向进入了大学。新认识的小伙伴们大部分时候侃的话题难免是自己的高中生活，有的心有余悸，有的心有不甘，有的好生怀念，这就是不同所在。我隔壁宿舍的小伙伴，来自一个黑暗不见五指的学习环境，高中不允许男女生同行，食堂男女生分区进食还有老师监视，每天六点开始早自习晚上十一点结束晚自习，没有娱乐活动，对于他来说离开那种环境我都能替他感到深深的解脱感；还有一个来自一所大名鼎鼎的某某监狱的小伙伴，高中三年被压抑和束缚，也许他们当中有些还会怀念，有些心生恐惧，但相比于周遭的所有同学，我想我算是比较幸运的，来自南方的一所比较开放的高中。\n可以某种程度上来说，除了高考前每周一次的练习和自己做的卷子，高一到高三我的老师没有强迫我们交任何作业，这就导致了我们集体涣散，一群曾经的名列前茅开始在各种活动中崭露头角，然后在各种考试中被虐的满地找牙。但好在那时候的老师是宽容的，总是给我们很多鼓励和支持，即使我挂科也会毅然决然的给我写上一个大大的90，我想，那段日子对我日后真的影响特别深远。后来，在各种早恋和课外活动中，我们混到了高二下学期，那时候我们班里发生了一件大事，以至于影响了我一生。某一天晚上晚自习的时候当我还和小伙伴们聊得正嗨的时候忽然有老师来教室里，告诉我们班主任出事了。我们根本没想到事情会那么难以接受和不可想象，给了我最多鼓励的班主任和她丈夫在散步的时候，一个据称是神经病的人本着情侣都去死的心态拿着水果刀就刺向了班主任的丈夫。他很优秀，她也很优秀，但就这么离谱的事情，我的班主任无法接受这一事实，最后悲痛的离开了我们去了外地慢慢调养。而我也忽然意识到，再不努力就没办法让她看到她所肯定的那个我了。那时候，是高二的寒假前。那时候我还是倒数。但我总是把相信自己放在第一位，于是就有了后来的高考，来到了北航。但这些都不是重点，这些都只是铺垫。\n\n大一入学\n我想很多软院的男生在刚入学的时候，心中总会牵挂着那样一个妹子，或许是女朋友，或许只是心上人，但我相信在高考结束之后那段迷茫、无聊、空虚的日子里，我们总会那样疯狂地失去理智过。\n高考结束后我谈了一次轰轰烈烈的恋爱，说是轰轰烈烈是因为在我父母都不知情的情况下我所有的好朋友都已经极力反对了，所以我冒着失去几乎所有朋友的风险失去理智了一回。过程相当庸俗，我想恋爱过的人大都明白这些过程，但我想说的是，当我们说着不分离的誓言各自去了不同的城市上了大学之后，我忽然发现周围有那么多相同处境的小伙伴。然后，当我开了个好头，在军训刚结束她就忽然人间蒸发了之后一个月的时间里，我看到大家接连赶在了当年光棍节前回到了一条光棍的状态，有那么一两个幸存的情比金坚的，那也是极少数幸运的，都是后话了。\n于是我们都迷茫了。在刚进入大学还不知道该干什么刚打算心里装着远方的妹子天天上自习却忽然就被甩了的时候，我们都迷茫了。我看到说说和微博过几天就有一个失意的小伙伴更新一条“今晚又睡不着了，想你”“把你的照片装在钥匙扣上，自习的累了拿出来看一眼就很满足”“好累”云云，当然不嫌羞耻的说我也是其中一员；我还记得那时候失意的人经常相约去沙河对面的串串摊喝酒吃串串侃点别的诉点苦；也记得我们每天就做梦梦到某个人然后不愿意醒来，开始了我们翘课的生活。这些都没什么，走得远了回头一看，这些都不算什么，你会发现很多人和你一样迷茫着，这是正常的，也是圆满的。\n之后半期考过后，就开始了一系列的校园活动，那时候才算是大学生活真正开始的时候，从非诚勿扰，到女生节许愿墙，人缘好的性格外向的开始交友，性格内向的就开始找小伙伴，大家虽然还在迷茫，但也都努力在适应。那段时间的我，却在经历一段挣扎，这个挣扎来源于两件事，创新杯，还有大学计算机基础。\n也许是我习惯了高中进去就各种活动的节奏，到了大学虽然我不愿意再去涉及那么多的人事关系，但我却更愿意做点专业的事情也好让我明白咱们这个专业是做什么的。我还记得第一次听到创新杯可以报名的时候，我还赖在床上和舍友开黑打游戏，然后我忽然激发出一股斗志，那种想要学习报国的斗志，所以头脑一热就跟舍友说咱们也去参加吧。虽然后来就一审混过了连二审都不敢去，但我想，如果此刻正在读这些文字的你，也有着一腔斗志想要挑战一下这个创新杯的话，我还是想和你说加油，走到哪是哪，重要的是不要放弃，这一次失败了下一次还能继续。开始的时候就我一个人装模做样的学了点东西抄了点代码其实那时候自己什么也看不懂，舍友们那时候还小，更是什么也不知道，以至于到了二审的时候我们犹豫了半天还是觉得不要去丢这个脸好了，不如用这个时间开一把小黑快乐一下。这件事就在一局游戏里了结了，但我觉得这个失败的经历对于我日后坚持不懈的努力也是必不可少的。\n再有就是大学计算机基础了。我想应该有些经历过的的人会明白，这个是文科的课程。没错，因为帮一个妹子做计算机作业，我按很多人设想的模式认识了一个文科的妹子。并且成功的从辅导计算机，到食堂吃饭，到出去吃饭，逛街，到一起度过跨年夜，最后在寒假的时候，在接近成功的时候，她因为我高考结束那段时间的经历而打了退堂鼓。那段时间我也着实没那那些想法。但是回想起来我想也许很多人走出迷茫的方式就是遇见那么一个可以带你走出来的人，但是又愁于无法遇见，我幸运到可以遇见，虽然最后走散了，因为那么现实的原因，但我终究是清醒过来，此刻我正站在大学的校园里，脚下是真实的土地。\n后来我和大多数颓废的大学生一样堕落了，下学期的时候，我偶然接触了一个坑爹的网游，具体是什么我就不说了。那一个学期我花费了整个学期在这个游戏上，但最终想来，其实对于不同的人来说做相同的事收获也是不同的，就像这一个学期的经历，我虽然也是这么浪费了时间，但我却有机会认识了来自天南地北的各路网友。从初中生，高中生，到大学生，为人父，为人母，我和他们在现实中都建立了相当稳固和良好的联系，他们也在我接下来的历程中给了不少建议。如此想来，我想，此刻正在读这些文字的你，若有心想要趁着青春把过去未完成的疯狂补偿一遍，一定不要只是失去什么，至少努力去收获这么多你能够触手可得的为人处世的经验。\n那次期末考，我和所有大学的迷茫者一样，终于挂科了。我们总说，没有挂科，没有翘课，没有女朋友的大学是不圆满的，也许我们在这样一个地方相会，最后那个条件我们还是暂时束之高阁吧，这么想着自己就感到安慰了，大学三分之二圆满了嘛。我记得，那个暑假，在回家的飞机起飞的那一刻，我忽然觉得自己经历的这一年大学是如此的虚幻，毫无建树，没有自己期望中的精彩，虽然将自己的青春一股脑儿发泄完了，但此刻却觉得沉甸甸的疲惫。那一刻，我想，是该改变的时候了。\n青春就这么过去了。后来想起的时候，有遗憾，也有庆幸。遗憾的是自己最终还是把自己第一年的成绩搞得一团糟，庆幸的是自己疯过，累过，青春过，没有后悔过。\n回到家，我先是忍着心疼删了游戏里的角色，删了游戏，甚至把电脑和手机里所有能玩的游戏和娱乐的软件都一并删除了。从那时候开始也算是一个分水岭，在那次之后我就慢慢变得很少玩游戏了。我想每个还算靠谱的大学生，都会有这样一个分水岭。我们当中有些人在大一刚入学时就能下定决心，而有些人直到毕业还是一样像无头苍蝇一样不知道未来往哪走，前者很快就成了学霸学神，而后者到最后还是学渣。\n大一的暑假，也许我和很多人度过的都不一样。我回到了高三的状态，在图书馆朝至夕归的过了两个月，不仅仅是复习我阵亡的大学物理，还把大一学过的课程几乎全都自学了一遍。那时候我父母甚至是我的很多朋友都不理解为什么我放假还要这样读书，但我强忍内心无法多陪伴父母一点时间的痛苦，用一个夏天的时间学会了坚持。那个暑假据说是北航史上最长的暑假，一个夏天让我学会了坚持，虽然最后的结局并不好，但转机也很快来到了。\n\n分水岭之后\n故事仍然从上一部分继续，但我的生命却在悄悄进入下一个时代。那个暑假的结束十分的戏剧，我临时被通知开学前补考，于是匆忙的改签了机票，幸运的是在第二天早上八点的航班有最后几个位子。我甚至连行李都来不及整，家人们朋友们也没有告知就被迫狼狈的离开了家。一个夏天的终结。\n第二天早上赶到机场的时候，却在机场里遇见了一个很久很久都没有机会见到的外地朋友，顿时郁闷的心情一扫而光。后来和朋友说起的时候，都觉得那真的是个上帝的馈赠，也许很多时候在你看来特别不如意特别不顺心的时刻，其实都是上帝在为你准备着馈赠而让你经历的。从那开始，我经历了一段特别黑暗的日子，当然，我已经对黑暗的日子习惯了。记得那时候，我曾经把自己的签名改成“如果生命是个悲剧，就让观众哭个够，如果生命是个喜剧，就让世界开心个够”。\n物理补考之后，我和很多人一样，进入了痛苦的转型期。时间久远，有些细节我已记不起来了，但我知道，那段时间我是咬着牙度过下来的。以至于当我看到圣经里上帝的教诲时，我忽然发现一切都是馈赠，生活总是看起来很不如意，当你换了一种心态去面对，生活顿时就变得不一样了。\n我们总是抱怨着生活的不如意，生活的累，但再怎么样我们都不能放弃，因为我们会明白，表面上看起来的不如意，其实只是对我们的考验，和给予我们的提升的机会。如果不曾努力，不如意又怎么会变成机会，如果不曾勇敢，不如意又怎么会变成挑战。如果，身处大二这个时期的你也在这么痛苦的放弃了你曾经堕落的生活，准备从学渣晋升到一个充满了激情和热爱的IT男，我想，坚持和信念是你要学会的。基督山伯爵说，人生的意义就在于四个字，等待和希望，这是我一直以来的座右铭。即使有太多的倒霉的事或者不好的事发生，我也不会放弃希望，但这也恰恰就是我最傻的地方。总是抱着必定落空的希望而坚持，最后碰得一鼻子灰，不过我并不觉得这种傻有什么可羞耻的地方，相反我仍然在坚持，我也希望有着同样信念的人也一定要坚持。\n于是我没有在意第一年的失败，又参加了第二年的创新杯。也许只是时机不对，所以直到第二年我才慢慢明白第一年犯下的错误和幼稚。创新杯进行了很久，直到下学期冯如杯的闯入让我希望去接受更大的挑战。虽然最后的结果都是失败，但某种意义上来说也并不能算是失败，对我们这样的学渣来说，能接受挑战也是一种成功，重要的是接受失败给予我们的经验并继续去尝试。创新杯的失败是因为接受了错误的概念引导，也和那时候没有做好接受任何挑战的准备有关，直到最后失败了之后我才忽然发现其实自己一直没有去面对的很多挑战才正是自己最需要的。如果，在遇到了新的挑战的时候我们只是一味的逃避想要让事情简单，有些挑战我们永远也无法应付的了，有些道理和知识我们永远也学不会。就像我们学软件的，有些东西我们从未学到过，如果不勇敢的去挑战，我们到最后只能拿着书上教我们的那些空洞的知识蓦然发现自己离成功的实践越来越远。\n两次失败后，我已经积累了足够的经验，加上和团队的磨合的也越来越好，我们准备向更大的目标进发，做一个更庞大的系统开发。也许直到现在都还是有那么多的质疑，觉得我太过冒险，然而没有失败，没有想要做得更好，又何来的突破和成功。我想，如果你们愿意去寻找自己热爱的事物，就应该大胆的去尝试，去改变，去经历，才能不断地更新自己的认识。携两三靠谱好基友，凭一腔热血，青春年少，有什么做不到的。年轻就该气盛，才不负年华。\n也许每个人的大学生活从一开始就像我现在这样，也不会有那么多迷茫，那么多弯路了，然而人生就是这样，在你该走弯路的时候，一定不要因为太多的顾虑而错过了弯路上的风景。所有人的生命，在一开始都是以相同的一条直线从起点奔向终点，然而正是由于生命的多彩，不同的人走向了不同的方向，经历了不同的曲折，或是与其他人的生命相交，或是重合，或是平行着远远看着，到最后所有人再回到同一个终点。如果我们选择一路都是直线的人生，我们只是选择了最短，最简单的人生，在相同的时间里，我们所经历的距离却远比充满了曲折的人生来的短。那么，既然我们有着相同的起点和终点，上帝所给与我们的生命长度是如此的有限，我们又为什么不多经历一点曲折和弯路，多看点风景呢？\n老者和长辈总会淳淳教诲我们，少走弯路年轻人。然而那只是因为他们不知道别处的风景，不知道弯路上的风景，弯路上的经历，不知道我们所多走的距离和别人的生命相比起来是多么的宝贵。我想，此刻正在读这些文字的你们，应该有很多人也在这么迷茫着吧。我的经历也许并不是那么的石破天惊，我的价值观也许不是那么的正常，也许我在很多人眼里是没吃药才会写下这些文字，但我觉得，是不同的经历造就了不同的人格，可你若不去经历，你将永远不知道对岸的风景。我相信，不管是变成什么样的技术宅，只要学会了坚持，就可以拥有全世界。\n\n","source":"bio/index.md","raw":"title: 自传\ndate: 2015-10-22 17:04:18\ntype: \"bio\"\ncomments: true\n---\n\n\n\n大三上学期的我 2013-11-24\n我明白也许这个时候就对大学生活做个总结之类的有点不自量力，但鉴于我也是个心怀梦想希望走的更远的小屌丝，有时候坐在图书馆周日午后的阳光里看着满阅览室的汉子和零星的女汉子，也不免心生悲凉和感慨希望写下点什么。所以，我还是先从大学之前说起吧。如果，正在看的你是一个高富帅，也许我们的经历无法产生共鸣，若是觉得无聊，看官们随意。\n\n大学之前\n所有人在刚进入大学的时候，就知识来说，也许大多数人是站在同一起跑线上的，特别是来到我们软院的，我想也有那么一部分人都是一起苦逼的被调剂来的。但是，其实每个人在人生的道路上，不是说上了大学就重新开始人生了，而是继续前行，所以我们每个人又是在不同的位置和方向进入了大学。新认识的小伙伴们大部分时候侃的话题难免是自己的高中生活，有的心有余悸，有的心有不甘，有的好生怀念，这就是不同所在。我隔壁宿舍的小伙伴，来自一个黑暗不见五指的学习环境，高中不允许男女生同行，食堂男女生分区进食还有老师监视，每天六点开始早自习晚上十一点结束晚自习，没有娱乐活动，对于他来说离开那种环境我都能替他感到深深的解脱感；还有一个来自一所大名鼎鼎的某某监狱的小伙伴，高中三年被压抑和束缚，也许他们当中有些还会怀念，有些心生恐惧，但相比于周遭的所有同学，我想我算是比较幸运的，来自南方的一所比较开放的高中。\n可以某种程度上来说，除了高考前每周一次的练习和自己做的卷子，高一到高三我的老师没有强迫我们交任何作业，这就导致了我们集体涣散，一群曾经的名列前茅开始在各种活动中崭露头角，然后在各种考试中被虐的满地找牙。但好在那时候的老师是宽容的，总是给我们很多鼓励和支持，即使我挂科也会毅然决然的给我写上一个大大的90，我想，那段日子对我日后真的影响特别深远。后来，在各种早恋和课外活动中，我们混到了高二下学期，那时候我们班里发生了一件大事，以至于影响了我一生。某一天晚上晚自习的时候当我还和小伙伴们聊得正嗨的时候忽然有老师来教室里，告诉我们班主任出事了。我们根本没想到事情会那么难以接受和不可想象，给了我最多鼓励的班主任和她丈夫在散步的时候，一个据称是神经病的人本着情侣都去死的心态拿着水果刀就刺向了班主任的丈夫。他很优秀，她也很优秀，但就这么离谱的事情，我的班主任无法接受这一事实，最后悲痛的离开了我们去了外地慢慢调养。而我也忽然意识到，再不努力就没办法让她看到她所肯定的那个我了。那时候，是高二的寒假前。那时候我还是倒数。但我总是把相信自己放在第一位，于是就有了后来的高考，来到了北航。但这些都不是重点，这些都只是铺垫。\n\n大一入学\n我想很多软院的男生在刚入学的时候，心中总会牵挂着那样一个妹子，或许是女朋友，或许只是心上人，但我相信在高考结束之后那段迷茫、无聊、空虚的日子里，我们总会那样疯狂地失去理智过。\n高考结束后我谈了一次轰轰烈烈的恋爱，说是轰轰烈烈是因为在我父母都不知情的情况下我所有的好朋友都已经极力反对了，所以我冒着失去几乎所有朋友的风险失去理智了一回。过程相当庸俗，我想恋爱过的人大都明白这些过程，但我想说的是，当我们说着不分离的誓言各自去了不同的城市上了大学之后，我忽然发现周围有那么多相同处境的小伙伴。然后，当我开了个好头，在军训刚结束她就忽然人间蒸发了之后一个月的时间里，我看到大家接连赶在了当年光棍节前回到了一条光棍的状态，有那么一两个幸存的情比金坚的，那也是极少数幸运的，都是后话了。\n于是我们都迷茫了。在刚进入大学还不知道该干什么刚打算心里装着远方的妹子天天上自习却忽然就被甩了的时候，我们都迷茫了。我看到说说和微博过几天就有一个失意的小伙伴更新一条“今晚又睡不着了，想你”“把你的照片装在钥匙扣上，自习的累了拿出来看一眼就很满足”“好累”云云，当然不嫌羞耻的说我也是其中一员；我还记得那时候失意的人经常相约去沙河对面的串串摊喝酒吃串串侃点别的诉点苦；也记得我们每天就做梦梦到某个人然后不愿意醒来，开始了我们翘课的生活。这些都没什么，走得远了回头一看，这些都不算什么，你会发现很多人和你一样迷茫着，这是正常的，也是圆满的。\n之后半期考过后，就开始了一系列的校园活动，那时候才算是大学生活真正开始的时候，从非诚勿扰，到女生节许愿墙，人缘好的性格外向的开始交友，性格内向的就开始找小伙伴，大家虽然还在迷茫，但也都努力在适应。那段时间的我，却在经历一段挣扎，这个挣扎来源于两件事，创新杯，还有大学计算机基础。\n也许是我习惯了高中进去就各种活动的节奏，到了大学虽然我不愿意再去涉及那么多的人事关系，但我却更愿意做点专业的事情也好让我明白咱们这个专业是做什么的。我还记得第一次听到创新杯可以报名的时候，我还赖在床上和舍友开黑打游戏，然后我忽然激发出一股斗志，那种想要学习报国的斗志，所以头脑一热就跟舍友说咱们也去参加吧。虽然后来就一审混过了连二审都不敢去，但我想，如果此刻正在读这些文字的你，也有着一腔斗志想要挑战一下这个创新杯的话，我还是想和你说加油，走到哪是哪，重要的是不要放弃，这一次失败了下一次还能继续。开始的时候就我一个人装模做样的学了点东西抄了点代码其实那时候自己什么也看不懂，舍友们那时候还小，更是什么也不知道，以至于到了二审的时候我们犹豫了半天还是觉得不要去丢这个脸好了，不如用这个时间开一把小黑快乐一下。这件事就在一局游戏里了结了，但我觉得这个失败的经历对于我日后坚持不懈的努力也是必不可少的。\n再有就是大学计算机基础了。我想应该有些经历过的的人会明白，这个是文科的课程。没错，因为帮一个妹子做计算机作业，我按很多人设想的模式认识了一个文科的妹子。并且成功的从辅导计算机，到食堂吃饭，到出去吃饭，逛街，到一起度过跨年夜，最后在寒假的时候，在接近成功的时候，她因为我高考结束那段时间的经历而打了退堂鼓。那段时间我也着实没那那些想法。但是回想起来我想也许很多人走出迷茫的方式就是遇见那么一个可以带你走出来的人，但是又愁于无法遇见，我幸运到可以遇见，虽然最后走散了，因为那么现实的原因，但我终究是清醒过来，此刻我正站在大学的校园里，脚下是真实的土地。\n后来我和大多数颓废的大学生一样堕落了，下学期的时候，我偶然接触了一个坑爹的网游，具体是什么我就不说了。那一个学期我花费了整个学期在这个游戏上，但最终想来，其实对于不同的人来说做相同的事收获也是不同的，就像这一个学期的经历，我虽然也是这么浪费了时间，但我却有机会认识了来自天南地北的各路网友。从初中生，高中生，到大学生，为人父，为人母，我和他们在现实中都建立了相当稳固和良好的联系，他们也在我接下来的历程中给了不少建议。如此想来，我想，此刻正在读这些文字的你，若有心想要趁着青春把过去未完成的疯狂补偿一遍，一定不要只是失去什么，至少努力去收获这么多你能够触手可得的为人处世的经验。\n那次期末考，我和所有大学的迷茫者一样，终于挂科了。我们总说，没有挂科，没有翘课，没有女朋友的大学是不圆满的，也许我们在这样一个地方相会，最后那个条件我们还是暂时束之高阁吧，这么想着自己就感到安慰了，大学三分之二圆满了嘛。我记得，那个暑假，在回家的飞机起飞的那一刻，我忽然觉得自己经历的这一年大学是如此的虚幻，毫无建树，没有自己期望中的精彩，虽然将自己的青春一股脑儿发泄完了，但此刻却觉得沉甸甸的疲惫。那一刻，我想，是该改变的时候了。\n青春就这么过去了。后来想起的时候，有遗憾，也有庆幸。遗憾的是自己最终还是把自己第一年的成绩搞得一团糟，庆幸的是自己疯过，累过，青春过，没有后悔过。\n回到家，我先是忍着心疼删了游戏里的角色，删了游戏，甚至把电脑和手机里所有能玩的游戏和娱乐的软件都一并删除了。从那时候开始也算是一个分水岭，在那次之后我就慢慢变得很少玩游戏了。我想每个还算靠谱的大学生，都会有这样一个分水岭。我们当中有些人在大一刚入学时就能下定决心，而有些人直到毕业还是一样像无头苍蝇一样不知道未来往哪走，前者很快就成了学霸学神，而后者到最后还是学渣。\n大一的暑假，也许我和很多人度过的都不一样。我回到了高三的状态，在图书馆朝至夕归的过了两个月，不仅仅是复习我阵亡的大学物理，还把大一学过的课程几乎全都自学了一遍。那时候我父母甚至是我的很多朋友都不理解为什么我放假还要这样读书，但我强忍内心无法多陪伴父母一点时间的痛苦，用一个夏天的时间学会了坚持。那个暑假据说是北航史上最长的暑假，一个夏天让我学会了坚持，虽然最后的结局并不好，但转机也很快来到了。\n\n分水岭之后\n故事仍然从上一部分继续，但我的生命却在悄悄进入下一个时代。那个暑假的结束十分的戏剧，我临时被通知开学前补考，于是匆忙的改签了机票，幸运的是在第二天早上八点的航班有最后几个位子。我甚至连行李都来不及整，家人们朋友们也没有告知就被迫狼狈的离开了家。一个夏天的终结。\n第二天早上赶到机场的时候，却在机场里遇见了一个很久很久都没有机会见到的外地朋友，顿时郁闷的心情一扫而光。后来和朋友说起的时候，都觉得那真的是个上帝的馈赠，也许很多时候在你看来特别不如意特别不顺心的时刻，其实都是上帝在为你准备着馈赠而让你经历的。从那开始，我经历了一段特别黑暗的日子，当然，我已经对黑暗的日子习惯了。记得那时候，我曾经把自己的签名改成“如果生命是个悲剧，就让观众哭个够，如果生命是个喜剧，就让世界开心个够”。\n物理补考之后，我和很多人一样，进入了痛苦的转型期。时间久远，有些细节我已记不起来了，但我知道，那段时间我是咬着牙度过下来的。以至于当我看到圣经里上帝的教诲时，我忽然发现一切都是馈赠，生活总是看起来很不如意，当你换了一种心态去面对，生活顿时就变得不一样了。\n我们总是抱怨着生活的不如意，生活的累，但再怎么样我们都不能放弃，因为我们会明白，表面上看起来的不如意，其实只是对我们的考验，和给予我们的提升的机会。如果不曾努力，不如意又怎么会变成机会，如果不曾勇敢，不如意又怎么会变成挑战。如果，身处大二这个时期的你也在这么痛苦的放弃了你曾经堕落的生活，准备从学渣晋升到一个充满了激情和热爱的IT男，我想，坚持和信念是你要学会的。基督山伯爵说，人生的意义就在于四个字，等待和希望，这是我一直以来的座右铭。即使有太多的倒霉的事或者不好的事发生，我也不会放弃希望，但这也恰恰就是我最傻的地方。总是抱着必定落空的希望而坚持，最后碰得一鼻子灰，不过我并不觉得这种傻有什么可羞耻的地方，相反我仍然在坚持，我也希望有着同样信念的人也一定要坚持。\n于是我没有在意第一年的失败，又参加了第二年的创新杯。也许只是时机不对，所以直到第二年我才慢慢明白第一年犯下的错误和幼稚。创新杯进行了很久，直到下学期冯如杯的闯入让我希望去接受更大的挑战。虽然最后的结果都是失败，但某种意义上来说也并不能算是失败，对我们这样的学渣来说，能接受挑战也是一种成功，重要的是接受失败给予我们的经验并继续去尝试。创新杯的失败是因为接受了错误的概念引导，也和那时候没有做好接受任何挑战的准备有关，直到最后失败了之后我才忽然发现其实自己一直没有去面对的很多挑战才正是自己最需要的。如果，在遇到了新的挑战的时候我们只是一味的逃避想要让事情简单，有些挑战我们永远也无法应付的了，有些道理和知识我们永远也学不会。就像我们学软件的，有些东西我们从未学到过，如果不勇敢的去挑战，我们到最后只能拿着书上教我们的那些空洞的知识蓦然发现自己离成功的实践越来越远。\n两次失败后，我已经积累了足够的经验，加上和团队的磨合的也越来越好，我们准备向更大的目标进发，做一个更庞大的系统开发。也许直到现在都还是有那么多的质疑，觉得我太过冒险，然而没有失败，没有想要做得更好，又何来的突破和成功。我想，如果你们愿意去寻找自己热爱的事物，就应该大胆的去尝试，去改变，去经历，才能不断地更新自己的认识。携两三靠谱好基友，凭一腔热血，青春年少，有什么做不到的。年轻就该气盛，才不负年华。\n也许每个人的大学生活从一开始就像我现在这样，也不会有那么多迷茫，那么多弯路了，然而人生就是这样，在你该走弯路的时候，一定不要因为太多的顾虑而错过了弯路上的风景。所有人的生命，在一开始都是以相同的一条直线从起点奔向终点，然而正是由于生命的多彩，不同的人走向了不同的方向，经历了不同的曲折，或是与其他人的生命相交，或是重合，或是平行着远远看着，到最后所有人再回到同一个终点。如果我们选择一路都是直线的人生，我们只是选择了最短，最简单的人生，在相同的时间里，我们所经历的距离却远比充满了曲折的人生来的短。那么，既然我们有着相同的起点和终点，上帝所给与我们的生命长度是如此的有限，我们又为什么不多经历一点曲折和弯路，多看点风景呢？\n老者和长辈总会淳淳教诲我们，少走弯路年轻人。然而那只是因为他们不知道别处的风景，不知道弯路上的风景，弯路上的经历，不知道我们所多走的距离和别人的生命相比起来是多么的宝贵。我想，此刻正在读这些文字的你们，应该有很多人也在这么迷茫着吧。我的经历也许并不是那么的石破天惊，我的价值观也许不是那么的正常，也许我在很多人眼里是没吃药才会写下这些文字，但我觉得，是不同的经历造就了不同的人格，可你若不去经历，你将永远不知道对岸的风景。我相信，不管是变成什么样的技术宅，只要学会了坚持，就可以拥有全世界。\n\n","updated":"2015-12-18T13:13:14.000Z","path":"bio/index.html","layout":"page","_id":"civaqnytj0003j4rb3my8n9kl"},{"title":"关于","date":"2015-10-22T09:04:18.000Z","type":"about","comments":0,"_content":"\nYuheng Chen, Bachelor degree of *Software Engineering* Of *Beihang University* (2011~2015), born hacker. **Full-stack Developer**, crazy fan of Hackathons all around the world, founder of Hackathon team *[hACKbUSTER](https://github.com/hackbuster)* and open-source animation organization *[Animatious](https://github.com/animatious)*.\n\n [Linkedin](https://cn.linkedin.com/pub/sergio-chan/42/14b/a6) | [Weibo](http://weibo.com/3089081773/profile?topnav=1&wvr=6) | [Github](https://github.com/SergioChan) \n\n## Skill Tree\n\n- Master Objective-C, professionally at Python, C#, PHP and Java, familiar with JavaScript, C++\n- Master MySQL, Redis, professionally at MongoDB\n- Good at System analysis and design, team leadership and team motivation\n- Master Scrum","source":"about/index.md","raw":"title: 关于\ndate: 2015-10-22 17:04:18\ntype: \"about\"\n\n\ncomments: false\n---\n\nYuheng Chen, Bachelor degree of *Software Engineering* Of *Beihang University* (2011~2015), born hacker. **Full-stack Developer**, crazy fan of Hackathons all around the world, founder of Hackathon team *[hACKbUSTER](https://github.com/hackbuster)* and open-source animation organization *[Animatious](https://github.com/animatious)*.\n\n [Linkedin](https://cn.linkedin.com/pub/sergio-chan/42/14b/a6) | [Weibo](http://weibo.com/3089081773/profile?topnav=1&wvr=6) | [Github](https://github.com/SergioChan) \n\n## Skill Tree\n\n- Master Objective-C, professionally at Python, C#, PHP and Java, familiar with JavaScript, C++\n- Master MySQL, Redis, professionally at MongoDB\n- Good at System analysis and design, team leadership and team motivation\n- Master Scrum","updated":"2016-08-30T08:32:44.000Z","path":"about/index.html","layout":"page","_id":"civaqnytl0004j4rbaf4uuoy0"}],"Post":[{"title":"我们只要把事实讲清楚就好了，至于下结论是他们的事。","date":"2016-02-06T12:53:46.000Z","_content":"\n\n\n过年回家果然是毫无效率可言。到处拜年，和各种长辈嘘寒问暖，见朋友，陪长辈。  \n\n觉得自己现在的生活还是好脆弱，自己肩上的担子远比自己想象的更重。所错过和遗憾的大学头两年，也许并不是这么容易就能补回来的吧，那将成为我永远鞭策自己前进的一股伤痛。学是学了很多东西，但是确实转念一想，到现在也没有什么特别拿得出手的东西，现在静下心来把自己沉淀的东西开始整合成一个完整的项目了，然而又碰上过年，效率直线下跌，所以更加的烦闷。\n\n年后的新一年的生活，我忽然感觉到很迷茫。显昆去真格实习来北京，Kevin公司搬到北京，我在北京到底何去何从，能够让我想要的家稳定和安宁一些，少一些风浪。2016年必定还会有更多的Hackathon等着我去挑战，我相信创意是源源不断的，能力也是一步步提升的，只要我坚持每一次都学习新技术，不论获奖与否都会是巨大的进步。所以我就更需要一个稳定的生活，来为我在各种时候的冲刺积蓄力量储备体力。\n\n过年回来和父母坦白完，也狠下心来从今以后就连出国读书也要靠自己。我觉得我会为我没有在自己的人生中把自己砍得鲜血淋漓而在将来感到遗憾。我希望活的波澜壮阔，我希望哪怕是最后战死也要留下一段荡气回肠的故事，我希望我能和别人不一样，所以我继续往自己身上割出一道道伤口。从大四开始就已经完全经济独立，说实话那时候还比现在工作的我更有积蓄，毕竟在学校里，钱也没什么地方花，然而那时候也许是逆反，也许是不甘，我所努力完成的经济独立让我都为那时候的我感动了。然而现在，我有更严酷的未来要面对，真实的生活，社会，未来，这一切不再是学校那时候的水平了。我想过退缩，但是我还是不想让自己泯然众人，我还是想证明自己，证明自己能够将自己热爱的事情做到让世人都惊叹的时候。\n\n所以我还是选择了，对自己更狠一点。希望一年后的自己不会辜负现在的我。就如我没有辜负一年前的我对我的期望一样。\n\n听闻父母的一些朋友的孩子都准备结婚，家里买好房子办好喜酒什么的，又或者在父母身边留着，等着父母中年努力工作给他们置办未来的婚房，我忽然觉得这种人生不仅现实，而且渺小。也许和我相比，他们还是不知道高到哪里去了，毕竟人家在哪哪也有了房子，哪哪准备办喜酒，然而我还是觉得，论人生的渺小与否，在于最后留下的内容多少和精彩程度。\n\n做自己最热爱的事情，并且尽全力做到最好，我觉得才是最精彩和最充实的人生，才是老年的时候，可以自豪的，欣慰的讲述给晚辈们听，告诉他们我的人生不曾遗憾过，也不曾空虚过。\n\n为自己新的一年加个油吧。  \n希望自己做到最好，不去在乎别人对自己的眼光和评价。  \n很多事情，证明都摆在那里，无需我多说了。\n别人相不相信，是他们的事情。\n\n高中的时候，有一句话，从低谷的时候伴随着我走过来。  \n`我们只要把事实讲清楚就好了，至于下结论是他们的事。`","source":"_posts/过年.md","raw":"title: 我们只要把事实讲清楚就好了，至于下结论是他们的事。\ndate: 2016-02-06 20:53:46\ncategories: 闲言碎语\ntags:\n---\n\n\n\n过年回家果然是毫无效率可言。到处拜年，和各种长辈嘘寒问暖，见朋友，陪长辈。  \n\n觉得自己现在的生活还是好脆弱，自己肩上的担子远比自己想象的更重。所错过和遗憾的大学头两年，也许并不是这么容易就能补回来的吧，那将成为我永远鞭策自己前进的一股伤痛。学是学了很多东西，但是确实转念一想，到现在也没有什么特别拿得出手的东西，现在静下心来把自己沉淀的东西开始整合成一个完整的项目了，然而又碰上过年，效率直线下跌，所以更加的烦闷。\n\n年后的新一年的生活，我忽然感觉到很迷茫。显昆去真格实习来北京，Kevin公司搬到北京，我在北京到底何去何从，能够让我想要的家稳定和安宁一些，少一些风浪。2016年必定还会有更多的Hackathon等着我去挑战，我相信创意是源源不断的，能力也是一步步提升的，只要我坚持每一次都学习新技术，不论获奖与否都会是巨大的进步。所以我就更需要一个稳定的生活，来为我在各种时候的冲刺积蓄力量储备体力。\n\n过年回来和父母坦白完，也狠下心来从今以后就连出国读书也要靠自己。我觉得我会为我没有在自己的人生中把自己砍得鲜血淋漓而在将来感到遗憾。我希望活的波澜壮阔，我希望哪怕是最后战死也要留下一段荡气回肠的故事，我希望我能和别人不一样，所以我继续往自己身上割出一道道伤口。从大四开始就已经完全经济独立，说实话那时候还比现在工作的我更有积蓄，毕竟在学校里，钱也没什么地方花，然而那时候也许是逆反，也许是不甘，我所努力完成的经济独立让我都为那时候的我感动了。然而现在，我有更严酷的未来要面对，真实的生活，社会，未来，这一切不再是学校那时候的水平了。我想过退缩，但是我还是不想让自己泯然众人，我还是想证明自己，证明自己能够将自己热爱的事情做到让世人都惊叹的时候。\n\n所以我还是选择了，对自己更狠一点。希望一年后的自己不会辜负现在的我。就如我没有辜负一年前的我对我的期望一样。\n\n听闻父母的一些朋友的孩子都准备结婚，家里买好房子办好喜酒什么的，又或者在父母身边留着，等着父母中年努力工作给他们置办未来的婚房，我忽然觉得这种人生不仅现实，而且渺小。也许和我相比，他们还是不知道高到哪里去了，毕竟人家在哪哪也有了房子，哪哪准备办喜酒，然而我还是觉得，论人生的渺小与否，在于最后留下的内容多少和精彩程度。\n\n做自己最热爱的事情，并且尽全力做到最好，我觉得才是最精彩和最充实的人生，才是老年的时候，可以自豪的，欣慰的讲述给晚辈们听，告诉他们我的人生不曾遗憾过，也不曾空虚过。\n\n为自己新的一年加个油吧。  \n希望自己做到最好，不去在乎别人对自己的眼光和评价。  \n很多事情，证明都摆在那里，无需我多说了。\n别人相不相信，是他们的事情。\n\n高中的时候，有一句话，从低谷的时候伴随着我走过来。  \n`我们只要把事实讲清楚就好了，至于下结论是他们的事。`","slug":"过年","published":1,"updated":"2016-08-25T03:13:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnytq0005j4rbwq9c6zja"},{"title":"谈谈我对Hackathon的理解","date":"2015-12-19T01:06:02.000Z","_content":"\n\n# Hackathon 是什么\n我们先要理解Hackathon这个词的起源。它起源于1999年，词语本身来自于Hack和Marathon的组合，意思就是一群程序员或者软件工程师相聚在一起，像马拉松一样不停的从起点跑到终点进行比赛。由于大部分Hackathon都是现场命题制，这就意味着所有程序员在一开始都是站在同一起跑线上的，所以Hackathon成为了每一个热爱挑战的程序员能够挑战自身各方面能力的机会。\n\n没错。我说的是，挑战。就如覃超大哥在SegmentFault的Hackathon开始的时候说的那样，hack精神就是Facebook最为推崇的理念，它的很多产品创新和突破都是来自于内部的Hackathon上迸发的灵感。所以应该不难理解，Hackathon的精神在于挑战自我和固有的事物、想法，从而去创造新的事物和新的想法。\n\n# 我的Hackathon经历\n先说说我的Hackathon经历吧。在接触Hackathon之前，我接触过很多创业团队，见过很多新的想法，但大部分都因为时间问题或者进度问题一拖再拖，亦或是这些想法并没有特别的打破人们固有的一些想法和思维模式。而我就已经乐衷于开拓自己的思维模式和范围，去接触更大的互联网世界。\n\n从创业和各种项目一路走来，我对软件工程的热爱逐渐在团队合作中被我自己培养了起来。对我来说，做一件事情，最重要的当然是这件事情是否有趣，是否值得我去热爱，其次就是能够和小伙伴一起去做这件事情，还记得两年前我刚开始走上这条道路的时候，我写到，“携两三靠谱好基友，凭一腔热血，青春年少，有什么做不到的。年轻就该气盛，才不负年华”。\n\n于是，当我第一次和小伙伴一起接触到Hackathon的时候，我就陷入了无比的狂热中。那是Dorahacks在北航举办的一次Hackathon，由于没有经验，我们也没有熬夜，只是晚上在QQ上相约一起写了一部分，第二天早上早早到地方开始调bug。一开始我们也通过头脑风暴想出了很多奇怪的创意，但是都被否定了，最后思宇在散步的时候想出了网页弹幕这个鬼点子。于是那也开启了我们每次Hackathon都一定会有的弹幕模式……其实写一个网页弹幕的Chrome插件花不了多少时间，加上leancloud即时通信和存储的集成，我们总共也没花几个小时，就将一个差不多通过了测试的版本放上台展示了。\n\n展示的时候，我扯了一大堆弹幕的起源和95后新兴人类的社交模式，扯了我从创业以来了解的各种互联网现状，然后啪的一展示，小伙伴们啪啪啪打了一堆弹幕上去，正好浏览的网页又特别想让人吐槽，所以大家都笑了，我们顺理成章拿了第一。\n\n后来我就总结出这么个道理，Hackathon，展示也是相当关键的一环，你要么让观众大笑，要么让观众大惊，如果观众一点反应都没有，那你就基本没有希望了。所以Hackathon，一定意义上并不是完全的在挑战一个人的思维能力，代码能力，团队合作能力之类的东西，更是在挑战和检验一个人的表达能力，简单地说，一个人的气场。对于一般的程序员来说，可能根本没有意识到在平时所谓气场和表达能力有什么重要性，但是，这也就意味着一个程序员将会永远在这种局限性之下成长。\n\n以上总结同样适用于我们接下来参加的一次大众中国的Hackathon。虽然这就是我将要说的商业大赛，但是最后拿了第一的团队，对于展示的把握相当的成熟，让我也学到了很多。我们什么奖也没有获得，但是我们脑洞大开的想让车与车之间通过弹幕的方式在公路上连接在一起。不知道为什么，也许我们和其他MBA或者博士们参加Hackathon的动机不一样吧，所以我们受到了相当的关注，这也让我感觉特别不自在和恼火。这本来就是大人们的一个游戏，他们只是对我们感到好奇罢了。\n\n挂羊头卖狗肉，是我对于很多这样的所谓Hackathon的商业创新大赛和外包大赛的总结。也许是各种企业主和策划方都觉得通过传统的比赛模式没有办法吸引到新时代的人才了，所以总是各种效仿，挂上Hackathon的名号。有一些比赛评委根本不看技术而看商业模式和商业分析，来自企业的一些Marketing的评委关注点是在如何让他们的企业赚更多的钱上，对于技术的创新性和效果并没有那么接受；而有一些比赛的评委对于自己出的题目已经有了相当明确的答案，却只是希望参加比赛的hacker能够按照他的期望把一个东西的原型做出来。\n\n是的，如果你想用广义的Hackathon定义来理解，你也许可以将他们也包含到Hackathon中，但是不可否认的是，这些比赛形式的本质是传统的，是抑制技术创新的。真正的Hackathon，应该是基于技术的创新和理念的创新，去解决一个实际的问题，从而让世界变得更美好。\n\n上周末的TC Hackathon，我想说我们最后退出了。在讨论了很久之后，对于某个企业提出的冰柜的题目，我们虽然觉得有很多能创新的点，但是当评委介绍完整个任务之后，我其实已经觉得没有多大希望了——评委对于项目有着明确的要求，甚至可以说他们应该已经花费了一些人力在这个项目上。整个题目是这个企业之前就已经提出的一个创业点，他们不希望自己投入研发成本去做这件事，而希望创业团队来帮他们实现。当没有什么好的创业团队来做这件事的时候，他们就把这件事情扔到一个Hackathon上，可以说，那些可怜的奖金如果换做外包的形式的话，数额只够一个人的所得。用廉价的奖金换来一个优质的外包方案，我相信对于每个企业都是一种好的选择。我也认识一些传统行业的人，他们告诉我，通过将项目外包给学校或者在学校内组织比赛的形式帮助他们完成一个项目的开发是他们很经常采用的手段。这个道理我想很多人都明白，但是我不希望外包比赛非得套上Hackathon的头套，玷污我心里对于技术创新的向往和渴望。\n\n最好的一次Hackathon是两周前的SegmentFault Hackathon。由于它本身是个开发者社区，而且这个Hackathon已经相当成熟，由他们自己举办，因此来自外界的干扰和污染特别小，评委也是来自于一线的新兴创业团队，并且都是一些注重技术和技术分享的公司。在这个比赛中，除了少量出现的偷偷用成品参加比赛的行为，包括零食，饮料的供应，都比TC的那次丰富和完善许多。而且采用的是现场公布题目的形式，题目的点也相当容易发散，不会提各种需求，这才让我感觉真真正正能出一些好东西。说实话，如果在Hackathon上还提一点两点三点好几点需求，那我就真的觉得和我平时做咨询，帮团队分析产品，做基础技术架构设计没有区别了。\n\n也许只有SegmentFault的Hackathon才配得上年轻开发者的节日1024吧。\n\n# Hackathon需要的技能\n对于我来说，我最害怕的就是止步不前，更害怕的是自己甘愿和其他90%的人一样陷于固有的事物和思维模式。我相信每一个接受过良好本科教育的大学毕业生在许多所谓的基础方式上都有着良好的基础，我们在校园里已经接受了足够的通识教育和专业基础教育，真正让每个人能够变得不同或者更好的，是在这个基础之上的思维模式。而Hackathon，既是对你的思维模式的磨炼，也是一种考验。\n\n参加Hackathon，你需要首先对这个比赛有足够的判断能力，他到底是个商业大赛，还是外包大赛，还是真的Hackathon？对于不同类型的“Hackathon”，你需要做不同的准备，虽然当你发现是前两者之后你可能已经对它失去兴趣了。下面是你需要的一些技能。\n\n## 你需要凝聚一个团队。\n\n对于团队的凝聚力更大程度应该是通过事情，而不仅仅是所谓的个人魅力。事情有趣，事情酷炫，事情实实在在的解决问题，我想每一个有激情的人都会很主动的投入进来。所以你需要想清楚要做的事情应该是什么样的，是实际的，还是超出自己想象的，对做的事情需要有一个方向的把控，这才能够凝聚起一个团队。我始终坚信，共同的热爱才是团队一致向前的最好动力。\n\n## 你需要挑选你的团队。\n\nHackathon不是刷上机题，你不是一个人在战斗。所以团队是最重要的部分。首先你需要保证你自己的技术栈足够宽，这里我说的不是什么web全栈框架，我说的技术栈是从前端，客户端，后端，数据库，服务器到建模，动画，设计，客户端的游戏开发，甚至还有视频制作这种技术如果最好都需要覆盖到。当然，对于一个人来说做到这些太困难了，所以这也就是你需要团队的原因。如果是偏商业大赛，即有比较明确的商业赞助和商业评委的参与，那么你还需要一到两个Marketing的小伙伴加入；如果是偏外包大赛，甚至纯技术的团队都可以胜任，但是有一个产品/交互会好很多；如果是纯Hackathon，组一个纯产品的小伙伴就没有特别大的意义了，那个时候，人人都可以是产品经理！\n\n团队人数方面，大部分Hackathon都限制在3~5人得范围内，最佳组合应该是能满足上述要求的4人组合。竞争力足够和5人团队匹敌，而5人团队也容易出现分歧，从而拖延本来就赶的进度。每一个决策都要尽量让每个队员都特别接受，并且有激情去做，因为Hackathon是在短时间内对每个人的精力和毅力的极大挑战，如果没有激情，那么你就会因为队员的疲惫而失去原本属于他的那份时间。\n\n## 你需要学会不一样的头脑风暴。\n\n这里的意思是如果你用正常的头脑风暴方式去思考，那么别人会和你做着同样的事情，到达同一个点，并且开始做同一个想法。这直接就宣告你的努力白费了。所以，你需要学会不一样的头脑风暴方式，不是从题目里的字眼发散，而是尝试着跳出来，从各处散乱的灵感里找到几个和题目接近的主题，再从那些主题中发散。记住，你能想到的东西，90%以上别人都会想到，所以我们要做的是去想别人想不到的那些想法。\n\n## 热爱。\n\n没有什么好说坚持和毅力什么的。那些都没有办法让你做到最好。只有热爱，像乔布斯说的那样，只有热爱能够让你真正把一件事情做好。所以在Hackathon的时候也一样，记住，一定要找到你热爱的东西，然后去完成它。如果找不到，就继续找，当然如果实在找不到，你可以选择随便找一个刚刚想出来的点子去实现。我相信4个人的思维火花碰撞，如果Hackathon足够纯净，你不可能找不到热爱的东西的。在Hackathon中，最切忌切忌的，就是凑合，为了做项目而去做项目。\n\n## 展示的时候，谦虚，但是让别人感受。\n\n展示也是相当重要的一部分，如我上文所提。当你在最后的展示的时候，你需要让所有人都能感受到你的热爱，感受到你们的想法和你们所实现的东西的激情，这时候就需要你的表达能力和感染力了。在台上不要害怕，保持谦虚是一种很好的驱赶恐慌感的方式。简单明了的让大家了解你的想法，并且通过demo的演示让大家感受到你的热爱。好的东西，才更需要一种好的途径进入每一个观众的内心。","source":"_posts/谈谈我对Hackathon的理解.md","raw":"title: 谈谈我对Hackathon的理解\ndate: 2015-12-19 09:06:02\ncategories: Hacker\ntags: [Hackathon]\n---\n\n\n# Hackathon 是什么\n我们先要理解Hackathon这个词的起源。它起源于1999年，词语本身来自于Hack和Marathon的组合，意思就是一群程序员或者软件工程师相聚在一起，像马拉松一样不停的从起点跑到终点进行比赛。由于大部分Hackathon都是现场命题制，这就意味着所有程序员在一开始都是站在同一起跑线上的，所以Hackathon成为了每一个热爱挑战的程序员能够挑战自身各方面能力的机会。\n\n没错。我说的是，挑战。就如覃超大哥在SegmentFault的Hackathon开始的时候说的那样，hack精神就是Facebook最为推崇的理念，它的很多产品创新和突破都是来自于内部的Hackathon上迸发的灵感。所以应该不难理解，Hackathon的精神在于挑战自我和固有的事物、想法，从而去创造新的事物和新的想法。\n\n# 我的Hackathon经历\n先说说我的Hackathon经历吧。在接触Hackathon之前，我接触过很多创业团队，见过很多新的想法，但大部分都因为时间问题或者进度问题一拖再拖，亦或是这些想法并没有特别的打破人们固有的一些想法和思维模式。而我就已经乐衷于开拓自己的思维模式和范围，去接触更大的互联网世界。\n\n从创业和各种项目一路走来，我对软件工程的热爱逐渐在团队合作中被我自己培养了起来。对我来说，做一件事情，最重要的当然是这件事情是否有趣，是否值得我去热爱，其次就是能够和小伙伴一起去做这件事情，还记得两年前我刚开始走上这条道路的时候，我写到，“携两三靠谱好基友，凭一腔热血，青春年少，有什么做不到的。年轻就该气盛，才不负年华”。\n\n于是，当我第一次和小伙伴一起接触到Hackathon的时候，我就陷入了无比的狂热中。那是Dorahacks在北航举办的一次Hackathon，由于没有经验，我们也没有熬夜，只是晚上在QQ上相约一起写了一部分，第二天早上早早到地方开始调bug。一开始我们也通过头脑风暴想出了很多奇怪的创意，但是都被否定了，最后思宇在散步的时候想出了网页弹幕这个鬼点子。于是那也开启了我们每次Hackathon都一定会有的弹幕模式……其实写一个网页弹幕的Chrome插件花不了多少时间，加上leancloud即时通信和存储的集成，我们总共也没花几个小时，就将一个差不多通过了测试的版本放上台展示了。\n\n展示的时候，我扯了一大堆弹幕的起源和95后新兴人类的社交模式，扯了我从创业以来了解的各种互联网现状，然后啪的一展示，小伙伴们啪啪啪打了一堆弹幕上去，正好浏览的网页又特别想让人吐槽，所以大家都笑了，我们顺理成章拿了第一。\n\n后来我就总结出这么个道理，Hackathon，展示也是相当关键的一环，你要么让观众大笑，要么让观众大惊，如果观众一点反应都没有，那你就基本没有希望了。所以Hackathon，一定意义上并不是完全的在挑战一个人的思维能力，代码能力，团队合作能力之类的东西，更是在挑战和检验一个人的表达能力，简单地说，一个人的气场。对于一般的程序员来说，可能根本没有意识到在平时所谓气场和表达能力有什么重要性，但是，这也就意味着一个程序员将会永远在这种局限性之下成长。\n\n以上总结同样适用于我们接下来参加的一次大众中国的Hackathon。虽然这就是我将要说的商业大赛，但是最后拿了第一的团队，对于展示的把握相当的成熟，让我也学到了很多。我们什么奖也没有获得，但是我们脑洞大开的想让车与车之间通过弹幕的方式在公路上连接在一起。不知道为什么，也许我们和其他MBA或者博士们参加Hackathon的动机不一样吧，所以我们受到了相当的关注，这也让我感觉特别不自在和恼火。这本来就是大人们的一个游戏，他们只是对我们感到好奇罢了。\n\n挂羊头卖狗肉，是我对于很多这样的所谓Hackathon的商业创新大赛和外包大赛的总结。也许是各种企业主和策划方都觉得通过传统的比赛模式没有办法吸引到新时代的人才了，所以总是各种效仿，挂上Hackathon的名号。有一些比赛评委根本不看技术而看商业模式和商业分析，来自企业的一些Marketing的评委关注点是在如何让他们的企业赚更多的钱上，对于技术的创新性和效果并没有那么接受；而有一些比赛的评委对于自己出的题目已经有了相当明确的答案，却只是希望参加比赛的hacker能够按照他的期望把一个东西的原型做出来。\n\n是的，如果你想用广义的Hackathon定义来理解，你也许可以将他们也包含到Hackathon中，但是不可否认的是，这些比赛形式的本质是传统的，是抑制技术创新的。真正的Hackathon，应该是基于技术的创新和理念的创新，去解决一个实际的问题，从而让世界变得更美好。\n\n上周末的TC Hackathon，我想说我们最后退出了。在讨论了很久之后，对于某个企业提出的冰柜的题目，我们虽然觉得有很多能创新的点，但是当评委介绍完整个任务之后，我其实已经觉得没有多大希望了——评委对于项目有着明确的要求，甚至可以说他们应该已经花费了一些人力在这个项目上。整个题目是这个企业之前就已经提出的一个创业点，他们不希望自己投入研发成本去做这件事，而希望创业团队来帮他们实现。当没有什么好的创业团队来做这件事的时候，他们就把这件事情扔到一个Hackathon上，可以说，那些可怜的奖金如果换做外包的形式的话，数额只够一个人的所得。用廉价的奖金换来一个优质的外包方案，我相信对于每个企业都是一种好的选择。我也认识一些传统行业的人，他们告诉我，通过将项目外包给学校或者在学校内组织比赛的形式帮助他们完成一个项目的开发是他们很经常采用的手段。这个道理我想很多人都明白，但是我不希望外包比赛非得套上Hackathon的头套，玷污我心里对于技术创新的向往和渴望。\n\n最好的一次Hackathon是两周前的SegmentFault Hackathon。由于它本身是个开发者社区，而且这个Hackathon已经相当成熟，由他们自己举办，因此来自外界的干扰和污染特别小，评委也是来自于一线的新兴创业团队，并且都是一些注重技术和技术分享的公司。在这个比赛中，除了少量出现的偷偷用成品参加比赛的行为，包括零食，饮料的供应，都比TC的那次丰富和完善许多。而且采用的是现场公布题目的形式，题目的点也相当容易发散，不会提各种需求，这才让我感觉真真正正能出一些好东西。说实话，如果在Hackathon上还提一点两点三点好几点需求，那我就真的觉得和我平时做咨询，帮团队分析产品，做基础技术架构设计没有区别了。\n\n也许只有SegmentFault的Hackathon才配得上年轻开发者的节日1024吧。\n\n# Hackathon需要的技能\n对于我来说，我最害怕的就是止步不前，更害怕的是自己甘愿和其他90%的人一样陷于固有的事物和思维模式。我相信每一个接受过良好本科教育的大学毕业生在许多所谓的基础方式上都有着良好的基础，我们在校园里已经接受了足够的通识教育和专业基础教育，真正让每个人能够变得不同或者更好的，是在这个基础之上的思维模式。而Hackathon，既是对你的思维模式的磨炼，也是一种考验。\n\n参加Hackathon，你需要首先对这个比赛有足够的判断能力，他到底是个商业大赛，还是外包大赛，还是真的Hackathon？对于不同类型的“Hackathon”，你需要做不同的准备，虽然当你发现是前两者之后你可能已经对它失去兴趣了。下面是你需要的一些技能。\n\n## 你需要凝聚一个团队。\n\n对于团队的凝聚力更大程度应该是通过事情，而不仅仅是所谓的个人魅力。事情有趣，事情酷炫，事情实实在在的解决问题，我想每一个有激情的人都会很主动的投入进来。所以你需要想清楚要做的事情应该是什么样的，是实际的，还是超出自己想象的，对做的事情需要有一个方向的把控，这才能够凝聚起一个团队。我始终坚信，共同的热爱才是团队一致向前的最好动力。\n\n## 你需要挑选你的团队。\n\nHackathon不是刷上机题，你不是一个人在战斗。所以团队是最重要的部分。首先你需要保证你自己的技术栈足够宽，这里我说的不是什么web全栈框架，我说的技术栈是从前端，客户端，后端，数据库，服务器到建模，动画，设计，客户端的游戏开发，甚至还有视频制作这种技术如果最好都需要覆盖到。当然，对于一个人来说做到这些太困难了，所以这也就是你需要团队的原因。如果是偏商业大赛，即有比较明确的商业赞助和商业评委的参与，那么你还需要一到两个Marketing的小伙伴加入；如果是偏外包大赛，甚至纯技术的团队都可以胜任，但是有一个产品/交互会好很多；如果是纯Hackathon，组一个纯产品的小伙伴就没有特别大的意义了，那个时候，人人都可以是产品经理！\n\n团队人数方面，大部分Hackathon都限制在3~5人得范围内，最佳组合应该是能满足上述要求的4人组合。竞争力足够和5人团队匹敌，而5人团队也容易出现分歧，从而拖延本来就赶的进度。每一个决策都要尽量让每个队员都特别接受，并且有激情去做，因为Hackathon是在短时间内对每个人的精力和毅力的极大挑战，如果没有激情，那么你就会因为队员的疲惫而失去原本属于他的那份时间。\n\n## 你需要学会不一样的头脑风暴。\n\n这里的意思是如果你用正常的头脑风暴方式去思考，那么别人会和你做着同样的事情，到达同一个点，并且开始做同一个想法。这直接就宣告你的努力白费了。所以，你需要学会不一样的头脑风暴方式，不是从题目里的字眼发散，而是尝试着跳出来，从各处散乱的灵感里找到几个和题目接近的主题，再从那些主题中发散。记住，你能想到的东西，90%以上别人都会想到，所以我们要做的是去想别人想不到的那些想法。\n\n## 热爱。\n\n没有什么好说坚持和毅力什么的。那些都没有办法让你做到最好。只有热爱，像乔布斯说的那样，只有热爱能够让你真正把一件事情做好。所以在Hackathon的时候也一样，记住，一定要找到你热爱的东西，然后去完成它。如果找不到，就继续找，当然如果实在找不到，你可以选择随便找一个刚刚想出来的点子去实现。我相信4个人的思维火花碰撞，如果Hackathon足够纯净，你不可能找不到热爱的东西的。在Hackathon中，最切忌切忌的，就是凑合，为了做项目而去做项目。\n\n## 展示的时候，谦虚，但是让别人感受。\n\n展示也是相当重要的一部分，如我上文所提。当你在最后的展示的时候，你需要让所有人都能感受到你的热爱，感受到你们的想法和你们所实现的东西的激情，这时候就需要你的表达能力和感染力了。在台上不要害怕，保持谦虚是一种很好的驱赶恐慌感的方式。简单明了的让大家了解你的想法，并且通过demo的演示让大家感受到你的热爱。好的东西，才更需要一种好的途径进入每一个观众的内心。","slug":"谈谈我对Hackathon的理解","published":1,"updated":"2015-12-19T01:08:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyu20008j4rbogkilg57"},{"title":"语","date":"2015-12-21T03:52:36.000Z","_content":"\n\n> 对自己降低期望是对自己最好的宽恕。  \n> 有时候期望太高反而没有办法有所突破吧。\n","source":"_posts/语.md","raw":"title: 语\ndate: 2015-12-21 11:52:36\ncategories: 闲言碎语\ntags:\n---\n\n\n> 对自己降低期望是对自己最好的宽恕。  \n> 有时候期望太高反而没有办法有所突破吧。\n","slug":"语","published":1,"updated":"2015-12-21T03:54:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyua000dj4rbgcrhyc6a"},{"title":"知乎 Hackathon 之前对于知乎产品形态的一些疯狂想法","date":"2016-03-08T03:02:40.000Z","_content":"\n知乎的 Hackathon 又要开始了，然而不对外开放，因此也没办法参加了 =。- 实在可惜。  \n知乎一直是社区产品中比较奇葩的存在，因为同时期的其他社区都做得不是特别好，但是知乎带着并不特殊的产品形态，凭借着良好的运营，在社区类产品中鹤立鸡群。\n\n然后  \n好久没参加 Hackathon 了😂  \n心里有点痒痒的\n\n## Idea A\n\n第一个想法是一个开源的开放的人类知识库计划。互联网时代，一个革新是信息可以存在互联网上随时供大众访问，而知乎所在努力打造和维护的一种氛围，也是以知识为硬通货的共享经济。知乎通过良好的运营和口碑，积累了大量忠实用户，也有很大一部分处于社会高级知识阶层的用户愿意在这个社区里共享自己的知识。但是随着整个社区的快速扩张和开放，越来越多的知识需求方或者说知识缺乏者涌入了社区。这对于社区本来应该是好事，但是由于之前并没有对这些用户进行良好的区分，不得不说现在知乎的娱乐性越来越强，质量也没有以前那么好了。  \n所以我们需要这样一个开源的开放的人类知识库计划。为什么说是开源？因为任何人都可以申请成为贡献者，当然，贡献者会需要一定要求，比方说教授以上，论文质量，或者什么学术机构的负责人之类的，这样才可以保证进入这个知识库的知识都是得到出厂认证的。这个知识库可以以社区的形式存在，同一领域的不同专家可以各自发表意见，甚至可以互喷，要知道，人类的文明进步，可离不开辩论和争执。为什么说是开放？因为任何人都可以访问，都可以获取，它的存在形式，你可以理解为十万个为什么的进化版。在思考什么百度百科，维基百科这些所谓的同类产品的时候，我突然意识到这根本不在同一个维度上，十万个为什么忽然跳进我的脑海，一切就豁然开朗：百科是在完成对于事物的定义，而十万个为什么和这个所谓的知识库，是在完成对于知识的定义。知识的范畴可大了，才不仅仅包括事物。这也是百度经验，百度知道想做的事情吧。但是这两者的竞争力基本就可以不用考虑了。就像，你不会觉得十万个为什么会是知乎的竞争对手一样😂  \nSo，十万个为什么这么伟大的存在，这个几乎所有人的知识启蒙老师，为什么现在地位越来越淡，没错，因为我们长大了啊😂，他所面对的人群和包含的知识水平都是很初级的，但是他在整个文化普及运动中起到了不可估量的作用。我觉得有兴趣的朋友可以去考证一下？（我记得以前看过类似的说法😂）所以，为了提高整个社会的知识水平，为了提高甚至整个人类文明的知识水平，同时利用互联网的优势，我觉得有必要，哪怕不是一个Hackathon能完成的东西，也应该有一家企业去完成这个艰巨的任务，抱着像谷歌那样的贡献社会，贡献人类的宗旨去努力。况且，这个知识库将是人类文明重新走上发展轨道的一块很重要的垫脚石。\n> （别告诉我现在天天看新闻看到经济有多好生活有多富足你就觉得人类现在还是发展的很快了，信息革命应该已经没什么动力了，无人机VR什么的都只是很小的一部分，并不能带动一个时代，现在随着互联网创新能力的削弱，下一个科技时代的带动技术还没有出现，这才是我忧虑的地方）\n\n\n## Idea B\n第二个想法，是一个无比疯狂的想法，但是不幸的是，需要第一个想法的支撑。这也是我说**「这个知识库将是人类文明重新走上发展轨道的一块很重要的垫脚石」** 的原因。人类历史上所在进行的活动，一直都是在不断地将意识形态的东西转化成物质形态的东西，简单地说，就是将理论知识转化成哪怕是文字也好，产品也好的物质存在。人类在发展过程中不断地发现一些定律，发明一些理论，然后不断去打磨理论，就好比人类最后将 E=mc2 打磨成了小男孩一样。但是，没有人能够反向，也没有人想过反向。  \n我来讲一个很形象的故事吧。我想造一台手机，我需要先去了解各种手机厂商的历史，设计原理，我需要去学习工业设计，需要去学习什么人体工程学，然后我还要学习大量的硬件知识，或者说了解不同的硬件应该如何去组合来构成一个能够工作的机器，毕竟一些基本的组件现在都已经不用你去关心了，再然后你还要去学习各种材料化学方面的知识，来制作外壳之类的，就算是你了解完这些，你还要去了解销售，产品，仓储物流，市场营销这些七七八八的知识，从而把你的手机卖出去，当然，这些都没有算上手机里面的软件了。（我只是举例，所以说的不可能十分精确，毕竟我也没造过手机=。=）我们可以看到，人类历史上对于意识形态向物质形态转化的这种方式，随着我们文明的进化和物质形态复杂度的增加，已经变得十分的庞大和不可控制了。试想，如果让你去图书馆，或者更好一些，给你互联网，让你去搜索，你要花费多大的成本来获取这些所有的知识？因此我们可以试着反向去获取知识，将**物质形态直接逆向解析成意识形态**。我只要将这个手机拍下来，一个工具就会将它所包含的所有方面的知识都解析出来，并且以一种更直接和明显的方式显示出来。我就可以**直接的**获取到物质形态所包含的所有意识形态。  \n\n这对于未来的教育，人类去了解世界的方式都是一个重大的变革。也就是说，通过人类文明几千年的积累和互联网技术的发展，将人类到目前为止所有的知识收集在一起，并且完成这样一个工具，让未来的人类能够更加直接的去获取知识，了解世界。我们之前所接受的教育，都是在教给我们几乎所有的基础理论知识，然后再去了解这个世界，到了大学，虽然好像是分开了专业，学习了不同的专业课，但是我们在选择专业的时候本身就是迷茫的，并且即使选择了专业，每个专业的细分领域还是非常的多，如果我们按照现有的模式去学习，那么可能我们要花4到10年的时间去循序渐进的获取知识，成为专业人才，更别说浪费在通识教育的十几年了。然而，如果有了这样一个工具，我们只需要教育未来的孩子们如何去使用这样的工具，这是几乎不用教的吧😂 然后他就可以用这个工具去学习，从最基础的数学定理到最接近用户的设计，以这种更具针对性的方式去学习，我想，就看重人的学习能力，而这样的人才，也会更早成长，更专业吧。  \n但是吧，我觉得这个工具最大的意义，还是在于完整了人类文明发展的一个循环。意识形态的知识通过实践转化为物质形态的产品，而产品可以被解析成知识，从而可以在意识形态上更好的创新。\n","source":"_posts/知乎-Hackathon-之前对于知乎产品形态的一些疯狂想法.md","raw":"title: 知乎 Hackathon 之前对于知乎产品形态的一些疯狂想法\ncategories: 闲言碎语\ndate: 2016-03-08 11:02:40\n\ntags: [Hackathon]\n---\n\n知乎的 Hackathon 又要开始了，然而不对外开放，因此也没办法参加了 =。- 实在可惜。  \n知乎一直是社区产品中比较奇葩的存在，因为同时期的其他社区都做得不是特别好，但是知乎带着并不特殊的产品形态，凭借着良好的运营，在社区类产品中鹤立鸡群。\n\n然后  \n好久没参加 Hackathon 了😂  \n心里有点痒痒的\n\n## Idea A\n\n第一个想法是一个开源的开放的人类知识库计划。互联网时代，一个革新是信息可以存在互联网上随时供大众访问，而知乎所在努力打造和维护的一种氛围，也是以知识为硬通货的共享经济。知乎通过良好的运营和口碑，积累了大量忠实用户，也有很大一部分处于社会高级知识阶层的用户愿意在这个社区里共享自己的知识。但是随着整个社区的快速扩张和开放，越来越多的知识需求方或者说知识缺乏者涌入了社区。这对于社区本来应该是好事，但是由于之前并没有对这些用户进行良好的区分，不得不说现在知乎的娱乐性越来越强，质量也没有以前那么好了。  \n所以我们需要这样一个开源的开放的人类知识库计划。为什么说是开源？因为任何人都可以申请成为贡献者，当然，贡献者会需要一定要求，比方说教授以上，论文质量，或者什么学术机构的负责人之类的，这样才可以保证进入这个知识库的知识都是得到出厂认证的。这个知识库可以以社区的形式存在，同一领域的不同专家可以各自发表意见，甚至可以互喷，要知道，人类的文明进步，可离不开辩论和争执。为什么说是开放？因为任何人都可以访问，都可以获取，它的存在形式，你可以理解为十万个为什么的进化版。在思考什么百度百科，维基百科这些所谓的同类产品的时候，我突然意识到这根本不在同一个维度上，十万个为什么忽然跳进我的脑海，一切就豁然开朗：百科是在完成对于事物的定义，而十万个为什么和这个所谓的知识库，是在完成对于知识的定义。知识的范畴可大了，才不仅仅包括事物。这也是百度经验，百度知道想做的事情吧。但是这两者的竞争力基本就可以不用考虑了。就像，你不会觉得十万个为什么会是知乎的竞争对手一样😂  \nSo，十万个为什么这么伟大的存在，这个几乎所有人的知识启蒙老师，为什么现在地位越来越淡，没错，因为我们长大了啊😂，他所面对的人群和包含的知识水平都是很初级的，但是他在整个文化普及运动中起到了不可估量的作用。我觉得有兴趣的朋友可以去考证一下？（我记得以前看过类似的说法😂）所以，为了提高整个社会的知识水平，为了提高甚至整个人类文明的知识水平，同时利用互联网的优势，我觉得有必要，哪怕不是一个Hackathon能完成的东西，也应该有一家企业去完成这个艰巨的任务，抱着像谷歌那样的贡献社会，贡献人类的宗旨去努力。况且，这个知识库将是人类文明重新走上发展轨道的一块很重要的垫脚石。\n> （别告诉我现在天天看新闻看到经济有多好生活有多富足你就觉得人类现在还是发展的很快了，信息革命应该已经没什么动力了，无人机VR什么的都只是很小的一部分，并不能带动一个时代，现在随着互联网创新能力的削弱，下一个科技时代的带动技术还没有出现，这才是我忧虑的地方）\n\n\n## Idea B\n第二个想法，是一个无比疯狂的想法，但是不幸的是，需要第一个想法的支撑。这也是我说**「这个知识库将是人类文明重新走上发展轨道的一块很重要的垫脚石」** 的原因。人类历史上所在进行的活动，一直都是在不断地将意识形态的东西转化成物质形态的东西，简单地说，就是将理论知识转化成哪怕是文字也好，产品也好的物质存在。人类在发展过程中不断地发现一些定律，发明一些理论，然后不断去打磨理论，就好比人类最后将 E=mc2 打磨成了小男孩一样。但是，没有人能够反向，也没有人想过反向。  \n我来讲一个很形象的故事吧。我想造一台手机，我需要先去了解各种手机厂商的历史，设计原理，我需要去学习工业设计，需要去学习什么人体工程学，然后我还要学习大量的硬件知识，或者说了解不同的硬件应该如何去组合来构成一个能够工作的机器，毕竟一些基本的组件现在都已经不用你去关心了，再然后你还要去学习各种材料化学方面的知识，来制作外壳之类的，就算是你了解完这些，你还要去了解销售，产品，仓储物流，市场营销这些七七八八的知识，从而把你的手机卖出去，当然，这些都没有算上手机里面的软件了。（我只是举例，所以说的不可能十分精确，毕竟我也没造过手机=。=）我们可以看到，人类历史上对于意识形态向物质形态转化的这种方式，随着我们文明的进化和物质形态复杂度的增加，已经变得十分的庞大和不可控制了。试想，如果让你去图书馆，或者更好一些，给你互联网，让你去搜索，你要花费多大的成本来获取这些所有的知识？因此我们可以试着反向去获取知识，将**物质形态直接逆向解析成意识形态**。我只要将这个手机拍下来，一个工具就会将它所包含的所有方面的知识都解析出来，并且以一种更直接和明显的方式显示出来。我就可以**直接的**获取到物质形态所包含的所有意识形态。  \n\n这对于未来的教育，人类去了解世界的方式都是一个重大的变革。也就是说，通过人类文明几千年的积累和互联网技术的发展，将人类到目前为止所有的知识收集在一起，并且完成这样一个工具，让未来的人类能够更加直接的去获取知识，了解世界。我们之前所接受的教育，都是在教给我们几乎所有的基础理论知识，然后再去了解这个世界，到了大学，虽然好像是分开了专业，学习了不同的专业课，但是我们在选择专业的时候本身就是迷茫的，并且即使选择了专业，每个专业的细分领域还是非常的多，如果我们按照现有的模式去学习，那么可能我们要花4到10年的时间去循序渐进的获取知识，成为专业人才，更别说浪费在通识教育的十几年了。然而，如果有了这样一个工具，我们只需要教育未来的孩子们如何去使用这样的工具，这是几乎不用教的吧😂 然后他就可以用这个工具去学习，从最基础的数学定理到最接近用户的设计，以这种更具针对性的方式去学习，我想，就看重人的学习能力，而这样的人才，也会更早成长，更专业吧。  \n但是吧，我觉得这个工具最大的意义，还是在于完整了人类文明发展的一个循环。意识形态的知识通过实践转化为物质形态的产品，而产品可以被解析成知识，从而可以在意识形态上更好的创新。\n","slug":"知乎-Hackathon-之前对于知乎产品形态的一些疯狂想法","published":1,"updated":"2016-03-08T10:00:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyud000fj4rbpfe43t34"},{"title":"无题-20160120","date":"2016-01-20T09:05:04.000Z","_content":"\n忽然发现拿再多第一，再多人认可你，这个世界还是那么大，还是总会有那么些人，无法满足他们那种居高临下，那种自以为占据所有主动地屌逼感，反而会让他们更加的想要刁难你和鄙视你。如果不是一路人的话，就不会是相互吸引，而只是相互排斥。\n\n最近各种遇见和感受到。  \nBut whatever, 你走你的路，有那么多人支持你，再说了，未来你想要的世界是依靠和你相似，相吸引的这群人一起来创造的，而且你也不断在证明这一点，那么那些所谓的其他人，是吧。\n\n最近准备重新开始读三国演义。觉得团队管理和自己未来的处世方式在里面都有很多可以借鉴的。\n\n例如 纵使你有十万大军，没有一个赵子龙，你一样被人家单骑救阿斗。\n\n很感谢，很感激，自己一路走来，凝聚在我周围或者对我特别在乎，特别认可的基友们。我和你们一起去创造了太多不可能的事情。  \n确实，拿第一第二第三，又有毛用，即使把全国全世界的Hackathon第一都拿遍了，该鄙视我的人还是鄙视我，该认可我的人还是认可我，这些并不能改变什么，相反，所有的事情，我能够去享受每一次的过程，和志同道合的这些基友们一起为了同一个目标热爱和奋斗，这才是我为什么走下去的原因。  \n\n那些鄙视我，不珍惜我的人，请等着被打脸吧。","source":"_posts/无题-20160120.md","raw":"title: 无题-20160120\ndate: 2016-01-20 17:05:04\ncategories: 闲言碎语\n\ntags:\n---\n\n忽然发现拿再多第一，再多人认可你，这个世界还是那么大，还是总会有那么些人，无法满足他们那种居高临下，那种自以为占据所有主动地屌逼感，反而会让他们更加的想要刁难你和鄙视你。如果不是一路人的话，就不会是相互吸引，而只是相互排斥。\n\n最近各种遇见和感受到。  \nBut whatever, 你走你的路，有那么多人支持你，再说了，未来你想要的世界是依靠和你相似，相吸引的这群人一起来创造的，而且你也不断在证明这一点，那么那些所谓的其他人，是吧。\n\n最近准备重新开始读三国演义。觉得团队管理和自己未来的处世方式在里面都有很多可以借鉴的。\n\n例如 纵使你有十万大军，没有一个赵子龙，你一样被人家单骑救阿斗。\n\n很感谢，很感激，自己一路走来，凝聚在我周围或者对我特别在乎，特别认可的基友们。我和你们一起去创造了太多不可能的事情。  \n确实，拿第一第二第三，又有毛用，即使把全国全世界的Hackathon第一都拿遍了，该鄙视我的人还是鄙视我，该认可我的人还是认可我，这些并不能改变什么，相反，所有的事情，我能够去享受每一次的过程，和志同道合的这些基友们一起为了同一个目标热爱和奋斗，这才是我为什么走下去的原因。  \n\n那些鄙视我，不珍惜我的人，请等着被打脸吧。","slug":"无题-20160120","published":1,"updated":"2016-01-20T09:17:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyuh000ij4rb2az2bn99"},{"title":"我的 GayHub - 2016","date":"2016-07-14T11:05:27.000Z","_content":"\n\n\n> As the number of my repos keeps increasing, I have to create this new repo in order to create some kinds of **index** for all the repos that I have written.\n\n![](/image/2016-gayhub.png)\n\n# Get to know me\n\nSergio Chan, Born Hacker, Currently works at *RavenTech. Inc* as a Researcher and Hacker\n\n[My blog](http://sergiochan.xyz)  |  [Linkedin](https://cn.linkedin.com/pub/sergio-chan/42/14b/a6) | [Weibo](http://weibo.com/3089081773/profile?topnav=1&wvr=6) \n\n# Below \bis the list of most of my repos\n\n> 下面是我大部分的个人仓库的分类列表\n\n### Algorithm Test 算法测试实现类\n\n- [Monty-Hall-Problem](https://github.com/SergioChan/Monty-Hall-Problem-Swift) 三门问题的Swift验证演示Playground\n- [LinkedListSwift](https://github.com/SergioChan/LinkedListSwift) Swift写的链表实现和各种基本操作\n- [SCPythonSudoku]( https://github.com/SergioChan/SCPythonSudoku ) A Python Sudoku solved program. Python写的深度优先搜索解数独程序\n\n### Kit or Framework for iOS 实用控件类\n\n- [SCBlueToothKit](https://github.com/SergioChan/SCBlueToothKit) Blue Tooth Kit based on Core BlueTooth brings you to fly dealing with Blue Tooth development\n- [SCAwesomeNetworking](https://github.com/SergioChan/SCAwesomeNetworking) An optimized networking framework based on AFNetworking and ProtoBuffer\n- [SCImagePicker](https://github.com/SergioChan/ImagePicker) A highly encapsulated and fully functional open-source image picker written in Objc based on Photokit. Including album list, asset list, selection preview, camera and short video taking\n- [SCTableViewCell](https://github.com/SergioChan/SCTableViewCell) Swipe-to-Delete Effects like iOS Native Mail App。一个模仿iOS8中的邮箱里面的cell删除动效以及滑动右侧菜单按钮效果的开源库\n- [SCNavigationControlCenter](https://github.com/SergioChan/SCNavigationControlCenter) This is an advanced navigation control center on iOS that can allow you to navigate to whichever view controller you want. iOS上的改进的导航栏控制中心。\n- [SCActivityIndicatorView](https://github.com/SergioChan/SCActivityIndicatorView) An indicator view providing you more freedom to control and customize it.一个魔性的菊花控件，助你摆脱系统菊花的各种烦恼\n- [SCRealm2SQLORM](https://github.com/SergioChan/SCRealm2SQLORM) A realm ORM kit transferring realm usage to traditional SQLite usage. Just for learning and practicing.这是一个简单的realm的类似sqlite的数据库接口库。可以给熟悉sql语法，新入门realm的新手参考\n- [SCTagWriteView](https://github.com/SergioChan/SCTagWriteView) An input custom view providing you ability to add and remove tags\n- [TUCalender](https://github.com/SergioChan/TUCalender) 根据业务需要基于JTCalendar改写的日历控件\n- [UILabel-AttributedText](https://github.com/SergioChan/UILabel-AttributedText) This is a solution category for UILabel to deal with the issue about special chracters.\n\n### Test on iOS Basic Frameworks iOS基础框架的测试实现类\n\n- [RunloopTest](https://github.com/SergioChan/RunloopTest)  This is a demo project for one of my blogs\n- [id-NSObjectDemo](https://github.com/SergioChan/id-NSObjectDemo) This is a demo project for one of my blogs\n\n### Animations on iOS 动画类\n\n- [SCTrelloNavigation](https://github.com/SergioChan/SCTrelloNavigation) An iOS native implementation of a Trello Animated Navagation. iOS上类似trello的导航动效控件实现。\n- [SCCatWaitingHUD](https://github.com/SergioChan/SCCatWaitingHUD) This is a cute and simple loading HUD on iOS :-P 这是一个可爱清新简单的加载HUD控件\n- [SCCinemaAnimation](https://github.com/SergioChan/SCCinemaAnimation)  An iOS native implementation of a Cinema Animation Application. iOS上电影购票的动效实现\n\n### Apps 独立应用类\n\n- [SCSelfAgile](https://github.com/SergioChan/SCSelfAgile) A Project for my daily life and well...obviously for fun.**(未上架)**\n- [PasswordTerminator](https://github.com/SergioChan/PasswordTerminator) Simple random password generator and manager. **(已上架)**\n- [MorningHorn](https://github.com/SergioChan/MorningHorn)  This is a warm and simple Alarm App.**(已上架)**\n\n### Others 其他类\n\n- [SCTornadoTCP](https://github.com/SergioChan/SCTornadoTCP) A TCP Server and Client based on tornado\n\n# Organizations\n\n> 参与和发起的一些组织和信息\n\n### [hACKbUSTER](https://github.com/hACKbUSTER)\n\nA hack team for hackathons, consists of the best hackers and designers. Top requirement, top idea, top tech level.\n\n- [FixPlusPlus](https://github.com/hACKbUSTER/FixPlusPlus)  First Prize For SegmentFault Hackathon Beijing. FIX++ (FixPlusPlus) is a professional display solution for future guidelines and instruction manuals. 更专业的拆解拼装展示方案，可应用于乐高玩具，宜家家具，苹果电脑等领域。\n- [Renaissance](https://github.com/hACKbUSTER/Renaissance) First Prize for Art Hackathon 2015 China, Data becomes music. 数据听觉化的尝试。\n- [UberGuide](https://github.com/hACKbUSTER/UberGuide-iOS) Third Prize for Uber Hackathon China 2016. Source code for iOS client of UberGuide Project. 用Uber API 让背包客通过Uber探索新的城市和文化。\n- [ProjectDaVinci](https://github.com/hACKbUSTER/ProjectDaVinci) First Prize of SegmentFault ✖️ AngelHack Shenzhen Hackathon 2016\n- [ProjectM](https://github.com/hACKbUSTER/ProjectM-SafariExtension) First Prize of SegmentFault ✖️ AngelHack Beijing Hackathon 2016\n\n### [Animatious](https://github.com/Animatious)\n\n- [awesome-animation](https://github.com/Animatious/awesome-animation) A great list of open sourced UI Motion Library produced by Animatious Group.\n\n### [@Conf](https://github.com/atConf)\n\n@Conf 团队，做开发者自己的技术大会\n\n- [atswift-2016](https://github.com/atConf/atswift-2016-resources) Resource files for atswift conference 2016, including keynote, pdf, source projects or playgrounds. 2016中国Swift开发者大会","source":"_posts/我的-GayHub-2016.md","raw":"title: 我的 GayHub - 2016\ndate: 2016-07-14 19:05:27\n\ncategories: 闲言碎语\n\n\n\ntags:\n---\n\n\n\n> As the number of my repos keeps increasing, I have to create this new repo in order to create some kinds of **index** for all the repos that I have written.\n\n![](/image/2016-gayhub.png)\n\n# Get to know me\n\nSergio Chan, Born Hacker, Currently works at *RavenTech. Inc* as a Researcher and Hacker\n\n[My blog](http://sergiochan.xyz)  |  [Linkedin](https://cn.linkedin.com/pub/sergio-chan/42/14b/a6) | [Weibo](http://weibo.com/3089081773/profile?topnav=1&wvr=6) \n\n# Below \bis the list of most of my repos\n\n> 下面是我大部分的个人仓库的分类列表\n\n### Algorithm Test 算法测试实现类\n\n- [Monty-Hall-Problem](https://github.com/SergioChan/Monty-Hall-Problem-Swift) 三门问题的Swift验证演示Playground\n- [LinkedListSwift](https://github.com/SergioChan/LinkedListSwift) Swift写的链表实现和各种基本操作\n- [SCPythonSudoku]( https://github.com/SergioChan/SCPythonSudoku ) A Python Sudoku solved program. Python写的深度优先搜索解数独程序\n\n### Kit or Framework for iOS 实用控件类\n\n- [SCBlueToothKit](https://github.com/SergioChan/SCBlueToothKit) Blue Tooth Kit based on Core BlueTooth brings you to fly dealing with Blue Tooth development\n- [SCAwesomeNetworking](https://github.com/SergioChan/SCAwesomeNetworking) An optimized networking framework based on AFNetworking and ProtoBuffer\n- [SCImagePicker](https://github.com/SergioChan/ImagePicker) A highly encapsulated and fully functional open-source image picker written in Objc based on Photokit. Including album list, asset list, selection preview, camera and short video taking\n- [SCTableViewCell](https://github.com/SergioChan/SCTableViewCell) Swipe-to-Delete Effects like iOS Native Mail App。一个模仿iOS8中的邮箱里面的cell删除动效以及滑动右侧菜单按钮效果的开源库\n- [SCNavigationControlCenter](https://github.com/SergioChan/SCNavigationControlCenter) This is an advanced navigation control center on iOS that can allow you to navigate to whichever view controller you want. iOS上的改进的导航栏控制中心。\n- [SCActivityIndicatorView](https://github.com/SergioChan/SCActivityIndicatorView) An indicator view providing you more freedom to control and customize it.一个魔性的菊花控件，助你摆脱系统菊花的各种烦恼\n- [SCRealm2SQLORM](https://github.com/SergioChan/SCRealm2SQLORM) A realm ORM kit transferring realm usage to traditional SQLite usage. Just for learning and practicing.这是一个简单的realm的类似sqlite的数据库接口库。可以给熟悉sql语法，新入门realm的新手参考\n- [SCTagWriteView](https://github.com/SergioChan/SCTagWriteView) An input custom view providing you ability to add and remove tags\n- [TUCalender](https://github.com/SergioChan/TUCalender) 根据业务需要基于JTCalendar改写的日历控件\n- [UILabel-AttributedText](https://github.com/SergioChan/UILabel-AttributedText) This is a solution category for UILabel to deal with the issue about special chracters.\n\n### Test on iOS Basic Frameworks iOS基础框架的测试实现类\n\n- [RunloopTest](https://github.com/SergioChan/RunloopTest)  This is a demo project for one of my blogs\n- [id-NSObjectDemo](https://github.com/SergioChan/id-NSObjectDemo) This is a demo project for one of my blogs\n\n### Animations on iOS 动画类\n\n- [SCTrelloNavigation](https://github.com/SergioChan/SCTrelloNavigation) An iOS native implementation of a Trello Animated Navagation. iOS上类似trello的导航动效控件实现。\n- [SCCatWaitingHUD](https://github.com/SergioChan/SCCatWaitingHUD) This is a cute and simple loading HUD on iOS :-P 这是一个可爱清新简单的加载HUD控件\n- [SCCinemaAnimation](https://github.com/SergioChan/SCCinemaAnimation)  An iOS native implementation of a Cinema Animation Application. iOS上电影购票的动效实现\n\n### Apps 独立应用类\n\n- [SCSelfAgile](https://github.com/SergioChan/SCSelfAgile) A Project for my daily life and well...obviously for fun.**(未上架)**\n- [PasswordTerminator](https://github.com/SergioChan/PasswordTerminator) Simple random password generator and manager. **(已上架)**\n- [MorningHorn](https://github.com/SergioChan/MorningHorn)  This is a warm and simple Alarm App.**(已上架)**\n\n### Others 其他类\n\n- [SCTornadoTCP](https://github.com/SergioChan/SCTornadoTCP) A TCP Server and Client based on tornado\n\n# Organizations\n\n> 参与和发起的一些组织和信息\n\n### [hACKbUSTER](https://github.com/hACKbUSTER)\n\nA hack team for hackathons, consists of the best hackers and designers. Top requirement, top idea, top tech level.\n\n- [FixPlusPlus](https://github.com/hACKbUSTER/FixPlusPlus)  First Prize For SegmentFault Hackathon Beijing. FIX++ (FixPlusPlus) is a professional display solution for future guidelines and instruction manuals. 更专业的拆解拼装展示方案，可应用于乐高玩具，宜家家具，苹果电脑等领域。\n- [Renaissance](https://github.com/hACKbUSTER/Renaissance) First Prize for Art Hackathon 2015 China, Data becomes music. 数据听觉化的尝试。\n- [UberGuide](https://github.com/hACKbUSTER/UberGuide-iOS) Third Prize for Uber Hackathon China 2016. Source code for iOS client of UberGuide Project. 用Uber API 让背包客通过Uber探索新的城市和文化。\n- [ProjectDaVinci](https://github.com/hACKbUSTER/ProjectDaVinci) First Prize of SegmentFault ✖️ AngelHack Shenzhen Hackathon 2016\n- [ProjectM](https://github.com/hACKbUSTER/ProjectM-SafariExtension) First Prize of SegmentFault ✖️ AngelHack Beijing Hackathon 2016\n\n### [Animatious](https://github.com/Animatious)\n\n- [awesome-animation](https://github.com/Animatious/awesome-animation) A great list of open sourced UI Motion Library produced by Animatious Group.\n\n### [@Conf](https://github.com/atConf)\n\n@Conf 团队，做开发者自己的技术大会\n\n- [atswift-2016](https://github.com/atConf/atswift-2016-resources) Resource files for atswift conference 2016, including keynote, pdf, source projects or playgrounds. 2016中国Swift开发者大会","slug":"我的-GayHub-2016","published":1,"updated":"2016-07-14T11:08:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyuj000kj4rbsc3nni2v"},{"title":"我是怎么踩过在 OSX 上录屏的坑的","date":"2016-03-23T15:55:44.000Z","_content":"\n昨天开始在研究 OSX 上的屏幕录制并且实时获取视频流或图像帧的实现。遇到了非常大的阻力，各种问题，昨晚纠结了一整晚，终于在小萌的启发下慢慢找到了解决办法，把谷歌和 stackoverflow 都翻了个底朝天，最后的解决有点意外，中间还是有一些细节需要求证，然而除了 Apple Doc 已经没有任何参考文献了，而有些机制 Apple Doc 中都不会涉及。所以此刻迫不及待的想要写一篇博客，来纪念万里长征的第一步。\n\n要实现录屏，有两种途径，一种是通过 `Core Graphic`， 一种是通过 `AVFoundation`。 `Core Graphic` 的话，你可以找到苹果官方的一份 [SampleCode](https://developer.apple.com/library/mac/samplecode/SonOfGrab/Introduction/Intro.html)，如果使用了 \n\n```\nCGImageRef screenShot = CGWindowListCreateImage(CGRectMake(0.0f, 0.0f, [self screenRect].size.width, [self screenRect].size.height), kCGWindowListOptionOnScreenOnly, kCGNullWindowID, kCGWindowImageDefault |kCGWindowImageNominalResolution);\n```\n\n它的优点在于你可以根据 `WindowID` 来获取**指定窗口**的图像，并且可以通过 `ListOption` 来设定各种包括桌面图标，去除桌面图标，去除桌面，这些七七八八的设置，所以微信 Mac 端的截屏功能应该就是使用了上面这行代码。**所以我们也可以设置一个 NSTimer， 来按照六十分之一秒一帧的速度来获取截图，并且形成一个流。** 实践表明性能还不错，对于录屏这种事情烧一烧 CPU 是常有的事情，毕竟你需要按帧来计算像素，而且对于 Mac 而言，CPU 并不是什么特别大的问题 =。= 因此这种办法是**可行的**，然而我觉得不够优雅。\n\n同样，Core Graphic 中还有一种实现办法：`CGDisplayCreateImage`：\n\n```\nCGImageRef Ref = CGDisplayCreateImage(display);\n//NSData *data = (NSData *)CFBridgingRelease(CGDataProviderCopyData(CGImageGetDataProvider(Ref)));\nscreenImg = [[NSImage alloc] initWithCGImage:Ref size:CGDisplayScreenSize(display)];\n//screenImg = [image mutableCopy];\nCGImageRelease(Ref);\nCGDisplayRelease (display);\n```\n\n这种实现的机制和上述的是一致的，实现出来的效果和性能也都不错，但是同样的还是觉得不够优雅。\n\n所以此刻就要转向 `AVFoundation` 了。在 `AVFoundation` 中，有一个 input 类叫做 `AVCaptureScreenInput` 这个 input 直接可以获得到当前屏幕的视频输入。这时候我想起两年前我做过视频追踪人脸的 sdk，简单地说就是通过 `AVDeviceCapture` 来获取相机的 input 然后打开一个 `AVSession`， 然后再将 input 里面的 buffer 读出来，对每一帧进行人脸检测的运算。然后我按照苹果官方的一个录屏的例子和一个 Github 上存在不多的这方面的仓库实现了简单的录屏，使用了 `AVCaptureMovieFileOutput` 作为 output。到这里的时候，一切都很顺利，输出到 mov 文件的录屏都是正常的。然后我开始了从缓冲区读取 buffer 的工作，简单来说，从缓冲区读帧是根据 `AVCaptureFileOutputDelegate` 里面的一个回调 \n\n```\n- (void)captureOutput:(AVCaptureFileOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection;\n\n```\n\n\n来实现的。这里的 `CMSampleBuffers` 是一个 `Core Foundation` 的对象，它包含了零个或多个压缩或未压缩过的特定媒体类型的抽样，通常被用来传递媒体数据。一个 `CMSampleBuffers` 可以包含：\n\n* `CMBlockBuffer`, 可能包含一个或多个的 sample (话说 sample 可以翻译为帧么？还是取样的意思……)\n* `CVImageBuffer` 包含了 buffer 层级的附件和 sample 层级的附件，还包括了包含的所有 sample 的格式，大小和时间信息\n\n按照 Apple Doc， 一个 `CMSampleBuffers` 就是这两种 buffer 之一的一个 wrapper， 因此每一个 `CMSampleBuffers` 只会包含其中之一。你需要用不同的方法来取出里面的数据。所以我就很正常的按照最正常的写法来取 buffer 了：\n\n```\nCVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);\nCVPixelBufferLockBaseAddress(imageBuffer,0);        // Lock the image buffer\n        \nuint8_t *baseAddress = (uint8_t *)CVPixelBufferGetBaseAddressOfPlane(imageBuffer, 0);   // Get information of the image\nsize_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);\nsize_t width = CVPixelBufferGetWidth(imageBuffer);\nsize_t height = CVPixelBufferGetHeight(imageBuffer);\nCGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n\nCGContextRef newContext = CGBitmapContextCreate(baseAddress, width, height, 8, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);\nCGImageRef newImage = CGBitmapContextCreateImage(newContext);\nCGContextRelease(newContext);\n\nCGColorSpaceRelease(colorSpace);\nCVPixelBufferUnlockBaseAddress(imageBuffer,0);\n```\n\n然而这个时候出了个小岔子，这里获取的 `CMSampleBuffers` 里面包的是 `CMBlockBuffer`！于是我开始查各种 stackoverflow， 无解， 一开始以为是视频格式的问题，需要按照 H264 的编码来解析，但是怎么可能呢…… 百思不得其解，即使我将 `CMBlockBuffer` 里面的 Data 读取了出来，也无法转换成 `NSImage`， 说明这个 Data 不是正常的 data。 那么有没有可能一帧被拆成多个 samples 来传输了呢…… 有可能，然而我尝试了仍然无果。\n\n这时候我回头看看，发现我这里并没有将视频导出到文件的需求，有没有其他 output 来替代。偏巧我在 stackoverflow 上看到了[这个问题](http://stackoverflow.com/questions/15916808/capturing-blank-stills-from-a-avcapturescreeninput)，于是就用 `AVCaptureVideoDataOutput` 来尝试。尝试之前我已经有强烈预感了 - - 毕竟上一个 output 是直接输出到文件，而这个 output 明显是直接输出成 data。于是你只要这样给一个 output 就可以恢复正常了：\n\n```\nself.output  = [[AVCaptureVideoDataOutput alloc] init];\n[((AVCaptureVideoDataOutput *)self.output) setVideoSettings:[NSDictionary dictionaryWithObjectsAndKeys:@(kCVPixelFormatType_32BGRA),kCVPixelBufferPixelFormatTypeKey, nil]];\ndispatch_queue_t queue = dispatch_queue_create(\"com.sergio.chan\", 0);\n[(AVCaptureVideoDataOutput *)self.output setSampleBufferDelegate:self queue:queue];\n```\n\n这时候的 sampleBuffer 已经可以正常按帧解析出来了，这里有两个问题，一个是在上面那段代码获取到一个 `CGImageRef` 的 `newImage` 对象后需要每一次都对 newImage 进行一次release，否则内存溢出就要爆炸了，一个是线程安全问题，在上面的代码里可以看出这个新的 `AVCaptureVideoDataOutputSampleBufferDelegate` 其实是在一个独立的线程上接收回调的，因此如果你要在这个 delegate 中进行 UI 操作的话，记得回到主线程操作 =。=\n\n```\n@try {\n    CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);\n    CVPixelBufferLockBaseAddress(imageBuffer,0);        // Lock the image buffer\n    \n    uint8_t *baseAddress = (uint8_t *)CVPixelBufferGetBaseAddressOfPlane(imageBuffer, 0);   // Get information of the image\n    size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);\n    size_t width = CVPixelBufferGetWidth(imageBuffer);\n    size_t height = CVPixelBufferGetHeight(imageBuffer);\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    \n    CGContextRef newContext = CGBitmapContextCreate(baseAddress, width, height, 8, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);\n    CGImageRef newImage = CGBitmapContextCreateImage(newContext);\n    CGContextRelease(newContext);\n    \n    CGColorSpaceRelease(colorSpace);\n    CVPixelBufferUnlockBaseAddress(imageBuffer,0);\n    \n    NSImage *image = [[NSImage alloc] initWithCGImage:newImage size:[self screenRect].size];\n    CGImageRelease(newImage);\n    \n    dispatch_async(dispatch_get_main_queue(), ^{\n        if(self.imageView) {\n            self.imageView.image = image;\n        }\n    });\n}\n@catch (NSException *exception) {\n    NSLog(@\"Error at %@\",exception.debugDescription);\n}\n@finally {\n    return;\n}\n```\n\nPS. Cocoa 中获取 ScreenRect 的方法如下：\n\n```\n- (NSRect)screenRect\n{\n    NSRect screenRect;\n    NSArray *screenArray = [NSScreen screens];\n    NSScreen *screen = [screenArray objectAtIndex: 0];\n    screenRect = [screen frame];//[screen visibleFrame];\n    \n    return screenRect;\n}\n\n```\n> 这里后来又遇到一个小坑。如果使用的是 visibleFrame， 那么如果你的窗口处于全屏模式，获取 visibleFrame 的时候其实会把上面状态栏的那部分区域给省略了，因为计算 visibleFrame 的时候估计不考虑状态栏是否隐藏吧，所以这里用 frame 更好。\n\n这里从 delegate 中获取到每一帧的数据之后就可以对每一帧进行压缩，并且以 Data 的形式进行传输了。差点忘记最后介绍一下 `AVCaptureScreenInput` 的一些特性了：\n\n```\nself.input.capturesMouseClicks = YES;\nself.input.minFrameDuration = CMTimeMake(1, 60);\nself.input.scaleFactor = 0.5f;\nself.input.cropRect = [self screenRect];\n```\n\n首先 `AVCaptureScreenInput` 可以记录下鼠标移动的轨迹，还可以记录鼠标的点击事件（自行体验），第二个属性设置的是最大帧率，也就是60帧一秒。第三个和第四个属性顾名思义分别是缩放的比例和最后输出的裁剪区域，设置这两个属性可以减少每一帧的大小，也就是说在输入的时候就已经限制过大小了，然后你再可以进行一些压缩什么的。最后其实 `AVCaptureScreenInput` 还有一个关键的属性，但是现在已经被废弃了，因为苹果已经把这个属性内置成系统默认了😂 **重复帧会被自动取消**，这在以前的版本是可以通过一个属性设置的，现在已经被默认采用了。\n\n多余的说几点：\n\n* 其实 Core Media 那层有很多知识点，但是苦于文档太少，研究的人也太少，因此实在是举步维艰，感兴趣的朋友可以参考一下[苹果的 Reference ](https://developer.apple.com/library/mac/documentation/CoreMedia/Reference/CMSampleBuffer/)看下这块的内容。\n* 其实可能有些人知道在 `AVFoundation` 下面，`Core Media`之上还有一层叫做 `Video ToolBox`，这在2012年那会儿都是只有越狱的设备才能调用到的 Private API，但是2014年的 WWDC 苹果将这一层开放出来了，因此你可以在 `AVFoundation` 更深入的层次去做视频编码解码和流处理，这块的知识我这次只看了个大概，留下了一些资料出处：[Github](https://github.com/McZonk/VideoToolboxPlus)  [WWDC](https://developer.apple.com/videos/play/wwdc2014/513/)\n\n最后，最重要的是！代码已经整理成开源库放在 [Github](https://github.com/RavenTech-GrowthHacker/RTScreenRecorder) 上了！","source":"_posts/我是怎么踩过在-OSX-上录屏的坑的.md","raw":"title: 我是怎么踩过在 OSX 上录屏的坑的\ndate: 2016-03-23 23:55:44\ncategories: Cocoa入门？\n\ntags: [Cocoa , AVFoundation]\n---\n\n昨天开始在研究 OSX 上的屏幕录制并且实时获取视频流或图像帧的实现。遇到了非常大的阻力，各种问题，昨晚纠结了一整晚，终于在小萌的启发下慢慢找到了解决办法，把谷歌和 stackoverflow 都翻了个底朝天，最后的解决有点意外，中间还是有一些细节需要求证，然而除了 Apple Doc 已经没有任何参考文献了，而有些机制 Apple Doc 中都不会涉及。所以此刻迫不及待的想要写一篇博客，来纪念万里长征的第一步。\n\n要实现录屏，有两种途径，一种是通过 `Core Graphic`， 一种是通过 `AVFoundation`。 `Core Graphic` 的话，你可以找到苹果官方的一份 [SampleCode](https://developer.apple.com/library/mac/samplecode/SonOfGrab/Introduction/Intro.html)，如果使用了 \n\n```\nCGImageRef screenShot = CGWindowListCreateImage(CGRectMake(0.0f, 0.0f, [self screenRect].size.width, [self screenRect].size.height), kCGWindowListOptionOnScreenOnly, kCGNullWindowID, kCGWindowImageDefault |kCGWindowImageNominalResolution);\n```\n\n它的优点在于你可以根据 `WindowID` 来获取**指定窗口**的图像，并且可以通过 `ListOption` 来设定各种包括桌面图标，去除桌面图标，去除桌面，这些七七八八的设置，所以微信 Mac 端的截屏功能应该就是使用了上面这行代码。**所以我们也可以设置一个 NSTimer， 来按照六十分之一秒一帧的速度来获取截图，并且形成一个流。** 实践表明性能还不错，对于录屏这种事情烧一烧 CPU 是常有的事情，毕竟你需要按帧来计算像素，而且对于 Mac 而言，CPU 并不是什么特别大的问题 =。= 因此这种办法是**可行的**，然而我觉得不够优雅。\n\n同样，Core Graphic 中还有一种实现办法：`CGDisplayCreateImage`：\n\n```\nCGImageRef Ref = CGDisplayCreateImage(display);\n//NSData *data = (NSData *)CFBridgingRelease(CGDataProviderCopyData(CGImageGetDataProvider(Ref)));\nscreenImg = [[NSImage alloc] initWithCGImage:Ref size:CGDisplayScreenSize(display)];\n//screenImg = [image mutableCopy];\nCGImageRelease(Ref);\nCGDisplayRelease (display);\n```\n\n这种实现的机制和上述的是一致的，实现出来的效果和性能也都不错，但是同样的还是觉得不够优雅。\n\n所以此刻就要转向 `AVFoundation` 了。在 `AVFoundation` 中，有一个 input 类叫做 `AVCaptureScreenInput` 这个 input 直接可以获得到当前屏幕的视频输入。这时候我想起两年前我做过视频追踪人脸的 sdk，简单地说就是通过 `AVDeviceCapture` 来获取相机的 input 然后打开一个 `AVSession`， 然后再将 input 里面的 buffer 读出来，对每一帧进行人脸检测的运算。然后我按照苹果官方的一个录屏的例子和一个 Github 上存在不多的这方面的仓库实现了简单的录屏，使用了 `AVCaptureMovieFileOutput` 作为 output。到这里的时候，一切都很顺利，输出到 mov 文件的录屏都是正常的。然后我开始了从缓冲区读取 buffer 的工作，简单来说，从缓冲区读帧是根据 `AVCaptureFileOutputDelegate` 里面的一个回调 \n\n```\n- (void)captureOutput:(AVCaptureFileOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection;\n\n```\n\n\n来实现的。这里的 `CMSampleBuffers` 是一个 `Core Foundation` 的对象，它包含了零个或多个压缩或未压缩过的特定媒体类型的抽样，通常被用来传递媒体数据。一个 `CMSampleBuffers` 可以包含：\n\n* `CMBlockBuffer`, 可能包含一个或多个的 sample (话说 sample 可以翻译为帧么？还是取样的意思……)\n* `CVImageBuffer` 包含了 buffer 层级的附件和 sample 层级的附件，还包括了包含的所有 sample 的格式，大小和时间信息\n\n按照 Apple Doc， 一个 `CMSampleBuffers` 就是这两种 buffer 之一的一个 wrapper， 因此每一个 `CMSampleBuffers` 只会包含其中之一。你需要用不同的方法来取出里面的数据。所以我就很正常的按照最正常的写法来取 buffer 了：\n\n```\nCVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);\nCVPixelBufferLockBaseAddress(imageBuffer,0);        // Lock the image buffer\n        \nuint8_t *baseAddress = (uint8_t *)CVPixelBufferGetBaseAddressOfPlane(imageBuffer, 0);   // Get information of the image\nsize_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);\nsize_t width = CVPixelBufferGetWidth(imageBuffer);\nsize_t height = CVPixelBufferGetHeight(imageBuffer);\nCGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n\nCGContextRef newContext = CGBitmapContextCreate(baseAddress, width, height, 8, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);\nCGImageRef newImage = CGBitmapContextCreateImage(newContext);\nCGContextRelease(newContext);\n\nCGColorSpaceRelease(colorSpace);\nCVPixelBufferUnlockBaseAddress(imageBuffer,0);\n```\n\n然而这个时候出了个小岔子，这里获取的 `CMSampleBuffers` 里面包的是 `CMBlockBuffer`！于是我开始查各种 stackoverflow， 无解， 一开始以为是视频格式的问题，需要按照 H264 的编码来解析，但是怎么可能呢…… 百思不得其解，即使我将 `CMBlockBuffer` 里面的 Data 读取了出来，也无法转换成 `NSImage`， 说明这个 Data 不是正常的 data。 那么有没有可能一帧被拆成多个 samples 来传输了呢…… 有可能，然而我尝试了仍然无果。\n\n这时候我回头看看，发现我这里并没有将视频导出到文件的需求，有没有其他 output 来替代。偏巧我在 stackoverflow 上看到了[这个问题](http://stackoverflow.com/questions/15916808/capturing-blank-stills-from-a-avcapturescreeninput)，于是就用 `AVCaptureVideoDataOutput` 来尝试。尝试之前我已经有强烈预感了 - - 毕竟上一个 output 是直接输出到文件，而这个 output 明显是直接输出成 data。于是你只要这样给一个 output 就可以恢复正常了：\n\n```\nself.output  = [[AVCaptureVideoDataOutput alloc] init];\n[((AVCaptureVideoDataOutput *)self.output) setVideoSettings:[NSDictionary dictionaryWithObjectsAndKeys:@(kCVPixelFormatType_32BGRA),kCVPixelBufferPixelFormatTypeKey, nil]];\ndispatch_queue_t queue = dispatch_queue_create(\"com.sergio.chan\", 0);\n[(AVCaptureVideoDataOutput *)self.output setSampleBufferDelegate:self queue:queue];\n```\n\n这时候的 sampleBuffer 已经可以正常按帧解析出来了，这里有两个问题，一个是在上面那段代码获取到一个 `CGImageRef` 的 `newImage` 对象后需要每一次都对 newImage 进行一次release，否则内存溢出就要爆炸了，一个是线程安全问题，在上面的代码里可以看出这个新的 `AVCaptureVideoDataOutputSampleBufferDelegate` 其实是在一个独立的线程上接收回调的，因此如果你要在这个 delegate 中进行 UI 操作的话，记得回到主线程操作 =。=\n\n```\n@try {\n    CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);\n    CVPixelBufferLockBaseAddress(imageBuffer,0);        // Lock the image buffer\n    \n    uint8_t *baseAddress = (uint8_t *)CVPixelBufferGetBaseAddressOfPlane(imageBuffer, 0);   // Get information of the image\n    size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);\n    size_t width = CVPixelBufferGetWidth(imageBuffer);\n    size_t height = CVPixelBufferGetHeight(imageBuffer);\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    \n    CGContextRef newContext = CGBitmapContextCreate(baseAddress, width, height, 8, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);\n    CGImageRef newImage = CGBitmapContextCreateImage(newContext);\n    CGContextRelease(newContext);\n    \n    CGColorSpaceRelease(colorSpace);\n    CVPixelBufferUnlockBaseAddress(imageBuffer,0);\n    \n    NSImage *image = [[NSImage alloc] initWithCGImage:newImage size:[self screenRect].size];\n    CGImageRelease(newImage);\n    \n    dispatch_async(dispatch_get_main_queue(), ^{\n        if(self.imageView) {\n            self.imageView.image = image;\n        }\n    });\n}\n@catch (NSException *exception) {\n    NSLog(@\"Error at %@\",exception.debugDescription);\n}\n@finally {\n    return;\n}\n```\n\nPS. Cocoa 中获取 ScreenRect 的方法如下：\n\n```\n- (NSRect)screenRect\n{\n    NSRect screenRect;\n    NSArray *screenArray = [NSScreen screens];\n    NSScreen *screen = [screenArray objectAtIndex: 0];\n    screenRect = [screen frame];//[screen visibleFrame];\n    \n    return screenRect;\n}\n\n```\n> 这里后来又遇到一个小坑。如果使用的是 visibleFrame， 那么如果你的窗口处于全屏模式，获取 visibleFrame 的时候其实会把上面状态栏的那部分区域给省略了，因为计算 visibleFrame 的时候估计不考虑状态栏是否隐藏吧，所以这里用 frame 更好。\n\n这里从 delegate 中获取到每一帧的数据之后就可以对每一帧进行压缩，并且以 Data 的形式进行传输了。差点忘记最后介绍一下 `AVCaptureScreenInput` 的一些特性了：\n\n```\nself.input.capturesMouseClicks = YES;\nself.input.minFrameDuration = CMTimeMake(1, 60);\nself.input.scaleFactor = 0.5f;\nself.input.cropRect = [self screenRect];\n```\n\n首先 `AVCaptureScreenInput` 可以记录下鼠标移动的轨迹，还可以记录鼠标的点击事件（自行体验），第二个属性设置的是最大帧率，也就是60帧一秒。第三个和第四个属性顾名思义分别是缩放的比例和最后输出的裁剪区域，设置这两个属性可以减少每一帧的大小，也就是说在输入的时候就已经限制过大小了，然后你再可以进行一些压缩什么的。最后其实 `AVCaptureScreenInput` 还有一个关键的属性，但是现在已经被废弃了，因为苹果已经把这个属性内置成系统默认了😂 **重复帧会被自动取消**，这在以前的版本是可以通过一个属性设置的，现在已经被默认采用了。\n\n多余的说几点：\n\n* 其实 Core Media 那层有很多知识点，但是苦于文档太少，研究的人也太少，因此实在是举步维艰，感兴趣的朋友可以参考一下[苹果的 Reference ](https://developer.apple.com/library/mac/documentation/CoreMedia/Reference/CMSampleBuffer/)看下这块的内容。\n* 其实可能有些人知道在 `AVFoundation` 下面，`Core Media`之上还有一层叫做 `Video ToolBox`，这在2012年那会儿都是只有越狱的设备才能调用到的 Private API，但是2014年的 WWDC 苹果将这一层开放出来了，因此你可以在 `AVFoundation` 更深入的层次去做视频编码解码和流处理，这块的知识我这次只看了个大概，留下了一些资料出处：[Github](https://github.com/McZonk/VideoToolboxPlus)  [WWDC](https://developer.apple.com/videos/play/wwdc2014/513/)\n\n最后，最重要的是！代码已经整理成开源库放在 [Github](https://github.com/RavenTech-GrowthHacker/RTScreenRecorder) 上了！","slug":"我是怎么踩过在-OSX-上录屏的坑的","published":1,"updated":"2016-03-23T16:03:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyul000mj4rb7jvtgpql"},{"title":"怎么设计和实现一个Newsfeed系统","date":"2015-04-01T01:14:52.000Z","_content":"\n\n也是拖了好久，才开始写这篇关于Newsfeed系统设计与实现的介绍。今天已经把新产品需要的第一个版本的Newsfeed系统部署完了，所以对整个过程也有了清晰的了解。我希望能够通过我研究，设计，实现和部署这个系统的过程，来展示Facebook，Twitter和朋友圈的基本实现原理大概是什么样的。  \n首先，想要实现类似Facebook的信息流的系统，如果使用最简单的脚本语言加Mysql的实现方式也是未尝不可，只是当一个系统的容量到一定级别之后，简单的技术就会变得难以满足系统的需求了。特别是在实际需求中，feed所在的表可能会经历超大并发的读写，而且由于feed的特殊性——例如Facebook，twitter，这些feed其实都只是一个简单的动态信息，而并非一个完整的对象信息，因此关系型数据库对于Newsfeed系统来说并不是最首选的方案。Feed的实际需求还有：\n\n> * 1.用户需要频繁查询自己和自己好友产生的动态集合。\n> * 2.用户需要频繁的查询自己或其他用户产生的动态的子集。\n>\n第一条需求远大于第二条，即刷朋友圈的次数远大于查看用户相册的次数。  \n\n如果采用关系型数据库，那么第一个需求的实现应该是先从好友表中获取该用户的好友ID，然后通过好友ID在这个表中查询所有的数据，并通过时间排序分页返回之类，这实际上在数据库操作中遍历了大量其他无用的信息，而且当表的容量增大，如果不采用高效的分表或索引，这个操作的代价将会更大。而第二个需求，也是存在同样的问题，当1000个用户分别查看1个用户的timeline时，其中有999次数据库操作是浪费的，因此在Newsfeed的系统中采用Nosql的数据库是更加明智的方案。  \n在开始，选择redis还是cassandra着实让我犹豫了一阵，这篇文章彻底打开了我的思路：\n\n[http://www.csdn.net/article/2013-11-07/2817430-design-decisions-for-scaling-your-high-traffic-feeds](http://www.csdn.net/article/2013-11-07/2817430-design-decisions-for-scaling-your-high-traffic-feeds)\n\n这是一个国外时尚网站和instagram的发展经验。\n\nFashiolista和Instagram都经历了从Redis开始，然后转战Cassandra的过程。笔者之所以会推荐从Redis开始是因为Redis更容易启动和维持。  \n然而Redis存在一定的限制，所有的数据需要被存储在RAM中，成本很高。另外，Redis不支持分片，这意味着你必须在结点间分片（Twemproxy 是一个不错的选择），这种分片很容易，但是添加和删除节点时的数据处理很复杂。当然你可以将Redis作为缓存，然后重新访问数据库，来克服这个限制。但 是随着访问数据库的成本越来越高，笔者建议还是用Cassandra代替Redis。  \nRedis是一种部署比较容易的Nosql数据库，它基于Key-value存储，数据全部存在内存中，访问速度和并发量着实很让人吃惊。对于各种软件中的Notification系统和这种没到Facebook,Twitter那种量级的Newsfeed系统，redis应该是性价比最高的一种数据库解决办法了：它的集群配置比较方便，配置文件比较简单（即使这样还是费了很大的劲，配置文件的详解还是有的，所以配置起来还算方便：[http://blog.csdn.net/neubuffer/article/details/17003909](http://blog.csdn.net/neubuffer/article/details/17003909)\n），并发量不用怎么处理就可以轻松过10w+（[http://my.oschina.net/pblack/blog/102394](http://my.oschina.net/pblack/blog/102394)）\n\n```\n$ numactl -C 6 ./redis-benchmark -q -n 100000 -d 256 \nPING (inline): 145137.88 requests per second \nPING: 144717.80 requests per second MSET (10 keys): 65487.89 requests per second \nSET: 142653.36 requests per second \nGET: 142450.14 requests per second \nINCR: 143061.52 requests per second \nLPUSH: 144092.22 requests per second \nLPOP: 142247.52 requests per second \nSADD: 144717.80 requests per second \nSPOP: 143678.17 requests per second \nLPUSH (again, in order to bench LRANGE): 143061.52 requests per second \nLRANGE (first 100 elements): 29577.05 requests per second \nLRANGE (first 300 elements): 10431.88 requests per second \nLRANGE (first 450 elements): 7010.66 requests per second \nLRANGE (first 600 elements): 5296.61 requests per second\n```\n\n存储的问题解决了，接下来就是主体的服务了。目前最主流的开源feed系统应该就是上面引用的文章所说的feedly，也就是现在改名为stream framework的一个开源项目，其源代码在github上面可以被搜到。目前开源的版本只有python的，其他语言的如果要实现必须去官网购买付费的服务。\n\n* 非开源的：http://getstream.io/get_started/\n* 开源的wiki地址：https://stream-framework.readthedocs.org/en/latest/installation.html\n\n直接用pip安装方式就可以安装好对python的支持。\n\n根据框架要求安装好几个python的库的支持之后，就可以参照提供的这个示例来设计整个系统了  \n[https://github.com/tbarbugli/stream_framework_example](https://github.com/tbarbugli/stream_framework_example)  \n这个框架的原理是使用框架本身提供的Activity类和它的结构，用户根据需求自定义verb，即动态的动作（不知道这么翻译行不行），然后根据使用的数据库形式派生自定义的feed类，确定自定义feed的格式和单个feed的数据上限。这个框架的核心在于Manager类，用户需要继承出一个子类，来实现基本的feed操作。例如添加，删除，分发。（修改feed貌似还不支持）  \n每个feed在数据库中的存在形式即一个key，对应的数据格式是sorted set，这是一个有序集合，每一个元素都有一个排序用的score，而这个score在这就是时间戳。我在自己设计实现相册的时候，也使用了这种设计思想。每一个有序集合里，只存着该feed所拥有的动态的activityId，而动态的基本信息会经过哈希后存在全局的10个hashes中。  \n根据上面提出的两个需求，每个用户就需要有两个feed，一个是每个用户自己的feed，也称为每个用户的timeline，一个是每个用户关注的用户的动态集合，即每个用户的feed，这个feed的维护是通过每次该用户关注的用户发布动态时的分发来进行的。当然，后来加上的相册不在这个框架提供的范围内，我给每个用户又添加了一个存储所有image的key，也是存储每个image唯一的id，再将具体的image信息存储在全局的hashes中。\n按照以上设计实现出来的系统中，当一个用户想要查看自己的feed，他就只需要直接查询自己的feed的这个key中的信息，当一个用户想要查看自己或某人的timeline的时候，他也只需要查询这个timeline中的信息即可，这些操作都是简单地GET，而不会像关系型数据库需要广大的遍历。当然，这个设计的关键之处就在于如何维护这些key中的内容。  \nRedis的官网有详细的博客和操作介绍：[http://redis.io](http://redis.io)\n\n说完了存储，就是最关键的分发。Stream framework的关键就在于利用celery异步队列处理机制实现了动态的分发。它默认必须安装django-celery来支持异步处理分发。  \nDjango-celery是celery在django的一个支持版本。它是独立于django的一个异步队列处理框架，简单地说就是他有一个队列，有N个worker（由用户自定义）等待执行队列中的task和一个或多个django app，也就是task的发送方贯穿而成。因为是django的版本，所以它的task实际上都是在django中预先编译好的。在stream framework中，用来实现分发的task就包括了几个具体的task，如果要自己写一些定向分发动态或notification，djcelery是必须要熟悉和掌握的。  \n我们可能想要实现类似微信朋友圈推广那种下沉式feed，就要通过定向分发将这个动态分发到指定用户的feed中去，而这个分发的工作量是极其大的，如果要给前端的管理平台等提供一个发布的接口，我们必须要用djcelery在后台运行的一个worker来不断的执行这个task，然后先将http请求返回给用户，而这个task的执行结果可以通过设置celery的backend存储目标来输出。  \n具体的celery设置可以参考：\n[http://docs.celeryproject.org/en/latest/django/](http://docs.celeryproject.org/en/latest/django/)","source":"_posts/怎么设计和实现一个Newsfeed系统.md","raw":"title: 怎么设计和实现一个Newsfeed系统\ndate: 2015-04-01 09:14:52\ncategories: Python学习笔记\ntags: [Newsfeed, celery, djcelery, redis, stream framework]\n---\n\n\n也是拖了好久，才开始写这篇关于Newsfeed系统设计与实现的介绍。今天已经把新产品需要的第一个版本的Newsfeed系统部署完了，所以对整个过程也有了清晰的了解。我希望能够通过我研究，设计，实现和部署这个系统的过程，来展示Facebook，Twitter和朋友圈的基本实现原理大概是什么样的。  \n首先，想要实现类似Facebook的信息流的系统，如果使用最简单的脚本语言加Mysql的实现方式也是未尝不可，只是当一个系统的容量到一定级别之后，简单的技术就会变得难以满足系统的需求了。特别是在实际需求中，feed所在的表可能会经历超大并发的读写，而且由于feed的特殊性——例如Facebook，twitter，这些feed其实都只是一个简单的动态信息，而并非一个完整的对象信息，因此关系型数据库对于Newsfeed系统来说并不是最首选的方案。Feed的实际需求还有：\n\n> * 1.用户需要频繁查询自己和自己好友产生的动态集合。\n> * 2.用户需要频繁的查询自己或其他用户产生的动态的子集。\n>\n第一条需求远大于第二条，即刷朋友圈的次数远大于查看用户相册的次数。  \n\n如果采用关系型数据库，那么第一个需求的实现应该是先从好友表中获取该用户的好友ID，然后通过好友ID在这个表中查询所有的数据，并通过时间排序分页返回之类，这实际上在数据库操作中遍历了大量其他无用的信息，而且当表的容量增大，如果不采用高效的分表或索引，这个操作的代价将会更大。而第二个需求，也是存在同样的问题，当1000个用户分别查看1个用户的timeline时，其中有999次数据库操作是浪费的，因此在Newsfeed的系统中采用Nosql的数据库是更加明智的方案。  \n在开始，选择redis还是cassandra着实让我犹豫了一阵，这篇文章彻底打开了我的思路：\n\n[http://www.csdn.net/article/2013-11-07/2817430-design-decisions-for-scaling-your-high-traffic-feeds](http://www.csdn.net/article/2013-11-07/2817430-design-decisions-for-scaling-your-high-traffic-feeds)\n\n这是一个国外时尚网站和instagram的发展经验。\n\nFashiolista和Instagram都经历了从Redis开始，然后转战Cassandra的过程。笔者之所以会推荐从Redis开始是因为Redis更容易启动和维持。  \n然而Redis存在一定的限制，所有的数据需要被存储在RAM中，成本很高。另外，Redis不支持分片，这意味着你必须在结点间分片（Twemproxy 是一个不错的选择），这种分片很容易，但是添加和删除节点时的数据处理很复杂。当然你可以将Redis作为缓存，然后重新访问数据库，来克服这个限制。但 是随着访问数据库的成本越来越高，笔者建议还是用Cassandra代替Redis。  \nRedis是一种部署比较容易的Nosql数据库，它基于Key-value存储，数据全部存在内存中，访问速度和并发量着实很让人吃惊。对于各种软件中的Notification系统和这种没到Facebook,Twitter那种量级的Newsfeed系统，redis应该是性价比最高的一种数据库解决办法了：它的集群配置比较方便，配置文件比较简单（即使这样还是费了很大的劲，配置文件的详解还是有的，所以配置起来还算方便：[http://blog.csdn.net/neubuffer/article/details/17003909](http://blog.csdn.net/neubuffer/article/details/17003909)\n），并发量不用怎么处理就可以轻松过10w+（[http://my.oschina.net/pblack/blog/102394](http://my.oschina.net/pblack/blog/102394)）\n\n```\n$ numactl -C 6 ./redis-benchmark -q -n 100000 -d 256 \nPING (inline): 145137.88 requests per second \nPING: 144717.80 requests per second MSET (10 keys): 65487.89 requests per second \nSET: 142653.36 requests per second \nGET: 142450.14 requests per second \nINCR: 143061.52 requests per second \nLPUSH: 144092.22 requests per second \nLPOP: 142247.52 requests per second \nSADD: 144717.80 requests per second \nSPOP: 143678.17 requests per second \nLPUSH (again, in order to bench LRANGE): 143061.52 requests per second \nLRANGE (first 100 elements): 29577.05 requests per second \nLRANGE (first 300 elements): 10431.88 requests per second \nLRANGE (first 450 elements): 7010.66 requests per second \nLRANGE (first 600 elements): 5296.61 requests per second\n```\n\n存储的问题解决了，接下来就是主体的服务了。目前最主流的开源feed系统应该就是上面引用的文章所说的feedly，也就是现在改名为stream framework的一个开源项目，其源代码在github上面可以被搜到。目前开源的版本只有python的，其他语言的如果要实现必须去官网购买付费的服务。\n\n* 非开源的：http://getstream.io/get_started/\n* 开源的wiki地址：https://stream-framework.readthedocs.org/en/latest/installation.html\n\n直接用pip安装方式就可以安装好对python的支持。\n\n根据框架要求安装好几个python的库的支持之后，就可以参照提供的这个示例来设计整个系统了  \n[https://github.com/tbarbugli/stream_framework_example](https://github.com/tbarbugli/stream_framework_example)  \n这个框架的原理是使用框架本身提供的Activity类和它的结构，用户根据需求自定义verb，即动态的动作（不知道这么翻译行不行），然后根据使用的数据库形式派生自定义的feed类，确定自定义feed的格式和单个feed的数据上限。这个框架的核心在于Manager类，用户需要继承出一个子类，来实现基本的feed操作。例如添加，删除，分发。（修改feed貌似还不支持）  \n每个feed在数据库中的存在形式即一个key，对应的数据格式是sorted set，这是一个有序集合，每一个元素都有一个排序用的score，而这个score在这就是时间戳。我在自己设计实现相册的时候，也使用了这种设计思想。每一个有序集合里，只存着该feed所拥有的动态的activityId，而动态的基本信息会经过哈希后存在全局的10个hashes中。  \n根据上面提出的两个需求，每个用户就需要有两个feed，一个是每个用户自己的feed，也称为每个用户的timeline，一个是每个用户关注的用户的动态集合，即每个用户的feed，这个feed的维护是通过每次该用户关注的用户发布动态时的分发来进行的。当然，后来加上的相册不在这个框架提供的范围内，我给每个用户又添加了一个存储所有image的key，也是存储每个image唯一的id，再将具体的image信息存储在全局的hashes中。\n按照以上设计实现出来的系统中，当一个用户想要查看自己的feed，他就只需要直接查询自己的feed的这个key中的信息，当一个用户想要查看自己或某人的timeline的时候，他也只需要查询这个timeline中的信息即可，这些操作都是简单地GET，而不会像关系型数据库需要广大的遍历。当然，这个设计的关键之处就在于如何维护这些key中的内容。  \nRedis的官网有详细的博客和操作介绍：[http://redis.io](http://redis.io)\n\n说完了存储，就是最关键的分发。Stream framework的关键就在于利用celery异步队列处理机制实现了动态的分发。它默认必须安装django-celery来支持异步处理分发。  \nDjango-celery是celery在django的一个支持版本。它是独立于django的一个异步队列处理框架，简单地说就是他有一个队列，有N个worker（由用户自定义）等待执行队列中的task和一个或多个django app，也就是task的发送方贯穿而成。因为是django的版本，所以它的task实际上都是在django中预先编译好的。在stream framework中，用来实现分发的task就包括了几个具体的task，如果要自己写一些定向分发动态或notification，djcelery是必须要熟悉和掌握的。  \n我们可能想要实现类似微信朋友圈推广那种下沉式feed，就要通过定向分发将这个动态分发到指定用户的feed中去，而这个分发的工作量是极其大的，如果要给前端的管理平台等提供一个发布的接口，我们必须要用djcelery在后台运行的一个worker来不断的执行这个task，然后先将http请求返回给用户，而这个task的执行结果可以通过设置celery的backend存储目标来输出。  \n具体的celery设置可以参考：\n[http://docs.celeryproject.org/en/latest/django/](http://docs.celeryproject.org/en/latest/django/)","slug":"怎么设计和实现一个Newsfeed系统","published":1,"updated":"2015-12-19T01:19:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyur000tj4rbhk13xk7f"},{"title":"如何在 WKWebView 中实现 Safari 原生的阅读模式","date":"2016-10-21T06:28:16.000Z","_content":"\n在浏览器中，阅读模式通常是一个很有用的功能，有人说这是读小说神器，有些人则认为阅读模式可以改善新闻网站的阅读体验，而有些广告商则对此抗议，认为阅读模式损害了广告主利益。当然，阅读模式对于普通用户来说是一种很方便实用的功能，这个无可厚非。\n\n在手机上，阅读模式有两种实现方式，一种是和 Safari 的实现类似的，利用 js 去解析网页数据分析出文本，基本上手机浏览器的实现都和 Safari 类似，另外一种则是抓取网页对应的 RSS 源，解析 RSS 源中的数据格式，取出需要的文本来显示。接下来我要展开讲的就是和 Safari 类似的阅读模式的实现，且是基于 WKWebView 来实现的。\n\n详细的项目代码在这： [PFWebViewController](https://github.com/PerfectFreeze/PFWebViewController)\n\n### 了解 Safari 阅读模式的实现\n\n关于实现，你可以先参考下面这两篇博客：\n\n- [iOS Safari阅读模式分析过程](http://blog.csdn.net/horkychen/article/details/50959785) \n- [iOS Safari阅读模式研究](http://blog.csdn.net/horkychen/article/details/50959771)\n\n> 一定要写这篇博客的原因就是，我能查到与此相关的中文博客有且仅有这两篇，我接下来讲的会更通俗易懂一些，毕竟最后模仿系统实现出来了。上面两篇的作者最后的结论和代码并不能正常运行，但是提供的信息和资源多多少少给了我很多参考。\n>\n> 其中，第二篇中提到的 JavaScriptCore，由于 WKWebView [不再支持](http://stackoverflow.com/questions/25792131/how-to-get-jscontext-from-wkwebview)，我们会用到 WebKit 支持的发送消息的传递信息模式。核心要用到的 JavaScript 文件在这两篇博客中也有给出。\n\n首先，我们需要用两个 WKWebView 来实现整个流程，一个是主要的浏览窗口 ( 暂且命名为 ) **MainWebView**，另一个则是用于阅读模式页面显示的 **ReaderWebView** 。参与整个阅读模式渲染流程的文件大致有这些：\n\n- index.html\n- safari-reader.js # 这个 js 负责的是内容的格式化和渲染，挂载在 **ReaderWebView** 上\n- safari-reader-check.js # 这个 js 负责的是内容的判断和提取，挂载在 **MainWebView**  上，（在最新的 Safari 中我一直没有截到这个脚本，从最后实现的效果来看，苹果可能将这部分放进原生实现了，所以这里我们就只能使用这个比较早期版本的 js 实现的内容判断，会出现一些网页最新版 Safari 会出现阅读模式的按钮而你使用它却判断无法进入阅读模式）\n- ReaderContext.h # 这就是原生实现的 C++ 代码头文件，应该是作为上面两个 js 之间的原生 Bridge，用指针插入的方法用 C++ 向 js 中插入可以直接调用的原生类和方法\n\nSafari 的基本流程就是，当 **MainWebView** 上的网页的 HTML 加载完成后，执行 safari-reader-check (当然后来可能执行原生代码去判断了，或者使用了更新的 js 文件) 中的 FinderJS 的函数来判断当前网页是否存在合适的 Node 来作为 Article，判断的规则大致就是根据 H 标签的个数，文本的长度之类的参数计算出权重，最后获得一个权重最高的 Node 作为 Article 对象。如果存在这个对象，则会告知浏览器显示阅读模式的按钮，反之浏览器则不会显示这个按钮。\n\n当用户点击了这个按钮之后，Article 对象会被提取出来，通过 ReaderContext 传递给 safari-reader.js 处理，然后**加载到 ReaderWebView 里面**。在 **ReaderWebView** 中渲染的 HTML 是一个模板文件，阅读模式中用到的所有 CSS 样式都会在这个 HTML 里面预先定义好，我们可以通过 Safari 的控制台取到这个 HTML 文件：\n\n![](https://ooo.0o0.ooo/2016/10/13/57ff3ba696edb.png)\n\n在 macOS 的 Safari 中就可以取到，Safari 中在任意有阅读模式选项的页面下点击这个按钮，然后进入页面的检查模式，你会看到 HTML 代码如下：\n\n![](https://ooo.0o0.ooo/2016/10/13/57ff3c766c7a9.png)\n\n当 body 加载的时候，它会调用 `ReaderJS.loaded()` 方法，这个方法负责处理 ReaderContext 传递过来的 Article 对象并将生成的 `<div class=\"page\">` 这个标签添加到 id 为 article 的标签下面。 用到的两个 js 文件都是匿名脚本，其中主要的 safari_reader.js 脚本可以通过点击空白区域添加断点来截获的（因为他实现了一个监听鼠标点击的事件）。\n\n### 我的实现\n\n首先，初始化两个 webView，并在 **MainWebView** 上加载原网页，记得：\n\n```\n _webView.navigationDelegate = self;\n _readerWebView.navigationDelegate = self;\n```\n\n初始化的时候，我们需要为两个 **MainWebView** 挂载 safari-reader-check.js 的脚本，需要为 **ReaderWebView**  同时挂载 safari-reader-check.js 和 safari-reader.js 这两个脚本，初始化的时候赋给两个 webview 的 `WKWebViewConfiguration` 按照如下来定义：\n\n```\n- (WKWebViewConfiguration *)configuration {\n    // Load reader mode js script\n    NSBundle *bundle = [NSBundle bundleForClass:[self class]];\n    NSURL *url = [bundle URLForResource:@\"PFWebViewController\" withExtension:@\"bundle\"];\n    NSBundle *scriptBundle = [NSBundle bundleWithURL:url];\n    \n    NSString *readerScriptFilePath = [scriptBundle pathForResource:@\"safari-reader\" ofType:@\"js\"];\n    NSString *readerCheckScriptFilePath = [scriptBundle pathForResource:@\"safari-reader-check\" ofType:@\"js\"];\n    \n    NSString *indexPageFilePath = [scriptBundle pathForResource:@\"index\" ofType:@\"html\"];\n    \n    // Load HTML for reader mode\n    readerHTMLString = [[NSString alloc] initWithContentsOfFile:indexPageFilePath encoding:NSUTF8StringEncoding error:nil];\n    \n    NSString *script = [[NSString alloc] initWithContentsOfFile:readerScriptFilePath encoding:NSUTF8StringEncoding error:nil];\n    WKUserScript *userScript = [[WKUserScript alloc] initWithSource:script injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:NO];\n    \n    NSString *check_script = [[NSString alloc] initWithContentsOfFile:readerCheckScriptFilePath encoding:NSUTF8StringEncoding error:nil];\n    WKUserScript *check_userScript = [[WKUserScript alloc] initWithSource:check_script injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:NO];\n    \n    WKUserContentController *userContentController = [[WKUserContentController alloc] init];\n    [userContentController addUserScript:userScript];\n    [userContentController addUserScript:check_userScript];\n    [userContentController addScriptMessageHandler:self name:@\"JSController\"];\n    \n    WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];\n    configuration.userContentController = userContentController;\n\n    return configuration;\n}\n```\n\n这样我们就可以在 `decidePolicyForNavigationResponse` 这个回调中进行阅读模式的判断，这个回调发生的时机是在获得 HTML 响应但尚未根据 HTML 去加载的时候，所以是判断阅读模式的最佳时机：\n\n```\n- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler {\n    if ([webView isEqual:self.readerWebView]) {\n        decisionHandler(WKNavigationResponsePolicyAllow);\n        return;\n    }\n    \n    // Set reader mode button status when navigation finished\n    [_webView evaluateJavaScript:@\"var ReaderArticleFinderJS = new ReaderArticleFinder(document);\" completionHandler:^(id _Nullable object, NSError * _Nullable error) {\n    }];\n    \n    [_webView evaluateJavaScript:@\"ReaderArticleFinderJS.isReaderModeAvailable();\" completionHandler:^(id _Nullable object, NSError * _Nullable error) {\n        if ([object integerValue] == 1) {\n            self.toolbar.readerModeBtn.enabled = YES;\n        } else {\n            self.toolbar.readerModeBtn.enabled = NO;\n        }\n    }];\n    \n    decisionHandler(WKNavigationResponsePolicyAllow);\n}\n```\n\n<img src=\"https://ooo.0o0.ooo/2016/10/21/5809b436031ce.jpeg\" width = \"40%\" />\n\n接下来就是点击阅读模式按钮的响应事件，这里我们可以不用 C++ 搭桥梁的方式传递对象指针，而直接用了一种更 tricky 的办法，将提取出来的 Article 对象以不可见的形式添加到目标的 **ReaderWebView** 中，然后修改获取到的 js 文件，让 safari-reader.js 在渲染完正文内容后将临时的这个不可见的节点删除。\n\n```\n[_webView evaluateJavaScript:@\"var ReaderArticleFinderJS = new ReaderArticleFinder(document);\" completionHandler:^(id _Nullable object, NSError * _Nullable error) {\n        }];\n[_webView evaluateJavaScript:@\"var article = ReaderArticleFinderJS.findArticle();\" completionHandler:^(id _Nullable object, NSError * _Nullable error) {\n        }];\n[_webView evaluateJavaScript:@\"article.element.outerHTML\" completionHandler:^(id _Nullable object, NSError * _Nullable error) {\n\tif ([object isKindOfClass:[NSString class]] && isReaderMode) {\n\t\t[_webView evaluateJavaScript:@\"ReaderArticleFinderJS.articleTitle()\" completionHandler:^(id _Nullable object_in, NSError * _Nullable error) {\n                    readerArticleTitle = object_in;\n                    \n                    NSMutableString *mut_str = [readerHTMLString mutableCopy];\n                    \n                    // Replace page title with article title\n                    [mut_str replaceOccurrencesOfString:@\"Reader\" withString:readerArticleTitle options:NSLiteralSearch range:NSMakeRange(0, 300)];\n                    NSRange t = [mut_str rangeOfString:@\"<div id=\\\"article\\\" role=\\\"article\\\">\"];\n                    NSInteger location = t.location + t.length;\n                    \n                    NSString *t_object = [NSString stringWithFormat:@\"<div style=\\\"position: absolute; top: -999em\\\">%@</div>\",object];\n                    [mut_str insertString:t_object atIndex:location];\n                    \n                    [_readerWebView loadHTMLString:mut_str baseURL:self.url];\n                    _readerWebView.alpha = 0.0f;\n                }];\n            }\n        }];\n\t\t[_webView evaluateJavaScript:@\"ReaderArticleFinderJS.prepareToTransitionToReader();\" completionHandler:^(id _Nullable object, NSError * _Nullable error) {\n     \t}];\n```\n\n> 这里采用的使 div 不可见的方式比较特别，因为 visibilty 或者 display 或者 height 这些参数都会被 js 排除在计算的节点之外，所以用 **top: -999em** 的写法。\n\n**ReaderWebView** 在 load 之后就会调用挂载在上面的 safari-reader.js 中的 loaded 方法：\n\n```javascript\nloaded: function() {\n    if (!ReaderArticleFinderJS || this._shouldSkipActivationWhenPageLoads())\n        return null;\n    if (this.loadArticle(), ReaderAppearanceJS.initialize(), ReadingPositionStabilizerJS.initialize(), this._shouldRestoreScrollPositionFromOriginalPageAtActivation) {\n        var e = 0;\n        if (e > 0)\n            document.body.scrollTop = e;\n        else {\n            var t = document.getElementById(\"safari-reader-element-marker\");\n            if (t) {\n                var n = parseFloat(t.style.top) / 100,\n                i = t.parentElement,\n                a = i.getBoundingClientRect();\n                document.body.scrollTop = window.scrollY + a.top + a.height * n, i.removeChild(t)\n            }\n        }\n    }\n    this._clickingOutsideOfPaperRectangleDismissesReader && (document.documentElement.addEventListener(\"mousedown\", monitorMouseDownForPotentialDeactivation), document.documentElement.addEventListener(\"click\", deactivateIfEventIsOutsideOfPaperContainer));\n    var o = function() {\n        this.setUserVisibleWidth(this.lastKnownUserVisibleWidth)\n    }.bind(this);\n    window.addEventListener(\"resize\", o, !1);\n\n    var article_node = document.getElementById(\"article\");\n    article_node.firstChild.remove();\n    \n    var message = { 'code' : 0 };\n    window.webkit.messageHandlers.JSController.postMessage(message);\n},\n```\n\n最后几行先是移除了 article 这个节点之下的第一个子节点，也就是我们添加上去的不可见的临时节点。然后通过 `WKWebView` 新的 js 交互方式发送消息，向原生的 Controller 发送一个加载完成的信号，我们可以在原生的 Controller 里面获取这个信息，然后随即开始阅读模式页面切换的动画：\n\n```\n- (void)userContentController:(WKUserContentController *)userContentController\n      didReceiveScriptMessage:(WKScriptMessage *)message {}\n```\n\n> 除了 loaded 方法，safari-reader.js 还有许多代码需要修改，最终可用的版本请参考项目仓库中的文件。\n\n<img src=\"https://ooo.0o0.ooo/2016/10/21/5809b43604002.jpeg\" width = \"40%\" />\n\n### 一个多余的问题记录 - 「在微信中打开」按钮点击失效\n\n在 `WKWebView` 中，比如微信网页有一个 「在微信中打开」的按钮会失效。这是因为微信网页的 HTML 写法是直接在 a 标签的 href 里面写上了 `weixin://` 这样开头的链接，对于 `WKWebView` 来说会作为一个普通的 URL 打开，从而无响应，不会有弹框。\n\n**解决办法**就是拦截非 Http:// 和 Https:// 开头的请求，转成应用内跳转：\n\n```\n- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {\n    if (![navigationAction.request.URL.absoluteString containsString:@\"http://\"] && ![navigationAction.request.URL.absoluteString containsString:@\"https://\"]) {\n        \n        UIApplication *application = [UIApplication sharedApplication];\n#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 100000\n        if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) \t\t{\n            [application openURL:navigationAction.request.URL options:@{} completionHandler:nil];\n         } else {\n            [application openURL:navigationAction.request.URL];\n         }\n#else\n        [application openURL:navigationAction.request.URL];\n#endif\n        decisionHandler(WKNavigationActionPolicyCancel);\n    } else {\n        decisionHandler(WKNavigationActionPolicyAllow);\n    }\n}\n```\n\n### PS.\n\n最后说一句，当然，毕竟这样抓取苹果的脚本来做和系统一样的效果是很 tricky 的办法，但是：\n\n- 审核是能过的，但是不保证能不能一定过\n\n- 有一些网页可能最新的 Safari 支持阅读模式，然而通过上述实现的浏览器却没法支持\n- 如果遇到了 2 的问题，你可以选择使用苹果官方封装的更好的 SafariWebViewController，绝对原生的效果，当然就是自定义程度更低了","source":"_posts/如何在-WKWebView-中实现-Safari-原生的阅读模式.md","raw":"title: 如何在 WKWebView 中实现 Safari 原生的阅读模式\ndate: 2016-10-21 14:28:16\ncategories: iOS菜鸟心得\n\n\ntags: [WKWebView, WebKit, Safari 阅读模式]\n---\n\n在浏览器中，阅读模式通常是一个很有用的功能，有人说这是读小说神器，有些人则认为阅读模式可以改善新闻网站的阅读体验，而有些广告商则对此抗议，认为阅读模式损害了广告主利益。当然，阅读模式对于普通用户来说是一种很方便实用的功能，这个无可厚非。\n\n在手机上，阅读模式有两种实现方式，一种是和 Safari 的实现类似的，利用 js 去解析网页数据分析出文本，基本上手机浏览器的实现都和 Safari 类似，另外一种则是抓取网页对应的 RSS 源，解析 RSS 源中的数据格式，取出需要的文本来显示。接下来我要展开讲的就是和 Safari 类似的阅读模式的实现，且是基于 WKWebView 来实现的。\n\n详细的项目代码在这： [PFWebViewController](https://github.com/PerfectFreeze/PFWebViewController)\n\n### 了解 Safari 阅读模式的实现\n\n关于实现，你可以先参考下面这两篇博客：\n\n- [iOS Safari阅读模式分析过程](http://blog.csdn.net/horkychen/article/details/50959785) \n- [iOS Safari阅读模式研究](http://blog.csdn.net/horkychen/article/details/50959771)\n\n> 一定要写这篇博客的原因就是，我能查到与此相关的中文博客有且仅有这两篇，我接下来讲的会更通俗易懂一些，毕竟最后模仿系统实现出来了。上面两篇的作者最后的结论和代码并不能正常运行，但是提供的信息和资源多多少少给了我很多参考。\n>\n> 其中，第二篇中提到的 JavaScriptCore，由于 WKWebView [不再支持](http://stackoverflow.com/questions/25792131/how-to-get-jscontext-from-wkwebview)，我们会用到 WebKit 支持的发送消息的传递信息模式。核心要用到的 JavaScript 文件在这两篇博客中也有给出。\n\n首先，我们需要用两个 WKWebView 来实现整个流程，一个是主要的浏览窗口 ( 暂且命名为 ) **MainWebView**，另一个则是用于阅读模式页面显示的 **ReaderWebView** 。参与整个阅读模式渲染流程的文件大致有这些：\n\n- index.html\n- safari-reader.js # 这个 js 负责的是内容的格式化和渲染，挂载在 **ReaderWebView** 上\n- safari-reader-check.js # 这个 js 负责的是内容的判断和提取，挂载在 **MainWebView**  上，（在最新的 Safari 中我一直没有截到这个脚本，从最后实现的效果来看，苹果可能将这部分放进原生实现了，所以这里我们就只能使用这个比较早期版本的 js 实现的内容判断，会出现一些网页最新版 Safari 会出现阅读模式的按钮而你使用它却判断无法进入阅读模式）\n- ReaderContext.h # 这就是原生实现的 C++ 代码头文件，应该是作为上面两个 js 之间的原生 Bridge，用指针插入的方法用 C++ 向 js 中插入可以直接调用的原生类和方法\n\nSafari 的基本流程就是，当 **MainWebView** 上的网页的 HTML 加载完成后，执行 safari-reader-check (当然后来可能执行原生代码去判断了，或者使用了更新的 js 文件) 中的 FinderJS 的函数来判断当前网页是否存在合适的 Node 来作为 Article，判断的规则大致就是根据 H 标签的个数，文本的长度之类的参数计算出权重，最后获得一个权重最高的 Node 作为 Article 对象。如果存在这个对象，则会告知浏览器显示阅读模式的按钮，反之浏览器则不会显示这个按钮。\n\n当用户点击了这个按钮之后，Article 对象会被提取出来，通过 ReaderContext 传递给 safari-reader.js 处理，然后**加载到 ReaderWebView 里面**。在 **ReaderWebView** 中渲染的 HTML 是一个模板文件，阅读模式中用到的所有 CSS 样式都会在这个 HTML 里面预先定义好，我们可以通过 Safari 的控制台取到这个 HTML 文件：\n\n![](https://ooo.0o0.ooo/2016/10/13/57ff3ba696edb.png)\n\n在 macOS 的 Safari 中就可以取到，Safari 中在任意有阅读模式选项的页面下点击这个按钮，然后进入页面的检查模式，你会看到 HTML 代码如下：\n\n![](https://ooo.0o0.ooo/2016/10/13/57ff3c766c7a9.png)\n\n当 body 加载的时候，它会调用 `ReaderJS.loaded()` 方法，这个方法负责处理 ReaderContext 传递过来的 Article 对象并将生成的 `<div class=\"page\">` 这个标签添加到 id 为 article 的标签下面。 用到的两个 js 文件都是匿名脚本，其中主要的 safari_reader.js 脚本可以通过点击空白区域添加断点来截获的（因为他实现了一个监听鼠标点击的事件）。\n\n### 我的实现\n\n首先，初始化两个 webView，并在 **MainWebView** 上加载原网页，记得：\n\n```\n _webView.navigationDelegate = self;\n _readerWebView.navigationDelegate = self;\n```\n\n初始化的时候，我们需要为两个 **MainWebView** 挂载 safari-reader-check.js 的脚本，需要为 **ReaderWebView**  同时挂载 safari-reader-check.js 和 safari-reader.js 这两个脚本，初始化的时候赋给两个 webview 的 `WKWebViewConfiguration` 按照如下来定义：\n\n```\n- (WKWebViewConfiguration *)configuration {\n    // Load reader mode js script\n    NSBundle *bundle = [NSBundle bundleForClass:[self class]];\n    NSURL *url = [bundle URLForResource:@\"PFWebViewController\" withExtension:@\"bundle\"];\n    NSBundle *scriptBundle = [NSBundle bundleWithURL:url];\n    \n    NSString *readerScriptFilePath = [scriptBundle pathForResource:@\"safari-reader\" ofType:@\"js\"];\n    NSString *readerCheckScriptFilePath = [scriptBundle pathForResource:@\"safari-reader-check\" ofType:@\"js\"];\n    \n    NSString *indexPageFilePath = [scriptBundle pathForResource:@\"index\" ofType:@\"html\"];\n    \n    // Load HTML for reader mode\n    readerHTMLString = [[NSString alloc] initWithContentsOfFile:indexPageFilePath encoding:NSUTF8StringEncoding error:nil];\n    \n    NSString *script = [[NSString alloc] initWithContentsOfFile:readerScriptFilePath encoding:NSUTF8StringEncoding error:nil];\n    WKUserScript *userScript = [[WKUserScript alloc] initWithSource:script injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:NO];\n    \n    NSString *check_script = [[NSString alloc] initWithContentsOfFile:readerCheckScriptFilePath encoding:NSUTF8StringEncoding error:nil];\n    WKUserScript *check_userScript = [[WKUserScript alloc] initWithSource:check_script injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:NO];\n    \n    WKUserContentController *userContentController = [[WKUserContentController alloc] init];\n    [userContentController addUserScript:userScript];\n    [userContentController addUserScript:check_userScript];\n    [userContentController addScriptMessageHandler:self name:@\"JSController\"];\n    \n    WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];\n    configuration.userContentController = userContentController;\n\n    return configuration;\n}\n```\n\n这样我们就可以在 `decidePolicyForNavigationResponse` 这个回调中进行阅读模式的判断，这个回调发生的时机是在获得 HTML 响应但尚未根据 HTML 去加载的时候，所以是判断阅读模式的最佳时机：\n\n```\n- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler {\n    if ([webView isEqual:self.readerWebView]) {\n        decisionHandler(WKNavigationResponsePolicyAllow);\n        return;\n    }\n    \n    // Set reader mode button status when navigation finished\n    [_webView evaluateJavaScript:@\"var ReaderArticleFinderJS = new ReaderArticleFinder(document);\" completionHandler:^(id _Nullable object, NSError * _Nullable error) {\n    }];\n    \n    [_webView evaluateJavaScript:@\"ReaderArticleFinderJS.isReaderModeAvailable();\" completionHandler:^(id _Nullable object, NSError * _Nullable error) {\n        if ([object integerValue] == 1) {\n            self.toolbar.readerModeBtn.enabled = YES;\n        } else {\n            self.toolbar.readerModeBtn.enabled = NO;\n        }\n    }];\n    \n    decisionHandler(WKNavigationResponsePolicyAllow);\n}\n```\n\n<img src=\"https://ooo.0o0.ooo/2016/10/21/5809b436031ce.jpeg\" width = \"40%\" />\n\n接下来就是点击阅读模式按钮的响应事件，这里我们可以不用 C++ 搭桥梁的方式传递对象指针，而直接用了一种更 tricky 的办法，将提取出来的 Article 对象以不可见的形式添加到目标的 **ReaderWebView** 中，然后修改获取到的 js 文件，让 safari-reader.js 在渲染完正文内容后将临时的这个不可见的节点删除。\n\n```\n[_webView evaluateJavaScript:@\"var ReaderArticleFinderJS = new ReaderArticleFinder(document);\" completionHandler:^(id _Nullable object, NSError * _Nullable error) {\n        }];\n[_webView evaluateJavaScript:@\"var article = ReaderArticleFinderJS.findArticle();\" completionHandler:^(id _Nullable object, NSError * _Nullable error) {\n        }];\n[_webView evaluateJavaScript:@\"article.element.outerHTML\" completionHandler:^(id _Nullable object, NSError * _Nullable error) {\n\tif ([object isKindOfClass:[NSString class]] && isReaderMode) {\n\t\t[_webView evaluateJavaScript:@\"ReaderArticleFinderJS.articleTitle()\" completionHandler:^(id _Nullable object_in, NSError * _Nullable error) {\n                    readerArticleTitle = object_in;\n                    \n                    NSMutableString *mut_str = [readerHTMLString mutableCopy];\n                    \n                    // Replace page title with article title\n                    [mut_str replaceOccurrencesOfString:@\"Reader\" withString:readerArticleTitle options:NSLiteralSearch range:NSMakeRange(0, 300)];\n                    NSRange t = [mut_str rangeOfString:@\"<div id=\\\"article\\\" role=\\\"article\\\">\"];\n                    NSInteger location = t.location + t.length;\n                    \n                    NSString *t_object = [NSString stringWithFormat:@\"<div style=\\\"position: absolute; top: -999em\\\">%@</div>\",object];\n                    [mut_str insertString:t_object atIndex:location];\n                    \n                    [_readerWebView loadHTMLString:mut_str baseURL:self.url];\n                    _readerWebView.alpha = 0.0f;\n                }];\n            }\n        }];\n\t\t[_webView evaluateJavaScript:@\"ReaderArticleFinderJS.prepareToTransitionToReader();\" completionHandler:^(id _Nullable object, NSError * _Nullable error) {\n     \t}];\n```\n\n> 这里采用的使 div 不可见的方式比较特别，因为 visibilty 或者 display 或者 height 这些参数都会被 js 排除在计算的节点之外，所以用 **top: -999em** 的写法。\n\n**ReaderWebView** 在 load 之后就会调用挂载在上面的 safari-reader.js 中的 loaded 方法：\n\n```javascript\nloaded: function() {\n    if (!ReaderArticleFinderJS || this._shouldSkipActivationWhenPageLoads())\n        return null;\n    if (this.loadArticle(), ReaderAppearanceJS.initialize(), ReadingPositionStabilizerJS.initialize(), this._shouldRestoreScrollPositionFromOriginalPageAtActivation) {\n        var e = 0;\n        if (e > 0)\n            document.body.scrollTop = e;\n        else {\n            var t = document.getElementById(\"safari-reader-element-marker\");\n            if (t) {\n                var n = parseFloat(t.style.top) / 100,\n                i = t.parentElement,\n                a = i.getBoundingClientRect();\n                document.body.scrollTop = window.scrollY + a.top + a.height * n, i.removeChild(t)\n            }\n        }\n    }\n    this._clickingOutsideOfPaperRectangleDismissesReader && (document.documentElement.addEventListener(\"mousedown\", monitorMouseDownForPotentialDeactivation), document.documentElement.addEventListener(\"click\", deactivateIfEventIsOutsideOfPaperContainer));\n    var o = function() {\n        this.setUserVisibleWidth(this.lastKnownUserVisibleWidth)\n    }.bind(this);\n    window.addEventListener(\"resize\", o, !1);\n\n    var article_node = document.getElementById(\"article\");\n    article_node.firstChild.remove();\n    \n    var message = { 'code' : 0 };\n    window.webkit.messageHandlers.JSController.postMessage(message);\n},\n```\n\n最后几行先是移除了 article 这个节点之下的第一个子节点，也就是我们添加上去的不可见的临时节点。然后通过 `WKWebView` 新的 js 交互方式发送消息，向原生的 Controller 发送一个加载完成的信号，我们可以在原生的 Controller 里面获取这个信息，然后随即开始阅读模式页面切换的动画：\n\n```\n- (void)userContentController:(WKUserContentController *)userContentController\n      didReceiveScriptMessage:(WKScriptMessage *)message {}\n```\n\n> 除了 loaded 方法，safari-reader.js 还有许多代码需要修改，最终可用的版本请参考项目仓库中的文件。\n\n<img src=\"https://ooo.0o0.ooo/2016/10/21/5809b43604002.jpeg\" width = \"40%\" />\n\n### 一个多余的问题记录 - 「在微信中打开」按钮点击失效\n\n在 `WKWebView` 中，比如微信网页有一个 「在微信中打开」的按钮会失效。这是因为微信网页的 HTML 写法是直接在 a 标签的 href 里面写上了 `weixin://` 这样开头的链接，对于 `WKWebView` 来说会作为一个普通的 URL 打开，从而无响应，不会有弹框。\n\n**解决办法**就是拦截非 Http:// 和 Https:// 开头的请求，转成应用内跳转：\n\n```\n- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {\n    if (![navigationAction.request.URL.absoluteString containsString:@\"http://\"] && ![navigationAction.request.URL.absoluteString containsString:@\"https://\"]) {\n        \n        UIApplication *application = [UIApplication sharedApplication];\n#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 100000\n        if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) \t\t{\n            [application openURL:navigationAction.request.URL options:@{} completionHandler:nil];\n         } else {\n            [application openURL:navigationAction.request.URL];\n         }\n#else\n        [application openURL:navigationAction.request.URL];\n#endif\n        decisionHandler(WKNavigationActionPolicyCancel);\n    } else {\n        decisionHandler(WKNavigationActionPolicyAllow);\n    }\n}\n```\n\n### PS.\n\n最后说一句，当然，毕竟这样抓取苹果的脚本来做和系统一样的效果是很 tricky 的办法，但是：\n\n- 审核是能过的，但是不保证能不能一定过\n\n- 有一些网页可能最新的 Safari 支持阅读模式，然而通过上述实现的浏览器却没法支持\n- 如果遇到了 2 的问题，你可以选择使用苹果官方封装的更好的 SafariWebViewController，绝对原生的效果，当然就是自定义程度更低了","slug":"如何在-WKWebView-中实现-Safari-原生的阅读模式","published":1,"updated":"2016-10-21T07:08:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyuw0016j4rb8zdjvjkd"},{"title":"使用 Photon 在 Unity 里快速搭建一个多人联机游戏","date":"2016-08-18T08:17:02.000Z","_content":"\n如何最快的搭建一个 Unity 上的多人游戏？答案也许是自己搭建一个游戏服务器，也许是 LAN 解决方案，但是最快的解决方案还是使用成熟的第三方后端服务，我找到了 [Photon](https://www.photonengine.com/en-US/Photon)，一个看起来不错最后证实也挺靠谱的游戏后端解决方案。\n\n一个游戏服务器，最主要的就是对不同参与者的事件同步和世界状态的同步，所以根本还是在于和服务器的长连接上，至于游戏中的用户体系，积分体系，货币体系这些，就是属于大后端的范畴了，也是可以独立于游戏同步服务器存在的系统。\n\n### 安装\n\n首先你需要集成 **Photon SDK For Unity**，下载地址在[这里](https://www.photonengine.com/en-US/Realtime/Download)。\n\n![图1](/image/photon_1.png) \n\n你需要将下载下来的 `PhotoAssets` 中的所有文件都拖到你的项目的 `Assets` 文件夹里面，注意在 `Plugins` 里面有两个 `Photon3Unity3D.dll`，需要将 `Metro` 文件夹删掉，保留一个，否则在 Unity 编译的时候会报错。\n\n拖进去之后只要 Unity 中 Compile 没有问题那第一步就大功告成了。\n\n### 脚本创建\n\n创建一个你用来维护游戏网络逻辑的脚本，例如命名为 `GameNetworkClient.cs`，然后你需要在头部加上这几个引用：\n\n```\nusing System.Collections;\nusing ExitGames.Client.Photon;\nusing ExitGames.Client.Photon.LoadBalancing;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Hashtable = ExitGames.Client.Photon.Hashtable;\n```\n\n接着声明一个私有的 `LoadBalancingClient`对象，你的脚本中的所有网络逻辑都会通过这个 `client` 对象来发起和回调。我们这样在 Start 中初始化 `client` 对象：\n\n```\nclient = new LoadBalancingClient();\nclient.AppId = \"{你的 App_id}\";  \nclient.OnStateChangeAction += this.OnStateChanged;\nclient.OnOpResponseAction += this.OnRespAction;\nclient.OnEventAction += this.OnEvent;\n\nclient.ConnectToRegionMaster(\"asia\");\n```\n\n> 你的 App_id 可以在 Photon 官网注册完免费账户后在账户详情页获取，免费的账户拥有 **20** 个同时在线人数的限额，对于小范围好友间的游戏和测试足够了。\n\n其中，最后一行代码就是 `client` 去连接 MasterServer 的方法，这里面传入的参数要根据你的游戏所在地区来确定， Photon 在全球有很多分散的数据中心，因此支持很多区域的连接，具体支持的地区和代码如下：\n\n| Region        | Hosted in  | Token |\n| ------------- | ---------- | ----- |\n| Asia          | Singapore  | asia  |\n| Australia     | Melbourne  | au    |\n| Canada, East  | Montreal   | cae   |\n| Europe        | Amsterdam  | eu    |\n| Japan         | Tokyo      | jp    |\n| South America | Sao Paulo  | sa    |\n| USA, East     | Washington | us    |\n| USA, West     | San José   | usw   |\n\n所以在这里我改成了 `asia`，事实证明新加坡的服务器是比较稳定的。\n\n### 状态维护\n\n`client` 的状态主要就是根据上面初始化的时候给的三个 Action 来维护的，你需要在你的脚本里为这三个 Action 都加上你自己的 Handler。当然，如果你想按照他的 demo 里示范的那样去继承 `client` 并且 override 这三个 Action 的回调都是可以的。\n\n#### OnStateChanged\n\n返回的是一个 `ClientState` 枚举值，主要就是一些 client 状态的值，例如\n\n `connecting`，`connected`，`joining`之类的。\n\n#### OnRespAction\n\n返回的是一个 `OperationResponse` 对象，它会在每次你用 `client` 对象调用一些方法并且获得 response 之后调用，分别有下面这些类型的 Operation:\n\n```\npublic class OperationCode {\n        [Obsolete(\"Exchanging encrpytion keys is done internally in the lib now. Don't expect this operation-result.\")]\n        public const byte ExchangeKeysForEncryption = 250;\n\n        /// <summary>(255) Code for OpJoin, to get into a room.</summary>\n        public const byte Join = 255;\n\n        /// <summary>(230) Authenticates this peer and connects to a virtual application</summary>\n        public const byte Authenticate = 230;\n\n        /// <summary>(229) Joins lobby (on master)</summary>\n        public const byte JoinLobby = 229;\n\n        /// <summary>(228) Leaves lobby (on master)</summary>\n        public const byte LeaveLobby = 228;\n\n        /// <summary>(227) Creates a game (or fails if name exists)</summary>\n        public const byte CreateGame = 227;\n\n        /// <summary>(226) Join game (by name)</summary>\n        public const byte JoinGame = 226;\n\n        /// <summary>(225) Joins random game (on master)</summary>\n        public const byte JoinRandomGame = 225;\n\n        // public const byte CancelJoinRandom = 224; // obsolete, cause JoinRandom no longer is a \"process\". now provides result immediately\n\n        /// <summary>(254) Code for OpLeave, to get out of a room.</summary>\n        public const byte Leave = (byte)254;\n\n        /// <summary>(253) Raise event (in a room, for other actors/players)</summary>\n        public const byte RaiseEvent = (byte)253;\n\n        /// <summary>(252) Set Properties (of room or actor/player)</summary>\n        public const byte SetProperties = (byte)252;\n\n        /// <summary>(251) Get Properties</summary>\n        public const byte GetProperties = (byte)251;\n\n        /// <summary>(248) Operation code to change interest groups in Rooms (Lite application and extending ones).</summary>\n        public const byte ChangeGroups = (byte)248;\n\n        /// <summary>(222) Request the rooms and online status for a list of friends (by name, which should be unique).</summary>\n        public const byte FindFriends = 222;\n\n        /// <summary>(221) Request statistics about a specific list of lobbies (their user and game count).</summary>\n        public const byte GetLobbyStats = 221;\n\n        /// <summary>(220) Get list of regional servers from a NameServer.</summary>\n        public const byte GetRegions = 220;\n\n        /// <summary>(219) WebRpc Operation.</summary>\n        public const byte WebRpc = 219;\n}\n```\n\n可以看到，例如 `rasieEvent`，`setProperties` 或者加入离开游戏这些请求都是会有服务器的 response 的，你可以根据返回对象的 `ReturnCode` 来判断请求是否成功并且是否执行一些错误后的处理，`ReturnCode` 为 0 成功，不为 0 则失败，如果需要也可以从 `DebugMessage` 中获取错误提示信息。\n\n#### **OnEventAction** \n\n返回的是一个 `EventData` 对象，它会在每次 `client` 接收到新的 Event 的时候调用，具体的 Event 类型根据`EventData` 的 `EventCode` 来确定，分别有下面这些类型的 `EventCode`:\n\n```\npublic class EventCode {\n        /// <summary>(230) Initial list of RoomInfos (in lobby on Master)</summary>\n        public const byte GameList = 230;\n\n        /// <summary>(229) Update of RoomInfos to be merged into \"initial\" list (in lobby on Master)</summary>\n        public const byte GameListUpdate = 229;\n\n        /// <summary>(228) Currently not used. State of queueing in case of server-full</summary>\n        public const byte QueueState = 228;\n\n        /// <summary>(227) Currently not used. Event for matchmaking</summary>\n        public const byte Match = 227;\n\n        /// <summary>(226) Event with stats about this application (players, rooms, etc)</summary>\n        public const byte AppStats = 226;\n\n        /// <summary>(224) This event provides a list of lobbies with their player and game counts.</summary>\n        public const byte LobbyStats = 224;\n\n        /// <summary>(210) Internally used in case of hosting by Azure</summary>\n        [Obsolete(\"TCP routing was removed after becoming obsolete.\")]\n        public const byte AzureNodeInfo = 210;\n\n        /// <summary>(255) Event Join: someone joined the game. The new actorNumber is provided as well as the properties of that actor (if set in OpJoin).</summary>\n        public const byte Join = (byte)255;\n\n        /// <summary>(254) Event Leave: The player who left the game can be identified by the actorNumber.</summary>\n        public const byte Leave = (byte)254;\n\n        /// <summary>(253) When you call OpSetProperties with the broadcast option \"on\", this event is fired. It contains the properties being set.</summary>\n        public const byte PropertiesChanged = (byte)253;\n\n        /// <summary>(253) When you call OpSetProperties with the broadcast option \"on\", this event is fired. It contains the properties being set.</summary>\n        [Obsolete(\"Use PropertiesChanged now.\")]\n        public const byte SetProperties = (byte)253;\n\n        /// <summary>(252) When player left game unexpected and the room has a playerTtl > 0, this event is fired to let everyone know about the timeout.</summary>\n        /// Obsolete. Replaced by Leave. public const byte Disconnect = LiteEventCode.Disconnect;\n\n        /// <summary>(251) Sent by Photon Cloud when a plugin-call or webhook-call failed. Usually, the execution on the server continues, despite the issue. Contains: ParameterCode.Info.</summary>\n        /// <seealso cref=\"https://doc.photonengine.com/en/realtime/current/reference/webhooks\"/>\n        public const byte ErrorInfo = 251;\n\n        /// <summary>(250) Sent by Photon whent he event cache slice was changed. Done by OpRaiseEvent.</summary>\n        public const byte CacheSliceChanged = 250;\n}\n```\n\n这里的 `EventCode` 你是可以自己定义的，这个 code 是个 **byte 类型的整数**，因此不能大于255，Photon 将从 0 开始的一大段值域都留给开发者用来自定义事件了。Photon 默认提供了 `GameList`，或者说 RoomList 的功能，你可以创建 `Room` 并且加入，`Room` 也有他自己的 Option，可以作为 Lobby，也就是所有人默认进入的 `Room`，当然也可以根据各种条件来查找 `Room`。\n\n这里的 **253 PropertiesChanged** 是一个非常重要的 Event，在上面我提到过，联机游戏的后端最重要的部分之一就是世界状态的同步，在这里也就是**房间的状态 Room Properties**，因此在 Photon SDK 中，当你调用 `client` 对当前加入的 `Room` 的某个属性做出了改变，这就会产生一个事件通知到整个 `Room` 里的所有玩家，这通常用来同步一些全局的属性，例如光线，地形，怪物的血量之类的。\n\n当然，你还可以自定义 Event，在我实现的 demo 中我就是用到了自定义 Event 来告知其他玩家我的状态。比如，整个地图 （可以看做就是一个 `Room`）中的玩家列表和位置是可以用全局状态来同步的，但是例如单个玩家的一些事件（使用物品，使用技能之类的）可能就需要由发起的用户向全 `Room` 的其他玩家发送一个同步事件。\n\n```\nbyte eventCode = 1; \nHashtable evData = new Hashtable (); \nevData.Add (\"player_id\", random_playerid);\nevData.Add (\"pos_x\", position.x);\nevData.Add (\"pos_y\", position.y);\n\nbool sendReliable = true; \nif (isConnected) {\n\tclient.OpRaiseEvent (eventCode, evData, sendReliable, RaiseEventOptions.Default);\n}\n```\n\n> 然后这个事件就会在除了发送者自己的其他玩家的客户端被回调。\n\n**这个时候收到的数据包怎么解出来呢？**\n\n最后再说说坑了我半天的 `EventData` 中的数据抽取，在 `EventData` 中的数据格式十分蛋疼，例如上面这段代码里发送的数据，当你在其他客户端收到的时候，它的数据其实是存在 `EventData` 的 `Parameters` 这个属性变量里面，这是一个 `Dictionary<byte,object>` 类型的对象，通过 `ParameterCode.Data` 这个 key 将 data 取出来之后，里面才是我们传入的 Hashtable ，然而现在已经变成了一个 `Dictionary<object,object>` 对象了。在没有仔细查看源码的情况下，它的官方 demo 和文档并没有提及如何解包 `EventData` ,因此我是通过 Debug 的方式才最终摸清了里面的数据格式。当然后来又看了下它的头文件，才看到 `ParameterCode.Data` 😂。\n\n","source":"_posts/使用-Photon-在-Unity-里快速搭建一个多人联机游戏.md","raw":"title: 使用 Photon 在 Unity 里快速搭建一个多人联机游戏\ndate: 2016-08-18 16:17:02\ncategories: 闲言碎语\n\n\ntags: [Unity, Photon]\n---\n\n如何最快的搭建一个 Unity 上的多人游戏？答案也许是自己搭建一个游戏服务器，也许是 LAN 解决方案，但是最快的解决方案还是使用成熟的第三方后端服务，我找到了 [Photon](https://www.photonengine.com/en-US/Photon)，一个看起来不错最后证实也挺靠谱的游戏后端解决方案。\n\n一个游戏服务器，最主要的就是对不同参与者的事件同步和世界状态的同步，所以根本还是在于和服务器的长连接上，至于游戏中的用户体系，积分体系，货币体系这些，就是属于大后端的范畴了，也是可以独立于游戏同步服务器存在的系统。\n\n### 安装\n\n首先你需要集成 **Photon SDK For Unity**，下载地址在[这里](https://www.photonengine.com/en-US/Realtime/Download)。\n\n![图1](/image/photon_1.png) \n\n你需要将下载下来的 `PhotoAssets` 中的所有文件都拖到你的项目的 `Assets` 文件夹里面，注意在 `Plugins` 里面有两个 `Photon3Unity3D.dll`，需要将 `Metro` 文件夹删掉，保留一个，否则在 Unity 编译的时候会报错。\n\n拖进去之后只要 Unity 中 Compile 没有问题那第一步就大功告成了。\n\n### 脚本创建\n\n创建一个你用来维护游戏网络逻辑的脚本，例如命名为 `GameNetworkClient.cs`，然后你需要在头部加上这几个引用：\n\n```\nusing System.Collections;\nusing ExitGames.Client.Photon;\nusing ExitGames.Client.Photon.LoadBalancing;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Hashtable = ExitGames.Client.Photon.Hashtable;\n```\n\n接着声明一个私有的 `LoadBalancingClient`对象，你的脚本中的所有网络逻辑都会通过这个 `client` 对象来发起和回调。我们这样在 Start 中初始化 `client` 对象：\n\n```\nclient = new LoadBalancingClient();\nclient.AppId = \"{你的 App_id}\";  \nclient.OnStateChangeAction += this.OnStateChanged;\nclient.OnOpResponseAction += this.OnRespAction;\nclient.OnEventAction += this.OnEvent;\n\nclient.ConnectToRegionMaster(\"asia\");\n```\n\n> 你的 App_id 可以在 Photon 官网注册完免费账户后在账户详情页获取，免费的账户拥有 **20** 个同时在线人数的限额，对于小范围好友间的游戏和测试足够了。\n\n其中，最后一行代码就是 `client` 去连接 MasterServer 的方法，这里面传入的参数要根据你的游戏所在地区来确定， Photon 在全球有很多分散的数据中心，因此支持很多区域的连接，具体支持的地区和代码如下：\n\n| Region        | Hosted in  | Token |\n| ------------- | ---------- | ----- |\n| Asia          | Singapore  | asia  |\n| Australia     | Melbourne  | au    |\n| Canada, East  | Montreal   | cae   |\n| Europe        | Amsterdam  | eu    |\n| Japan         | Tokyo      | jp    |\n| South America | Sao Paulo  | sa    |\n| USA, East     | Washington | us    |\n| USA, West     | San José   | usw   |\n\n所以在这里我改成了 `asia`，事实证明新加坡的服务器是比较稳定的。\n\n### 状态维护\n\n`client` 的状态主要就是根据上面初始化的时候给的三个 Action 来维护的，你需要在你的脚本里为这三个 Action 都加上你自己的 Handler。当然，如果你想按照他的 demo 里示范的那样去继承 `client` 并且 override 这三个 Action 的回调都是可以的。\n\n#### OnStateChanged\n\n返回的是一个 `ClientState` 枚举值，主要就是一些 client 状态的值，例如\n\n `connecting`，`connected`，`joining`之类的。\n\n#### OnRespAction\n\n返回的是一个 `OperationResponse` 对象，它会在每次你用 `client` 对象调用一些方法并且获得 response 之后调用，分别有下面这些类型的 Operation:\n\n```\npublic class OperationCode {\n        [Obsolete(\"Exchanging encrpytion keys is done internally in the lib now. Don't expect this operation-result.\")]\n        public const byte ExchangeKeysForEncryption = 250;\n\n        /// <summary>(255) Code for OpJoin, to get into a room.</summary>\n        public const byte Join = 255;\n\n        /// <summary>(230) Authenticates this peer and connects to a virtual application</summary>\n        public const byte Authenticate = 230;\n\n        /// <summary>(229) Joins lobby (on master)</summary>\n        public const byte JoinLobby = 229;\n\n        /// <summary>(228) Leaves lobby (on master)</summary>\n        public const byte LeaveLobby = 228;\n\n        /// <summary>(227) Creates a game (or fails if name exists)</summary>\n        public const byte CreateGame = 227;\n\n        /// <summary>(226) Join game (by name)</summary>\n        public const byte JoinGame = 226;\n\n        /// <summary>(225) Joins random game (on master)</summary>\n        public const byte JoinRandomGame = 225;\n\n        // public const byte CancelJoinRandom = 224; // obsolete, cause JoinRandom no longer is a \"process\". now provides result immediately\n\n        /// <summary>(254) Code for OpLeave, to get out of a room.</summary>\n        public const byte Leave = (byte)254;\n\n        /// <summary>(253) Raise event (in a room, for other actors/players)</summary>\n        public const byte RaiseEvent = (byte)253;\n\n        /// <summary>(252) Set Properties (of room or actor/player)</summary>\n        public const byte SetProperties = (byte)252;\n\n        /// <summary>(251) Get Properties</summary>\n        public const byte GetProperties = (byte)251;\n\n        /// <summary>(248) Operation code to change interest groups in Rooms (Lite application and extending ones).</summary>\n        public const byte ChangeGroups = (byte)248;\n\n        /// <summary>(222) Request the rooms and online status for a list of friends (by name, which should be unique).</summary>\n        public const byte FindFriends = 222;\n\n        /// <summary>(221) Request statistics about a specific list of lobbies (their user and game count).</summary>\n        public const byte GetLobbyStats = 221;\n\n        /// <summary>(220) Get list of regional servers from a NameServer.</summary>\n        public const byte GetRegions = 220;\n\n        /// <summary>(219) WebRpc Operation.</summary>\n        public const byte WebRpc = 219;\n}\n```\n\n可以看到，例如 `rasieEvent`，`setProperties` 或者加入离开游戏这些请求都是会有服务器的 response 的，你可以根据返回对象的 `ReturnCode` 来判断请求是否成功并且是否执行一些错误后的处理，`ReturnCode` 为 0 成功，不为 0 则失败，如果需要也可以从 `DebugMessage` 中获取错误提示信息。\n\n#### **OnEventAction** \n\n返回的是一个 `EventData` 对象，它会在每次 `client` 接收到新的 Event 的时候调用，具体的 Event 类型根据`EventData` 的 `EventCode` 来确定，分别有下面这些类型的 `EventCode`:\n\n```\npublic class EventCode {\n        /// <summary>(230) Initial list of RoomInfos (in lobby on Master)</summary>\n        public const byte GameList = 230;\n\n        /// <summary>(229) Update of RoomInfos to be merged into \"initial\" list (in lobby on Master)</summary>\n        public const byte GameListUpdate = 229;\n\n        /// <summary>(228) Currently not used. State of queueing in case of server-full</summary>\n        public const byte QueueState = 228;\n\n        /// <summary>(227) Currently not used. Event for matchmaking</summary>\n        public const byte Match = 227;\n\n        /// <summary>(226) Event with stats about this application (players, rooms, etc)</summary>\n        public const byte AppStats = 226;\n\n        /// <summary>(224) This event provides a list of lobbies with their player and game counts.</summary>\n        public const byte LobbyStats = 224;\n\n        /// <summary>(210) Internally used in case of hosting by Azure</summary>\n        [Obsolete(\"TCP routing was removed after becoming obsolete.\")]\n        public const byte AzureNodeInfo = 210;\n\n        /// <summary>(255) Event Join: someone joined the game. The new actorNumber is provided as well as the properties of that actor (if set in OpJoin).</summary>\n        public const byte Join = (byte)255;\n\n        /// <summary>(254) Event Leave: The player who left the game can be identified by the actorNumber.</summary>\n        public const byte Leave = (byte)254;\n\n        /// <summary>(253) When you call OpSetProperties with the broadcast option \"on\", this event is fired. It contains the properties being set.</summary>\n        public const byte PropertiesChanged = (byte)253;\n\n        /// <summary>(253) When you call OpSetProperties with the broadcast option \"on\", this event is fired. It contains the properties being set.</summary>\n        [Obsolete(\"Use PropertiesChanged now.\")]\n        public const byte SetProperties = (byte)253;\n\n        /// <summary>(252) When player left game unexpected and the room has a playerTtl > 0, this event is fired to let everyone know about the timeout.</summary>\n        /// Obsolete. Replaced by Leave. public const byte Disconnect = LiteEventCode.Disconnect;\n\n        /// <summary>(251) Sent by Photon Cloud when a plugin-call or webhook-call failed. Usually, the execution on the server continues, despite the issue. Contains: ParameterCode.Info.</summary>\n        /// <seealso cref=\"https://doc.photonengine.com/en/realtime/current/reference/webhooks\"/>\n        public const byte ErrorInfo = 251;\n\n        /// <summary>(250) Sent by Photon whent he event cache slice was changed. Done by OpRaiseEvent.</summary>\n        public const byte CacheSliceChanged = 250;\n}\n```\n\n这里的 `EventCode` 你是可以自己定义的，这个 code 是个 **byte 类型的整数**，因此不能大于255，Photon 将从 0 开始的一大段值域都留给开发者用来自定义事件了。Photon 默认提供了 `GameList`，或者说 RoomList 的功能，你可以创建 `Room` 并且加入，`Room` 也有他自己的 Option，可以作为 Lobby，也就是所有人默认进入的 `Room`，当然也可以根据各种条件来查找 `Room`。\n\n这里的 **253 PropertiesChanged** 是一个非常重要的 Event，在上面我提到过，联机游戏的后端最重要的部分之一就是世界状态的同步，在这里也就是**房间的状态 Room Properties**，因此在 Photon SDK 中，当你调用 `client` 对当前加入的 `Room` 的某个属性做出了改变，这就会产生一个事件通知到整个 `Room` 里的所有玩家，这通常用来同步一些全局的属性，例如光线，地形，怪物的血量之类的。\n\n当然，你还可以自定义 Event，在我实现的 demo 中我就是用到了自定义 Event 来告知其他玩家我的状态。比如，整个地图 （可以看做就是一个 `Room`）中的玩家列表和位置是可以用全局状态来同步的，但是例如单个玩家的一些事件（使用物品，使用技能之类的）可能就需要由发起的用户向全 `Room` 的其他玩家发送一个同步事件。\n\n```\nbyte eventCode = 1; \nHashtable evData = new Hashtable (); \nevData.Add (\"player_id\", random_playerid);\nevData.Add (\"pos_x\", position.x);\nevData.Add (\"pos_y\", position.y);\n\nbool sendReliable = true; \nif (isConnected) {\n\tclient.OpRaiseEvent (eventCode, evData, sendReliable, RaiseEventOptions.Default);\n}\n```\n\n> 然后这个事件就会在除了发送者自己的其他玩家的客户端被回调。\n\n**这个时候收到的数据包怎么解出来呢？**\n\n最后再说说坑了我半天的 `EventData` 中的数据抽取，在 `EventData` 中的数据格式十分蛋疼，例如上面这段代码里发送的数据，当你在其他客户端收到的时候，它的数据其实是存在 `EventData` 的 `Parameters` 这个属性变量里面，这是一个 `Dictionary<byte,object>` 类型的对象，通过 `ParameterCode.Data` 这个 key 将 data 取出来之后，里面才是我们传入的 Hashtable ，然而现在已经变成了一个 `Dictionary<object,object>` 对象了。在没有仔细查看源码的情况下，它的官方 demo 和文档并没有提及如何解包 `EventData` ,因此我是通过 Debug 的方式才最终摸清了里面的数据格式。当然后来又看了下它的头文件，才看到 `ParameterCode.Data` 😂。\n\n","slug":"使用-Photon-在-Unity-里快速搭建一个多人联机游戏","published":1,"updated":"2016-08-24T15:39:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyv5001fj4rb2y7vqgo6"},{"title":"不要想当然的使用UITableView","date":"2016-02-16T08:41:50.000Z","_content":"\n\n## 前言\n\n一直想写一篇UITableView使用经验的干货，因为TableView实在是太万能了，它帮你维护了ContentSize，数据源加载，一些事件的回调还有最重要的是视图的重用，以至于有些项目（什么电商，什么O2O这类的应用）满地都是TableView，所以在一般项目中很容易出现对于TableView的滥用或者是误用。然而由于这种事情仁者见仁，智者见智，因此在一个项目组里，一些错误的风气很容易被持续甚至发扬下去。\n\n我不打算在性能优化方面深入介绍，因为已经有很多关于TableView性能优化的博客了，我可能会稍微提到一些。这篇博客主要是关于整体结构，使用经验这方面的整理，让更多还没踩坑或者正在踩坑的同学们及时醒悟。\n\n## 不要试图过分的去复用一个TableViewController\n\n想想在使用TableViewController或者包含了TableView的Controller的时候，如果遇到了如下的这类场景，我们一般会怎么做？\n\n1. 联系人列表，有两个场景要使用，一个是好友列表，一个是手机联系人列表，甚至还有更多类型的联系人列表。好友列表中需要展示用户信息，例如头像，用户名，性别，等级之类，点击头像可以进入好友的个人主页，点击Cell可以进入聊天页面；而手机联系人列表中需要展示手机号，联系人姓名，头像等信息，需要标识是否可以发送邀请，点击Cell不会响应，点击头像进入发送邀请页面。\n2. 个人主页，样式基本一致，但是有三个场景要使用，分为好友个人主页，非好友个人主页和自己的个人主页。展示的基本信息都一样，例如用户名，姓名，性别，生日，等级这些信息，但是非好友和好友加载的数据源和显示的数据有略微不同，例如好友显示的是姓名，而非好友显示的是用户名。而自己的个人主页展示的数据更多，一些其他用户不可见的信息对自己全部都是可见的。同时好友个人主页可以编辑备注名或者分组，自己的个人主页能修改全部信息和上传头像，且修改要在当前页面直接修改，非好友个人主页可以发送好友请求，或者花费一些金币获取更详细的个人信息。\n\n以上这两个实例场景在基本的带一定社交功能的应用中都会普遍出现。大部分开发者对第一个场景的解决办法都是写在同一个控制器中，当然，这里也和一些产品经理对于需求顺序和需求提前预测的忽视有关。一些情况里都是先实现了好友列表然后才要加入手机联系人列表，这样，在基本结构类似的情况下，为了节约迭代工作成本，在同一个控制器中修改代码无可厚非。我们可以简单的对TableView的数据源进行区分，对TableView的delegate回调进行判断，从而将两套TableView的逻辑写在一个控制器中，实现高聚合。然而，在第一个场景里并不明显的弊端，会在我描述的这个第二个场景里丑恶毕露。在考虑复用TableView的时候，**你需要考虑高聚合的性价比**，如果到了一定规模或者复杂度的时候，高聚合反而会给结构带来破坏，这时候高聚合的性价比非常低，在实际项目中对于产品结构的稳定性和将来的迭代性就会开始不断的产生负面的影响。\n\n在第二个场景下，我见过这些用法：用枚举来标识当前TableView的类型，在所有数据源和Delegate回调的地方加上判断；给TableView加Tag；在Cell中加判断来区分不同的显示和不同的操作响应；甚至用进入个人主页的时候传入的userID来作为不同入口的判断。这些用法听起来虽然是低效一些，但是好像没什么大的问题，因为实际上每次TableView的加载和事件回调都可以被正常响应。然而我想总结的是这么一种习惯问题：当一个控制器被你不断的以这种形式往上加代码，几套逻辑被强制塞到同一个控制器中，这就像那个靠泥土和石头垒了七层楼的哥们一样，当你再视图往上添加一些重要的，新的东西的时候，他可能就全盘崩溃了，甚至让你不知道从何下手。\n\n在实际项目中，你永远想象不到随着需求的增加，这些东西可能被怎么样的复用，而每一次复用，即使是很微小的不同，也是在破坏着代码的拓展性。你看看下面这个TableView是怎么被复用的就会知道了。\n\n```\ntypedef enum {\n    DataSourceTypeAllContacts = 0,          \n    DataSourceTypeAllGroup,                 \n    DataSourceTypeFriendContacts,           \n    DataSourceTypeAddGroupContacts,         \n    DataSourceTypeAllContactsSearch,        \n    DataSourceTypeAllGroupSearch,           \n    DataSourceTypeFriendContactsSearch,     \n    DataSourceTypeAddGroupContactsSearch,   \n}DataSourceType;\n```\n\n这只是一个简单的联系人列表，但是在实际项目中，他被以这种简单低效的形式复用了8次，这就使你的代码变得越来越难以维护，每一次加载都加入了大量的判断，对于团队的其他成员，接手或者在你的代码基础上添加功能都会变得极其蛋疼。\n\n在实际项目开发中，你需要将你的代码**可读性，可维护性，可拓展性**放在首位，而不是想着如何用最少代码去实现一个功能。当然，如果在保证了这三件事情的基础上还能够用最少的代码，那大概就是真大神了。但是对于更大多数的开发者来说，你需要将这三件事情放在第一位。\n\n对于上面的这个复用了8次的TableView来说，还是有可能的优化空间的。例如，当数据源的类型一致，只是获取的方法不同，例如获取群组成员列表和好友列表，TableView的数据源数组中的数据类型是一样的，那么这个时候只要在加载数据的时候做个区分，而不用再TableView加载数据源的时候做区分。这里的意思是，在Cell的结构可以复用的情况下，Cell也可以复用，将TableView的一些复用逻辑转移到Cell中去。当然，如果Cell结构差异很大，或者你需要用xib来定义Cell的布局，那对于Cell的复用就要更加的小心。\n\n当然，说了这么多，还是标题的一句话，**不要试图过分的去复用一个TableViewController**，这是一个好习惯，也会让你的队友们觉得你写的结构很容易看懂。在遇到较为复杂，或在可预见时间范围内有可能出现新的附加需求的功能模块的时候，尽量分开文件写，可以把多个控制器需要共用的部件封装出来，减少重复的代码量。\n\n## 如果我要在同一个控制器中复用TableView呢？\n如果有这么一个需求：\n\n* 在我的个人中心页面中，要根据我的不同用户状态显示几乎完全不同的tableview。有这几种状态，例如注册未填写信息，填写信息未提交审核，正在审核，审核通过，修改信息正在审核，这些状态甚至有可能更多，这时候该怎么办？\n\n在上一小节中的第二个场景中，我们已经将几种逻辑上有区分的个人中心拆分开来了。但是如果遇到同一个控制器中的tableView仍然会出现多种情况的时候，我们无法在上层继续拆分了，否则就会做很多多余的工作。这时候我们可以有以下这么几种解决办法：\n\n1. 根据用户状态的枚举来在tableView的delegate和datasource加上大量的switch来实现入口的区分，这时候我们其实是使用了同一个tableView，并且将多路复用的选择放到了tableView去loadData的时候。这个方法就是最简单也是最笨重的，很多开发者在不考虑持续性的时候很容易走上这条不归路。\n2. 采用一个通用的cellModel，在数据源加载的时候就对多路复用进行了选择，cellModel的属性里有样式的枚举类型，cell的高度，数据对象等等，而且扩展性也还行。但是弊端就在于，虽然这种方法掩盖了第一种方法笨重的外表，但是在cellForRow这些加载过程中，仍然需要对cellModel的属性进行判断。虽然这些操作也是可以被封装出来的，但是仍然很臃肿，特别是同一个控制器的复用场景不断增加的情况下，cellForRow这个方法的可读性仍然很差。\n3. 根据数据源，也就是用户状态来返回不同的tableView，由tableView自己来维护自己的delegate和datasource，这样把所有的加载逻辑写在tableView中，根据情况而定是否要返回一个新的tableView。这样多路复用的选择其实就发生在了返回tableView的操作里，可以避免在控制器中出现臃肿的代码。\n\n> 我不确定第三种方法是否是最佳实践。希望能有一些探讨~\n\n\n\n## 不要试图滥用Cell的重用机制\n\n我知道TableView的重用机制让我们对于性能省了很多心思。然而有时候用的不正确其实会让程序消耗更多的性能。设想这么两个场景，一个是朋友圈的多图Cell，一个是Cell下方的点赞和评论视图，由于你将Cell从重用池中取出的时候，它所已经初始化好的ImageView数量和点赞评论视图和现在将要显示的这个数据源不一致，因此这时候你需要：\n\n1. 还需要多少个ImageView就初始化多少个ImageView，不需要的就释放掉\n2. 点赞或者评论列表由于涉及到布局，可能整体都要重新初始化\n\n在滑动的过程中，视图的重新初始化是十分消耗性能的。尽量不要在layoutSubView中出现init的代码。因此如果你预先定义好10种Identifier，分别对应0到9个图片的情况的数据源，那么在相同数量图片的数据源之间复用的时候，就可以省略掉上面的第一步了。而点赞和评论列表则不可避免的需要重新布局，同样也是要减少初始化的操作。当然，对于Cell滑动的时候初始化的卡顿，我们也可以将点赞和评论的视图放在另外一个线程来绘制，然后再放回主线程来。\n\n另外，Cell的复用和TableView的复用同样也是一个问题。可以说，大部分的复用其实都是用大量的ifelse来完成的。复用不是错误的，但是如果复杂度到了一定水平之后，就要慎重考虑复用的后果而不是每次都无脑的往上添砖加瓦了。\n\n## 一些小Tips?\n\n> 这些我总结出来的经验可能也许大概会和你们已有的一些经验发生冲突，我也希望能和大家有一些探讨。\n\n1. 属于Cell的逻辑最好写在Cell中，避免TableView所在的控制器臃肿冗长而复杂从而降低可维护性，适度聚合，适度耦合应该是最好的。例如Cell中的delegate就放在Cell中去处理，点击Cell中的图片需要跳转也放在Cell中去做，一些ImagePicker之类的控件也由Cell自己处理。控制器只负责数据的加载和外围事件的处理。这样可以控制每一个组件的规模，避免过分臃肿。\n2. Cell的layout全部放在Cell中，在CellForRow中只做重用以及将数据传入Cell，让Cell自身去根据数据来layout，这样可以控制CellForRow这个方法的规模。一些新手很容易将大量的layout代码写在CellForRow中，导致一个方法就要滚好几屏，可读性极差。\n3. 不要到处写reloadData，你的队友们会把你炸了的。可以局部刷新的请用局部刷新。\n4. 复杂结构的Cell尽量不要用autolayout，由于autolayout会有一个视图依赖链，在Cell中更新一个约束会导致一系列视图的更新，当视图结构很复杂的时候，视图更新对性能的消耗就很大了。\n5. 在Cell中对CALayer的一些操作和效果，都会对性能有很大的影响。特别指出的是过多的圆角和阴影。\n6. 更多的可以参考objcio的[这篇文章](https://www.objc.io/issues/1-view-controllers/table-views/)。\n\n## 更多?\n\n我暂时没有想到更多，如果读者有什么要批评吐槽我的就赶紧让我一起涨姿势吧！> 3 <\n","source":"_posts/不要想当然的就使用UITableView.md","raw":"title: 不要想当然的使用UITableView\ndate: 2016-02-16 16:41:50\ncategories: iOS菜鸟心得\ntags: [UITableView]\n---\n\n\n## 前言\n\n一直想写一篇UITableView使用经验的干货，因为TableView实在是太万能了，它帮你维护了ContentSize，数据源加载，一些事件的回调还有最重要的是视图的重用，以至于有些项目（什么电商，什么O2O这类的应用）满地都是TableView，所以在一般项目中很容易出现对于TableView的滥用或者是误用。然而由于这种事情仁者见仁，智者见智，因此在一个项目组里，一些错误的风气很容易被持续甚至发扬下去。\n\n我不打算在性能优化方面深入介绍，因为已经有很多关于TableView性能优化的博客了，我可能会稍微提到一些。这篇博客主要是关于整体结构，使用经验这方面的整理，让更多还没踩坑或者正在踩坑的同学们及时醒悟。\n\n## 不要试图过分的去复用一个TableViewController\n\n想想在使用TableViewController或者包含了TableView的Controller的时候，如果遇到了如下的这类场景，我们一般会怎么做？\n\n1. 联系人列表，有两个场景要使用，一个是好友列表，一个是手机联系人列表，甚至还有更多类型的联系人列表。好友列表中需要展示用户信息，例如头像，用户名，性别，等级之类，点击头像可以进入好友的个人主页，点击Cell可以进入聊天页面；而手机联系人列表中需要展示手机号，联系人姓名，头像等信息，需要标识是否可以发送邀请，点击Cell不会响应，点击头像进入发送邀请页面。\n2. 个人主页，样式基本一致，但是有三个场景要使用，分为好友个人主页，非好友个人主页和自己的个人主页。展示的基本信息都一样，例如用户名，姓名，性别，生日，等级这些信息，但是非好友和好友加载的数据源和显示的数据有略微不同，例如好友显示的是姓名，而非好友显示的是用户名。而自己的个人主页展示的数据更多，一些其他用户不可见的信息对自己全部都是可见的。同时好友个人主页可以编辑备注名或者分组，自己的个人主页能修改全部信息和上传头像，且修改要在当前页面直接修改，非好友个人主页可以发送好友请求，或者花费一些金币获取更详细的个人信息。\n\n以上这两个实例场景在基本的带一定社交功能的应用中都会普遍出现。大部分开发者对第一个场景的解决办法都是写在同一个控制器中，当然，这里也和一些产品经理对于需求顺序和需求提前预测的忽视有关。一些情况里都是先实现了好友列表然后才要加入手机联系人列表，这样，在基本结构类似的情况下，为了节约迭代工作成本，在同一个控制器中修改代码无可厚非。我们可以简单的对TableView的数据源进行区分，对TableView的delegate回调进行判断，从而将两套TableView的逻辑写在一个控制器中，实现高聚合。然而，在第一个场景里并不明显的弊端，会在我描述的这个第二个场景里丑恶毕露。在考虑复用TableView的时候，**你需要考虑高聚合的性价比**，如果到了一定规模或者复杂度的时候，高聚合反而会给结构带来破坏，这时候高聚合的性价比非常低，在实际项目中对于产品结构的稳定性和将来的迭代性就会开始不断的产生负面的影响。\n\n在第二个场景下，我见过这些用法：用枚举来标识当前TableView的类型，在所有数据源和Delegate回调的地方加上判断；给TableView加Tag；在Cell中加判断来区分不同的显示和不同的操作响应；甚至用进入个人主页的时候传入的userID来作为不同入口的判断。这些用法听起来虽然是低效一些，但是好像没什么大的问题，因为实际上每次TableView的加载和事件回调都可以被正常响应。然而我想总结的是这么一种习惯问题：当一个控制器被你不断的以这种形式往上加代码，几套逻辑被强制塞到同一个控制器中，这就像那个靠泥土和石头垒了七层楼的哥们一样，当你再视图往上添加一些重要的，新的东西的时候，他可能就全盘崩溃了，甚至让你不知道从何下手。\n\n在实际项目中，你永远想象不到随着需求的增加，这些东西可能被怎么样的复用，而每一次复用，即使是很微小的不同，也是在破坏着代码的拓展性。你看看下面这个TableView是怎么被复用的就会知道了。\n\n```\ntypedef enum {\n    DataSourceTypeAllContacts = 0,          \n    DataSourceTypeAllGroup,                 \n    DataSourceTypeFriendContacts,           \n    DataSourceTypeAddGroupContacts,         \n    DataSourceTypeAllContactsSearch,        \n    DataSourceTypeAllGroupSearch,           \n    DataSourceTypeFriendContactsSearch,     \n    DataSourceTypeAddGroupContactsSearch,   \n}DataSourceType;\n```\n\n这只是一个简单的联系人列表，但是在实际项目中，他被以这种简单低效的形式复用了8次，这就使你的代码变得越来越难以维护，每一次加载都加入了大量的判断，对于团队的其他成员，接手或者在你的代码基础上添加功能都会变得极其蛋疼。\n\n在实际项目开发中，你需要将你的代码**可读性，可维护性，可拓展性**放在首位，而不是想着如何用最少代码去实现一个功能。当然，如果在保证了这三件事情的基础上还能够用最少的代码，那大概就是真大神了。但是对于更大多数的开发者来说，你需要将这三件事情放在第一位。\n\n对于上面的这个复用了8次的TableView来说，还是有可能的优化空间的。例如，当数据源的类型一致，只是获取的方法不同，例如获取群组成员列表和好友列表，TableView的数据源数组中的数据类型是一样的，那么这个时候只要在加载数据的时候做个区分，而不用再TableView加载数据源的时候做区分。这里的意思是，在Cell的结构可以复用的情况下，Cell也可以复用，将TableView的一些复用逻辑转移到Cell中去。当然，如果Cell结构差异很大，或者你需要用xib来定义Cell的布局，那对于Cell的复用就要更加的小心。\n\n当然，说了这么多，还是标题的一句话，**不要试图过分的去复用一个TableViewController**，这是一个好习惯，也会让你的队友们觉得你写的结构很容易看懂。在遇到较为复杂，或在可预见时间范围内有可能出现新的附加需求的功能模块的时候，尽量分开文件写，可以把多个控制器需要共用的部件封装出来，减少重复的代码量。\n\n## 如果我要在同一个控制器中复用TableView呢？\n如果有这么一个需求：\n\n* 在我的个人中心页面中，要根据我的不同用户状态显示几乎完全不同的tableview。有这几种状态，例如注册未填写信息，填写信息未提交审核，正在审核，审核通过，修改信息正在审核，这些状态甚至有可能更多，这时候该怎么办？\n\n在上一小节中的第二个场景中，我们已经将几种逻辑上有区分的个人中心拆分开来了。但是如果遇到同一个控制器中的tableView仍然会出现多种情况的时候，我们无法在上层继续拆分了，否则就会做很多多余的工作。这时候我们可以有以下这么几种解决办法：\n\n1. 根据用户状态的枚举来在tableView的delegate和datasource加上大量的switch来实现入口的区分，这时候我们其实是使用了同一个tableView，并且将多路复用的选择放到了tableView去loadData的时候。这个方法就是最简单也是最笨重的，很多开发者在不考虑持续性的时候很容易走上这条不归路。\n2. 采用一个通用的cellModel，在数据源加载的时候就对多路复用进行了选择，cellModel的属性里有样式的枚举类型，cell的高度，数据对象等等，而且扩展性也还行。但是弊端就在于，虽然这种方法掩盖了第一种方法笨重的外表，但是在cellForRow这些加载过程中，仍然需要对cellModel的属性进行判断。虽然这些操作也是可以被封装出来的，但是仍然很臃肿，特别是同一个控制器的复用场景不断增加的情况下，cellForRow这个方法的可读性仍然很差。\n3. 根据数据源，也就是用户状态来返回不同的tableView，由tableView自己来维护自己的delegate和datasource，这样把所有的加载逻辑写在tableView中，根据情况而定是否要返回一个新的tableView。这样多路复用的选择其实就发生在了返回tableView的操作里，可以避免在控制器中出现臃肿的代码。\n\n> 我不确定第三种方法是否是最佳实践。希望能有一些探讨~\n\n\n\n## 不要试图滥用Cell的重用机制\n\n我知道TableView的重用机制让我们对于性能省了很多心思。然而有时候用的不正确其实会让程序消耗更多的性能。设想这么两个场景，一个是朋友圈的多图Cell，一个是Cell下方的点赞和评论视图，由于你将Cell从重用池中取出的时候，它所已经初始化好的ImageView数量和点赞评论视图和现在将要显示的这个数据源不一致，因此这时候你需要：\n\n1. 还需要多少个ImageView就初始化多少个ImageView，不需要的就释放掉\n2. 点赞或者评论列表由于涉及到布局，可能整体都要重新初始化\n\n在滑动的过程中，视图的重新初始化是十分消耗性能的。尽量不要在layoutSubView中出现init的代码。因此如果你预先定义好10种Identifier，分别对应0到9个图片的情况的数据源，那么在相同数量图片的数据源之间复用的时候，就可以省略掉上面的第一步了。而点赞和评论列表则不可避免的需要重新布局，同样也是要减少初始化的操作。当然，对于Cell滑动的时候初始化的卡顿，我们也可以将点赞和评论的视图放在另外一个线程来绘制，然后再放回主线程来。\n\n另外，Cell的复用和TableView的复用同样也是一个问题。可以说，大部分的复用其实都是用大量的ifelse来完成的。复用不是错误的，但是如果复杂度到了一定水平之后，就要慎重考虑复用的后果而不是每次都无脑的往上添砖加瓦了。\n\n## 一些小Tips?\n\n> 这些我总结出来的经验可能也许大概会和你们已有的一些经验发生冲突，我也希望能和大家有一些探讨。\n\n1. 属于Cell的逻辑最好写在Cell中，避免TableView所在的控制器臃肿冗长而复杂从而降低可维护性，适度聚合，适度耦合应该是最好的。例如Cell中的delegate就放在Cell中去处理，点击Cell中的图片需要跳转也放在Cell中去做，一些ImagePicker之类的控件也由Cell自己处理。控制器只负责数据的加载和外围事件的处理。这样可以控制每一个组件的规模，避免过分臃肿。\n2. Cell的layout全部放在Cell中，在CellForRow中只做重用以及将数据传入Cell，让Cell自身去根据数据来layout，这样可以控制CellForRow这个方法的规模。一些新手很容易将大量的layout代码写在CellForRow中，导致一个方法就要滚好几屏，可读性极差。\n3. 不要到处写reloadData，你的队友们会把你炸了的。可以局部刷新的请用局部刷新。\n4. 复杂结构的Cell尽量不要用autolayout，由于autolayout会有一个视图依赖链，在Cell中更新一个约束会导致一系列视图的更新，当视图结构很复杂的时候，视图更新对性能的消耗就很大了。\n5. 在Cell中对CALayer的一些操作和效果，都会对性能有很大的影响。特别指出的是过多的圆角和阴影。\n6. 更多的可以参考objcio的[这篇文章](https://www.objc.io/issues/1-view-controllers/table-views/)。\n\n## 更多?\n\n我暂时没有想到更多，如果读者有什么要批评吐槽我的就赶紧让我一起涨姿势吧！> 3 <\n","slug":"不要想当然的就使用UITableView","published":1,"updated":"2016-02-17T06:07:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyva001lj4rbry74bziq"},{"title":"三件小事","date":"2016-01-27T13:36:18.000Z","_content":"\n事情是这样的。  \n江南皮革厂倒闭了。于是最近有这三件小事一直困扰着我。  \n一个是id和NSObject的解释，看过很多博客，但是却一直没有一个深刻的理解，现在醒悟过来觉得大概是看的那些博客本身就讲的含糊不清吧。所以我就用我最直白的语言和解释来说明一下我对于id和NSObject的一些小见解。一开始直接就是跟着代码写的，所以非常的直接。  \n第二个是weak和assign的小事，为什么delegate需要声明weak而不是assign。  \n第三个是关于这个`NS_DESIGNATED_INITIALIZER`宏的解释。\n> 示例工程在[这里](https://github.com/SergioChan/id-NSObjectDemo)。\n\n## id, NSObject 那些事\n\n这里讲的关于id和NSObject的内容，最好打开你的Xcode，打开demo工程，然后就能看到一系列编译的警告。跟着警告往下看你就会对于id和NSObject的区别更加的理解了。\n\n这里你可以看到，test是一个指向UIImage对象的id指针，你可以向他发送length消息。  \n然而如果他不是一个对象指针，而是一个对象，那么你向他发送length消息的话，在编译的时候编译器会无法编译，原因在下面有提到。\n​    \n```\nid test = [[UIImage alloc] init];\n[test length];\n\nNSObject *test1 = [[UIImage alloc]init];\n[test1 length];\n```\n\n这里你可以看到，如果引入了TestObject的头文件，对于任意id类型的对象指针，你就可以向他发送TestObject能够响应的消息了。  \n无论这个id类型指针指向的对象是不是TestObject类型，编译器并不关心这个，也无法知道。  \n然而对于NSObject，他仍然不能响应这个fuck方法，因为向一个对象发送消息的时候，编译器会在对象声明类型的方法表中去判断这个对象是否能够响应这个消息，而不是根据实际分配的对象类型。\n\n```\nid test3 = [[UIImage alloc]init];\n[test3 fuck];\n\nNSObject *test2 = [[TestObject alloc]init];\n[test2 fuck];\n```\n\n所以其实NSObject很少手动声明，如果要声明具体的对象，则最好声明具体的类型，或者id动态类型。  \nid之所以为动态类型，在于它所指向的对象类型是在运行时才确定的，因此使用起来更加的方便。  \nNSObject 只能响应自己的一些简单的方法，例如 copy，hash之类。\n\n```   \n[test2 hash];\n```\n\n下面解释了为什么delegate要用id声明而不是用NSObject\n\n``` \n@property (nonatomic,weak) id<TestDelegate> delegate;\n@property (nonatomic,weak) NSObject<TestDelegate> *delegate;\n```\n\n大部分delegate在实现的时候都需要像下面这个来调用，根据上文所说，因为delegate的方法表其实是运行时才能知道的，在编译时编译器是无法识别的，所以这种调用方式也就不能成立，因此delegate要用第一种id的声明方式来声明：\n\n```\nNSObject *test4 = [[TestObject alloc]init];\nif([test4 respondsToSelector:@selector(fuck)])\n{\n    [test4 fuck];\n}\n\nid test5 = [[TestObject alloc]init];\nif([test5 respondsToSelector:@selector(fuck)])\n{\n    [test5 fuck];\n}\n```\n\n当然如果id所指向的对象在运行时无法响应fuck方法，运行时就会报错。  \n可以这么说吧： **NSObject声明的对象类型在编译时确定，id声明的对象类型在运行时确定**，因此在消息发送上会有一些区别。\n\n## weak, assign 那些事\n这个问题起源于这两种声明delegate的方式：\n\n```\n@property (nonatomic, weak) id  <fuckDelegate> delegate; \n@property (nonatomic, assign) id  <fuckDelegate> delegate; \n```\n\n首先第一种声明方式在我们的日常使用中十分的常见，可能都已经成为一种习惯了。但是例如已经被废弃的 `@property(nonatomic, assign) id< UISearchDisplayDelegate > delegate`，虽然在iOS8之后被废弃，然而它说明delegate也可以用第二种声明方式。\n\n区别就在于weak和assign声明的属性虽然都是不会引起引用计数的增加，但是还是有很大不同。[weak的实现](http://www.cocoachina.com/ios/20150605/11990.html)决定了在属性的主人释放的时候，weak指针所对应的对象也会一起被释放，然而assign不会，因此这里有产生一个野delegate指针的风险。除非是在MRC的环境下，手动对delegate置为nil。这会需要额外的操作，因此后来系统的实现渐渐的也转向weak了。\n\n参考[这里](http://stackoverflow.com/questions/9428500/whats-the-difference-between-weak-and-assign-in-delegate-property-declaratio)。\n\n## NS_DESIGNATED_INITIALIZER\n第一次看到这个的时候，心里想的是 “WTF 这是什么鬼”。\n\n```\n-(instancetype)initWithName:(NSString *)name NS_DESIGNATED_INITIALIZER;\n-(instancetype)init;\n```\n\n这时候看看Swift就明白了 =。= 这是objc为了配合Swift的特性而诞生的一个附加宏。Swift中有designated和convenience两种初始化方法，它要求我们初始化出来的实例对象尽量是属性完整的，即使使用了convenience的初始化方法，也会要求在这个初始化方法中调用同类的designated的初始化方法完成完整的初始化。\n\n像这样：\n\n```\n- (instancetype)init\n{\n    self = [self initWithName:@\"fuck\"];\n    return self;\n}\n\n- (instancetype)initWithName:(NSString *)name\n{\n    self = [super init];\n    return self;\n}\n```\n\n所以这只是一个Swift的特性的objc版本，也是为了更好的和Swift配合开发而加上的。\n\n参考[这里](http://stackoverflow.com/questions/26185239/ios-designated-initializers-using-ns-designated-initializer)。\n","source":"_posts/三件小事.md","raw":"title: 三件小事\ndate: 2016-01-27 21:36:18  \ncategories: iOS菜鸟心得  \ntags: [NSObject, id, weak, assign, NS_DESIGNATED_INITIALIZER]\n---\n\n事情是这样的。  \n江南皮革厂倒闭了。于是最近有这三件小事一直困扰着我。  \n一个是id和NSObject的解释，看过很多博客，但是却一直没有一个深刻的理解，现在醒悟过来觉得大概是看的那些博客本身就讲的含糊不清吧。所以我就用我最直白的语言和解释来说明一下我对于id和NSObject的一些小见解。一开始直接就是跟着代码写的，所以非常的直接。  \n第二个是weak和assign的小事，为什么delegate需要声明weak而不是assign。  \n第三个是关于这个`NS_DESIGNATED_INITIALIZER`宏的解释。\n> 示例工程在[这里](https://github.com/SergioChan/id-NSObjectDemo)。\n\n## id, NSObject 那些事\n\n这里讲的关于id和NSObject的内容，最好打开你的Xcode，打开demo工程，然后就能看到一系列编译的警告。跟着警告往下看你就会对于id和NSObject的区别更加的理解了。\n\n这里你可以看到，test是一个指向UIImage对象的id指针，你可以向他发送length消息。  \n然而如果他不是一个对象指针，而是一个对象，那么你向他发送length消息的话，在编译的时候编译器会无法编译，原因在下面有提到。\n​    \n```\nid test = [[UIImage alloc] init];\n[test length];\n\nNSObject *test1 = [[UIImage alloc]init];\n[test1 length];\n```\n\n这里你可以看到，如果引入了TestObject的头文件，对于任意id类型的对象指针，你就可以向他发送TestObject能够响应的消息了。  \n无论这个id类型指针指向的对象是不是TestObject类型，编译器并不关心这个，也无法知道。  \n然而对于NSObject，他仍然不能响应这个fuck方法，因为向一个对象发送消息的时候，编译器会在对象声明类型的方法表中去判断这个对象是否能够响应这个消息，而不是根据实际分配的对象类型。\n\n```\nid test3 = [[UIImage alloc]init];\n[test3 fuck];\n\nNSObject *test2 = [[TestObject alloc]init];\n[test2 fuck];\n```\n\n所以其实NSObject很少手动声明，如果要声明具体的对象，则最好声明具体的类型，或者id动态类型。  \nid之所以为动态类型，在于它所指向的对象类型是在运行时才确定的，因此使用起来更加的方便。  \nNSObject 只能响应自己的一些简单的方法，例如 copy，hash之类。\n\n```   \n[test2 hash];\n```\n\n下面解释了为什么delegate要用id声明而不是用NSObject\n\n``` \n@property (nonatomic,weak) id<TestDelegate> delegate;\n@property (nonatomic,weak) NSObject<TestDelegate> *delegate;\n```\n\n大部分delegate在实现的时候都需要像下面这个来调用，根据上文所说，因为delegate的方法表其实是运行时才能知道的，在编译时编译器是无法识别的，所以这种调用方式也就不能成立，因此delegate要用第一种id的声明方式来声明：\n\n```\nNSObject *test4 = [[TestObject alloc]init];\nif([test4 respondsToSelector:@selector(fuck)])\n{\n    [test4 fuck];\n}\n\nid test5 = [[TestObject alloc]init];\nif([test5 respondsToSelector:@selector(fuck)])\n{\n    [test5 fuck];\n}\n```\n\n当然如果id所指向的对象在运行时无法响应fuck方法，运行时就会报错。  \n可以这么说吧： **NSObject声明的对象类型在编译时确定，id声明的对象类型在运行时确定**，因此在消息发送上会有一些区别。\n\n## weak, assign 那些事\n这个问题起源于这两种声明delegate的方式：\n\n```\n@property (nonatomic, weak) id  <fuckDelegate> delegate; \n@property (nonatomic, assign) id  <fuckDelegate> delegate; \n```\n\n首先第一种声明方式在我们的日常使用中十分的常见，可能都已经成为一种习惯了。但是例如已经被废弃的 `@property(nonatomic, assign) id< UISearchDisplayDelegate > delegate`，虽然在iOS8之后被废弃，然而它说明delegate也可以用第二种声明方式。\n\n区别就在于weak和assign声明的属性虽然都是不会引起引用计数的增加，但是还是有很大不同。[weak的实现](http://www.cocoachina.com/ios/20150605/11990.html)决定了在属性的主人释放的时候，weak指针所对应的对象也会一起被释放，然而assign不会，因此这里有产生一个野delegate指针的风险。除非是在MRC的环境下，手动对delegate置为nil。这会需要额外的操作，因此后来系统的实现渐渐的也转向weak了。\n\n参考[这里](http://stackoverflow.com/questions/9428500/whats-the-difference-between-weak-and-assign-in-delegate-property-declaratio)。\n\n## NS_DESIGNATED_INITIALIZER\n第一次看到这个的时候，心里想的是 “WTF 这是什么鬼”。\n\n```\n-(instancetype)initWithName:(NSString *)name NS_DESIGNATED_INITIALIZER;\n-(instancetype)init;\n```\n\n这时候看看Swift就明白了 =。= 这是objc为了配合Swift的特性而诞生的一个附加宏。Swift中有designated和convenience两种初始化方法，它要求我们初始化出来的实例对象尽量是属性完整的，即使使用了convenience的初始化方法，也会要求在这个初始化方法中调用同类的designated的初始化方法完成完整的初始化。\n\n像这样：\n\n```\n- (instancetype)init\n{\n    self = [self initWithName:@\"fuck\"];\n    return self;\n}\n\n- (instancetype)initWithName:(NSString *)name\n{\n    self = [super init];\n    return self;\n}\n```\n\n所以这只是一个Swift的特性的objc版本，也是为了更好的和Swift配合开发而加上的。\n\n参考[这里](http://stackoverflow.com/questions/26185239/ios-designated-initializers-using-ns-designated-initializer)。\n","slug":"三件小事","published":1,"updated":"2016-08-25T01:50:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyvg001pj4rb62dyaz9o"},{"title":"“人工智能”邪教","date":"2016-05-28T07:06:50.000Z","_content":"\n\n我觉得现在的不论是全社会还是整个互联网圈，都弥漫着一股对于人工智能的狂热崇拜，就像是一种人工智能邪教一样，深深地蛊惑着每一个圈外人或者是无知者的心智。大家都觉得，人工智能好牛逼啊，人工智能可以比人还聪明，人工智能可以做到一切。Excuse me？作为一个微小的人类你却妄想把自己幻想中的，注意是幻想中的造物主创造出来，Excuse me？这是一些算法能解决的吗？充其量，造出来的不过是深蓝，不过是Alpha Go这种在我看来**只能定义为机器的所谓“智能”**。\n\n> 这里你可以移步[百度百科](http://baike.baidu.com/link?url=EP2EGmEI_HCXGn-iz4sLNr8dtbOsZ-eL_tSmQSk_4GCmdw5yiS-gkmJgSyJtJi5HEKSna62nvccqNG98RL-e1xE-PZBWqT9QAmH00609Ho_)来看看什么是智能：\n> \n> 从感觉到记忆到思维这一过程，称为“智慧”，智慧的结果就产生了行为和语言，将行为和语言的表达过程称为“能力”，两者合称“智能”，将**感觉、记忆、回忆、思维、语言、行为的整个过程称为智能过程**，它是智力和能力的表现。它们分别又可以用“智商”和“能商”来描述其在个体中发挥智能的程度。“情商”可以调整智商和能商的正确发挥，或控制二者恰到好处地发挥它们的作用。\n> \n> 它的定义是：\n> \n> 智能及智能的本质是古今中外许多哲学家、脑科学家一直在努力探索和研究的问题，但至今仍然没有完全了解，以致智能的发生与物质的本质、宇宙的起源、生命的本质一起被列为自然界四大奥秘。\n> \n> 近些年来，随着脑科学、神经心理学等研究的进展，人们对人脑的结构和功能有了初步认识，但对整个神经系统的内部结构和作用机制，特别是脑的功能原理还没有认识清楚，有待进一步的探索。因此，**很难对智能给出确切的定义**。而在仿生和模拟、超级计算机方面也有其特定含义。\n\n\n\n我们先来想想人类和机器所不同的地方在哪，以及我们为什么莫名其妙会产生这种对于人工智能的狂热崇拜。首先，**机器需要规范的输入**，机器只会根据输入去得到输出，对，无论是工厂里的生产机器，亦或是计算机，说白了都是机器，他需要对应的输入来产生输出，因此，当输入不对的时候，机器就炸了。就像你不能把一盘菜端到Alpha Go面前让他尝尝是什么味道一样，所以它充其量就是个机器。那么什么是智能呢？可以这么说，**就目前的人类认知来说，整个宇宙里，唯一具有智能的生物或者是物体，只有人类**。因为**智能包括了很复杂的语言，情感，道德认知体系**，我们可以根据任意的输入，或者进一步说，我们的感官能够接受的全部格式，来理解，转化为我们甚至都不能理解的输入，最后产生输出。这种输入我们现在所能了解到的就是，他可能是一种激素，也可能是一种神经电流，最后的输出也是非常复杂多样化的，具体表现为**行为**，例如我可以现在在电脑上写下这些文字，这就是我的智能的一种输出。正是因为智能的高级，所以才产生了复杂的社会结构和科学体系，正是因为智能，才有了我们，才有了我们存在的意义。\n\n那么，我们接下去理解这件事情。我们其实是在**试图创造一个否定自己存在意义的事物**。这无关造物主不造物主的事情，毕竟造物主只是个比喻，只是说，**我们的存在正是由我们的智能自我定义的**，但是当更高级的智能存在之后，世界会以“他们”的定义而存在，那么我们的存在的意义就不复存在了，这是一种很矛盾的悖论。当然，简易起来理解，就是一些科学家所担心的，既然有了“他们”，那我们就没有存在的必要了，“他们”迟早会把我们从这个世界上抹去。然而这也并不会构成什么实质性的威胁，就像蚂蚁在地球上不也活的好好的 =。= 我这么理解自然是更加的以我们人类自我出发的视角去思考的。\n\n这里我忽然想到前几天和哥们聊到的一个非常有意思的新闻，讲的是俄罗斯还是哪有一个小伙因为大脑里某个运动控制中枢坏掉了，导致了下半身瘫痪还是什么，决定接受换头手术。我记得我也在百度新闻里看到过这个雷人的新闻，还说接受的那颗头来自于中国什么的。在这里我们不去考究新闻的真实性，我们就单纯的来思考，如果有一个人因为大脑的病变导致全身都不听使唤了，这时候他要接受换头手术，假设换了一个健康的头之后他的身体能够被新的头所控制，那么这个行为本身是不是二？**我们的存在不是由我们的身体来定义的**，医学上定义一个人的死亡也是以脑死亡，即意识的活动来判定一个“人”的死亡，所以这下就有趣了，我们忽然发现我们的存在是由我们的大脑来决定的，我们身体上的任何一个部件都可以更换，唯独大脑不能更换，即使你长得和之前一模一样，一旦换了脑袋，你也不存在了。所以我从这联想到了上一段我提到的否定自身存在意义的想法，这是类似的，我们可以更换眼睛，鼻子，身体的各个部位，用机器来代替，但是如果用人工智能来替代了大脑，那你就不存在了，因为**他会以他的存在来定义你的存在**。当然，这里我只是想进一步证明我们的大脑或者说我们的智能才是我们存在的意义，而非肉身。**我们的存在正是因为我们的存在而定义的**，所以这个问题才会没有答案。\n\n回到实际，刨除玄学问题来说，虽然我们对于人工智能的实现有了一定把握，我们通过对大脑运行机制的“猜测”来设计出了神经网络，就像 Alpha Go 所实现的那样，通过不断地深度学习来让智能自我进化。但是，表面上一路坦途，语义理解，语音识别，光学识别，模式识别 blahblah，各种算法都有各种团队在不断的创新，然而，(也可能因为我是个在这方面的悲观主义者)，我认为我们离真正的研究透彻差了十万八千里，甚至我们的方向就不对。我可以随便举几个例子，用光学识别来实现各种面部识别，手势识别，且不说光线的问题，就说干扰源的问题，你怎么解决，我戴上人皮面具，我拿来几个仿真手的模型来混淆你，没有几家公司哪几个算法能做到这种地步的……因为人都会判断错误的东西，你妄想机器能够判断对，也就是说，我们总是觉得，我们一定要造出比自己牛逼的事物，对，没错，但是我们永远造不出识别能力比人类牛逼的事物，为什么？因为我们本身的认知就十分有限，我们受自身条件的限制，只能通过我们有限的感官来感知世界。我会展开解释这一点。当然，这里为了防止被喷，我需要加上一个先提条件，那就是在**有限样本量的情况下，机器算法通过大量训练是可以超过人类的识别能力的**，但是这是在有限样本量的情况下，现实生活中，除非你把世界上每一个人都算进样本里，否则你的算法只要稍微用在一个特征远离你的样本库的人身上，算法识别能力就会远低于人类。\n\n其实当你仔细思考，你就会明白，人类对于人工智能的狂热其实是来自千百年以来人类对于自身各种感官和器官限制的一种恐惧或者说是对于更强的个体的一种追求。当我们发现所谓的进化在几千年里并没有让人们进化出一双火眼金睛，其实现在的人类对于自身的进化速度是十分的怀疑和担忧的。且不论生物学界对于进化论的不断质疑，如果你不承认对于整个种族的怀疑，你会发现几乎全部的围绕人工智能的讨论，都是集中在如何创造一个进化速度是我们人类的几千几万倍的智能。所以说，我们如今所看见和了解的几乎所有人工智能，无一例外都是对于人体一些机能和感官的加强，例如远场识别麦克风，满足了人们千里耳的生理限制；计算机，满足了人脑记忆机制的缺陷和运算能力的缺陷；还有各种红外，高清，全景摄像头，满足了人们视觉上的局限性，能够同时识别更多物体。（虽然在嗅觉和味觉上人类并没有什么不满足的，这是极其有趣的一点，人类反而对这两种感官十分的自得其乐 =。=）这里提到了计算机，我想你应该会承认，人脑的运算速度远没有计算机快，对吧？但那仅仅是局限于计算，人脑的可贵和重要之处在于理解和识别，而这一点正是现在所有的人工智能所欠缺的。几乎所有的看起来名气挺大的人工智能，拉出来，涉及到最核心的人脑中执行理解的这块区域，基本上都是在打哈哈。\n\n\n从Siri，到Cortana，到谷歌前段时间推出的人工智能，再到亚马逊的Echo，他们无一例外都扮演着助理的角色，或者说，在有限的场景下做出有限的反应执行有限的操作，你会很经常的遇到Siri用奇怪的口气告诉你她在互联网上为你查到以下信息，这其实只是一个语音搜索，这只是在弥补人脑对于信息获取途径的缺乏以及信息的存储缺陷。如果有一天你的大脑能够连上互联网，你能够在你的思维里通过搜索引擎去搜索信息，我想，这些“人工智能“就已经可以去吃土了。所以问题的根源是在于我们对于信息获取的途径，在于我们对信息的存储。\n\n除了所谓“快速”的信息获取，如今这些大厂搞出来的人工智能还有一些或多或少方便到人们的功能，对，这些都只能算是功能。例如可以控制智能家居，控制播放器，控制blahblah，给你定闹钟，也有一些格式比较规范的内容他们可以为你梳理，例如音乐，新闻，比赛的实时比分，这些内容在互联网上大多数都是以一些固定的格式存在，因此他可以实时的为你从互联网上去抓取这些信息。然而正是由于功能的固定，和语义理解的局限，目前的，我敢说所有，所有这类人工智能，其实**都相当于一个语音输入的DOS机**，而且这也是我为什么反感过多的炒作人工智能的原因之首。  \n\n\n由于人类的表达方式是没有办法被穷举的，这个先提条件我们必须先达成一致，所以当你只是在用一个有限的指令集去实现这个所谓的智能，或者说在我们可以预见的未来都没有办法摆脱一个大的句式库或者语法库的形式，那么这个指令集其实就是DOS指令一样，是需要用户去学习的。你也许会说，任何交互都有学习成本，只不过现在的交互在不断演进罢了，所以学习成本不应该作为首要考虑的因素。确实，现在的语音助理类软件有非常多，我暂且不称呼他们为人工智能，用户接触他们的时间也已经挺长的了，我们也在慢慢发现我们适应了他们的局限性，我们会按照Siri能听懂的格式告诉他 几点几分给谁谁谁发短信，然后他问你要发送什么，然后你就一个字一个字的把你要发的短信读给她听。这种情况下，当你的所谓智能真正带来了一些方便的时候，用户其实是愿意也自动的会去付出这个学习成本的。但是，第一，这仍然不能称之为智能，第二，我们可能陷入了和DOS时代类似的误区。  \n\n\n我到过一些在中国可以算得上三四线的城市，那么更别说中亚，非洲大片大片的地区了，这些地方的人口，虽然一直在享受着计算机时代带来的红利，但是同时他们也没办法过多的接触计算机。仔细想想，其实在讨论，追求和渴望，甚至去创造人工智能的人群里，基本上大多数人所从事的行业都和计算机相关，或者说日常较为频繁的接触计算机。这类人群确实已经在图形操作系统的时代里完成了进化。但是如果我们放眼整个人类文明，这个进程仍然是非常缓慢的，根本原因一个是在于早先的计算机硬件成本，一个还是在于图形界面操作系统的学习成本仍然存在（你敢说Windows的学习成本低我跟你急，如果你是个学计算机的，你被多少人找你重装过系统了？）。图形操作系统的普及很大意义上就是因为当时的世界上只有极少极少数的极客会将一整张DOS命令表背的滚瓜烂熟轻车熟路然后完全通过指令来控制整个系统，这些人封闭在自己的世界里，认为自己正在创造新世界，认为自己很酷，不可否认，对于开发者来说，命令行是非常方便和高效的一个方法，然而对于消费者，对于Entire Human Species，这无疑是一个封闭，自我的群体。而我认为由于互联网浪潮的兴起，现在的整个社会正有这个趋势，而且由于如今互联网能够在其他行业看来更轻而易举的融资，这个原本是负面的效应反而被钱洗了个脸，成为了一个新的社会生产力。我们封闭的有理，我们酷的有理，因为我们更有钱，而且，更重要的是，技术这个事情，相比于传统行业，更容易白手起家，这对于社会阶层流动等等等等都是有积极作用的（这里如果是经济学家应该能分析出个长篇大论吧），因此种种外界因素作用之下，使得我见过很多代码狂人，整天就是写代码研究算法，并且觉得自己非常屌。**这个社会在助长他们的封闭性。**\n\n可以说，乔布斯热衷于图形操作系统，是希望解放人类的创造力和生产力，然而如今？我们需要新的突破。现在的操作系统，完全可以和Flow一样存在于云端，而客户端，也就是过去意义上的电脑，只有显示的设备和网络连接的设备，以及一个麦克风，它的成本可以做到极低，这在硬件的实现上已经没有了理论障碍。然而在软件层面，这仍然是一个没有解开的坎。\n\n当然，在这里我并不是认为类似Siri，Cortana或者Echo，Rokit之流没有什么意义，相反，他们在这个时代是一个勇敢的先驱者，只不过他们的意义没有那么夸张罢了。我所认为的下一个时代，也就是未来的时代，**现在还没有到来**。可以肯定的是**下一个时代的来临不是光靠一群程序员天天写着什么O2O什么打车软件就可以创造出来的，也不是一群程序员今天写个电商网站明天写个论坛就能创造出来的**，这些都只是商业模式，都只是创造财富的一种手段，做的极少数顶尖的独角兽和巨头也不过就是在或多或少的改变人类生活，却并不足以成为推动人类文明进化的重要力量（Ps. 写完之后校对的时候发现这句话也许有些过激，然而却是真真的反映了当下互联网时代缺乏真正的革命性创新的现状，读者不必太过较真）。所以，程序员们，有些时候不要老是被大家在做什么或者大公司在做什么所蒙蔽了双眼，有些时候冷静下来好好思考一下自己所处的时代，也许你会明白其实我们还有更大的使命去完成，更伟大的事情等着被创造。也许你就会明白，大部分人不过都是在重复别人走过的路，如果可以为整个人类去踩出一条新路，那岂不是此生无憾了？\n\n当我们用代码，算法，想去实现一个所谓的人工智能的时候，其实这和造物主创造我们是一样的过程。我们尚且无法明白人类是如何被创造出来的，我们尚且只能用基因进化论来搪塞，但是不能否认的是，生物学界并无法定义人类的意识是什么时候，什么条件下，具体又是如何产生的。尼安德特人？得了吧。所以我们的基因，我们的造物主为我们写下的基因，其实就和我们现在写的代码一样，都是去定义一个物体，并且教会它各种基本的方法，例如我们人类的肌肉运动，看，听，吃，拉屎，就相当于一个程序里的基本方法加减乘除开方等等。当有了这些之后，基因又继续教会了我们去思考，去学习，去识别，从而诞生了人类，而现在我们教会了我们要创造的这个“事物”去学习，但是还没有人能够真正教会它去思考和识别（当然如果那样一天已经到来了现在的世界可能就面目全非了）。所以我觉得，想要真正的，或者说最正确最合理的去创造一个人工智能的方式，如果你真的想要这么做的话，不是从你的行为出发，也不是从你想要它帮你放一首歌会如何说的话出发，而应该从我们的大脑和基因出发，去理解和反编译我们自己的代码，去明白我们的基因是如何变成控制我们成长，控制我们生老病死七情六欲的代码，这才是让我感觉真正热血沸腾的事情。当然，如果有一天这个技术能够获得突破，那就真的算是人类文明进化的一大步了吧。\n\n\n最后声明：**通篇扯淡，说的都是废话，不要相信，仅博一乐**。","source":"_posts/“人工智能”邪教.md","raw":"title: “人工智能”邪教\ndate: 2016-05-28 15:06:50\ntags: [哲学, 扯淡]\ncategories: 闲言碎语\n---\n\n\n我觉得现在的不论是全社会还是整个互联网圈，都弥漫着一股对于人工智能的狂热崇拜，就像是一种人工智能邪教一样，深深地蛊惑着每一个圈外人或者是无知者的心智。大家都觉得，人工智能好牛逼啊，人工智能可以比人还聪明，人工智能可以做到一切。Excuse me？作为一个微小的人类你却妄想把自己幻想中的，注意是幻想中的造物主创造出来，Excuse me？这是一些算法能解决的吗？充其量，造出来的不过是深蓝，不过是Alpha Go这种在我看来**只能定义为机器的所谓“智能”**。\n\n> 这里你可以移步[百度百科](http://baike.baidu.com/link?url=EP2EGmEI_HCXGn-iz4sLNr8dtbOsZ-eL_tSmQSk_4GCmdw5yiS-gkmJgSyJtJi5HEKSna62nvccqNG98RL-e1xE-PZBWqT9QAmH00609Ho_)来看看什么是智能：\n> \n> 从感觉到记忆到思维这一过程，称为“智慧”，智慧的结果就产生了行为和语言，将行为和语言的表达过程称为“能力”，两者合称“智能”，将**感觉、记忆、回忆、思维、语言、行为的整个过程称为智能过程**，它是智力和能力的表现。它们分别又可以用“智商”和“能商”来描述其在个体中发挥智能的程度。“情商”可以调整智商和能商的正确发挥，或控制二者恰到好处地发挥它们的作用。\n> \n> 它的定义是：\n> \n> 智能及智能的本质是古今中外许多哲学家、脑科学家一直在努力探索和研究的问题，但至今仍然没有完全了解，以致智能的发生与物质的本质、宇宙的起源、生命的本质一起被列为自然界四大奥秘。\n> \n> 近些年来，随着脑科学、神经心理学等研究的进展，人们对人脑的结构和功能有了初步认识，但对整个神经系统的内部结构和作用机制，特别是脑的功能原理还没有认识清楚，有待进一步的探索。因此，**很难对智能给出确切的定义**。而在仿生和模拟、超级计算机方面也有其特定含义。\n\n\n\n我们先来想想人类和机器所不同的地方在哪，以及我们为什么莫名其妙会产生这种对于人工智能的狂热崇拜。首先，**机器需要规范的输入**，机器只会根据输入去得到输出，对，无论是工厂里的生产机器，亦或是计算机，说白了都是机器，他需要对应的输入来产生输出，因此，当输入不对的时候，机器就炸了。就像你不能把一盘菜端到Alpha Go面前让他尝尝是什么味道一样，所以它充其量就是个机器。那么什么是智能呢？可以这么说，**就目前的人类认知来说，整个宇宙里，唯一具有智能的生物或者是物体，只有人类**。因为**智能包括了很复杂的语言，情感，道德认知体系**，我们可以根据任意的输入，或者进一步说，我们的感官能够接受的全部格式，来理解，转化为我们甚至都不能理解的输入，最后产生输出。这种输入我们现在所能了解到的就是，他可能是一种激素，也可能是一种神经电流，最后的输出也是非常复杂多样化的，具体表现为**行为**，例如我可以现在在电脑上写下这些文字，这就是我的智能的一种输出。正是因为智能的高级，所以才产生了复杂的社会结构和科学体系，正是因为智能，才有了我们，才有了我们存在的意义。\n\n那么，我们接下去理解这件事情。我们其实是在**试图创造一个否定自己存在意义的事物**。这无关造物主不造物主的事情，毕竟造物主只是个比喻，只是说，**我们的存在正是由我们的智能自我定义的**，但是当更高级的智能存在之后，世界会以“他们”的定义而存在，那么我们的存在的意义就不复存在了，这是一种很矛盾的悖论。当然，简易起来理解，就是一些科学家所担心的，既然有了“他们”，那我们就没有存在的必要了，“他们”迟早会把我们从这个世界上抹去。然而这也并不会构成什么实质性的威胁，就像蚂蚁在地球上不也活的好好的 =。= 我这么理解自然是更加的以我们人类自我出发的视角去思考的。\n\n这里我忽然想到前几天和哥们聊到的一个非常有意思的新闻，讲的是俄罗斯还是哪有一个小伙因为大脑里某个运动控制中枢坏掉了，导致了下半身瘫痪还是什么，决定接受换头手术。我记得我也在百度新闻里看到过这个雷人的新闻，还说接受的那颗头来自于中国什么的。在这里我们不去考究新闻的真实性，我们就单纯的来思考，如果有一个人因为大脑的病变导致全身都不听使唤了，这时候他要接受换头手术，假设换了一个健康的头之后他的身体能够被新的头所控制，那么这个行为本身是不是二？**我们的存在不是由我们的身体来定义的**，医学上定义一个人的死亡也是以脑死亡，即意识的活动来判定一个“人”的死亡，所以这下就有趣了，我们忽然发现我们的存在是由我们的大脑来决定的，我们身体上的任何一个部件都可以更换，唯独大脑不能更换，即使你长得和之前一模一样，一旦换了脑袋，你也不存在了。所以我从这联想到了上一段我提到的否定自身存在意义的想法，这是类似的，我们可以更换眼睛，鼻子，身体的各个部位，用机器来代替，但是如果用人工智能来替代了大脑，那你就不存在了，因为**他会以他的存在来定义你的存在**。当然，这里我只是想进一步证明我们的大脑或者说我们的智能才是我们存在的意义，而非肉身。**我们的存在正是因为我们的存在而定义的**，所以这个问题才会没有答案。\n\n回到实际，刨除玄学问题来说，虽然我们对于人工智能的实现有了一定把握，我们通过对大脑运行机制的“猜测”来设计出了神经网络，就像 Alpha Go 所实现的那样，通过不断地深度学习来让智能自我进化。但是，表面上一路坦途，语义理解，语音识别，光学识别，模式识别 blahblah，各种算法都有各种团队在不断的创新，然而，(也可能因为我是个在这方面的悲观主义者)，我认为我们离真正的研究透彻差了十万八千里，甚至我们的方向就不对。我可以随便举几个例子，用光学识别来实现各种面部识别，手势识别，且不说光线的问题，就说干扰源的问题，你怎么解决，我戴上人皮面具，我拿来几个仿真手的模型来混淆你，没有几家公司哪几个算法能做到这种地步的……因为人都会判断错误的东西，你妄想机器能够判断对，也就是说，我们总是觉得，我们一定要造出比自己牛逼的事物，对，没错，但是我们永远造不出识别能力比人类牛逼的事物，为什么？因为我们本身的认知就十分有限，我们受自身条件的限制，只能通过我们有限的感官来感知世界。我会展开解释这一点。当然，这里为了防止被喷，我需要加上一个先提条件，那就是在**有限样本量的情况下，机器算法通过大量训练是可以超过人类的识别能力的**，但是这是在有限样本量的情况下，现实生活中，除非你把世界上每一个人都算进样本里，否则你的算法只要稍微用在一个特征远离你的样本库的人身上，算法识别能力就会远低于人类。\n\n其实当你仔细思考，你就会明白，人类对于人工智能的狂热其实是来自千百年以来人类对于自身各种感官和器官限制的一种恐惧或者说是对于更强的个体的一种追求。当我们发现所谓的进化在几千年里并没有让人们进化出一双火眼金睛，其实现在的人类对于自身的进化速度是十分的怀疑和担忧的。且不论生物学界对于进化论的不断质疑，如果你不承认对于整个种族的怀疑，你会发现几乎全部的围绕人工智能的讨论，都是集中在如何创造一个进化速度是我们人类的几千几万倍的智能。所以说，我们如今所看见和了解的几乎所有人工智能，无一例外都是对于人体一些机能和感官的加强，例如远场识别麦克风，满足了人们千里耳的生理限制；计算机，满足了人脑记忆机制的缺陷和运算能力的缺陷；还有各种红外，高清，全景摄像头，满足了人们视觉上的局限性，能够同时识别更多物体。（虽然在嗅觉和味觉上人类并没有什么不满足的，这是极其有趣的一点，人类反而对这两种感官十分的自得其乐 =。=）这里提到了计算机，我想你应该会承认，人脑的运算速度远没有计算机快，对吧？但那仅仅是局限于计算，人脑的可贵和重要之处在于理解和识别，而这一点正是现在所有的人工智能所欠缺的。几乎所有的看起来名气挺大的人工智能，拉出来，涉及到最核心的人脑中执行理解的这块区域，基本上都是在打哈哈。\n\n\n从Siri，到Cortana，到谷歌前段时间推出的人工智能，再到亚马逊的Echo，他们无一例外都扮演着助理的角色，或者说，在有限的场景下做出有限的反应执行有限的操作，你会很经常的遇到Siri用奇怪的口气告诉你她在互联网上为你查到以下信息，这其实只是一个语音搜索，这只是在弥补人脑对于信息获取途径的缺乏以及信息的存储缺陷。如果有一天你的大脑能够连上互联网，你能够在你的思维里通过搜索引擎去搜索信息，我想，这些“人工智能“就已经可以去吃土了。所以问题的根源是在于我们对于信息获取的途径，在于我们对信息的存储。\n\n除了所谓“快速”的信息获取，如今这些大厂搞出来的人工智能还有一些或多或少方便到人们的功能，对，这些都只能算是功能。例如可以控制智能家居，控制播放器，控制blahblah，给你定闹钟，也有一些格式比较规范的内容他们可以为你梳理，例如音乐，新闻，比赛的实时比分，这些内容在互联网上大多数都是以一些固定的格式存在，因此他可以实时的为你从互联网上去抓取这些信息。然而正是由于功能的固定，和语义理解的局限，目前的，我敢说所有，所有这类人工智能，其实**都相当于一个语音输入的DOS机**，而且这也是我为什么反感过多的炒作人工智能的原因之首。  \n\n\n由于人类的表达方式是没有办法被穷举的，这个先提条件我们必须先达成一致，所以当你只是在用一个有限的指令集去实现这个所谓的智能，或者说在我们可以预见的未来都没有办法摆脱一个大的句式库或者语法库的形式，那么这个指令集其实就是DOS指令一样，是需要用户去学习的。你也许会说，任何交互都有学习成本，只不过现在的交互在不断演进罢了，所以学习成本不应该作为首要考虑的因素。确实，现在的语音助理类软件有非常多，我暂且不称呼他们为人工智能，用户接触他们的时间也已经挺长的了，我们也在慢慢发现我们适应了他们的局限性，我们会按照Siri能听懂的格式告诉他 几点几分给谁谁谁发短信，然后他问你要发送什么，然后你就一个字一个字的把你要发的短信读给她听。这种情况下，当你的所谓智能真正带来了一些方便的时候，用户其实是愿意也自动的会去付出这个学习成本的。但是，第一，这仍然不能称之为智能，第二，我们可能陷入了和DOS时代类似的误区。  \n\n\n我到过一些在中国可以算得上三四线的城市，那么更别说中亚，非洲大片大片的地区了，这些地方的人口，虽然一直在享受着计算机时代带来的红利，但是同时他们也没办法过多的接触计算机。仔细想想，其实在讨论，追求和渴望，甚至去创造人工智能的人群里，基本上大多数人所从事的行业都和计算机相关，或者说日常较为频繁的接触计算机。这类人群确实已经在图形操作系统的时代里完成了进化。但是如果我们放眼整个人类文明，这个进程仍然是非常缓慢的，根本原因一个是在于早先的计算机硬件成本，一个还是在于图形界面操作系统的学习成本仍然存在（你敢说Windows的学习成本低我跟你急，如果你是个学计算机的，你被多少人找你重装过系统了？）。图形操作系统的普及很大意义上就是因为当时的世界上只有极少极少数的极客会将一整张DOS命令表背的滚瓜烂熟轻车熟路然后完全通过指令来控制整个系统，这些人封闭在自己的世界里，认为自己正在创造新世界，认为自己很酷，不可否认，对于开发者来说，命令行是非常方便和高效的一个方法，然而对于消费者，对于Entire Human Species，这无疑是一个封闭，自我的群体。而我认为由于互联网浪潮的兴起，现在的整个社会正有这个趋势，而且由于如今互联网能够在其他行业看来更轻而易举的融资，这个原本是负面的效应反而被钱洗了个脸，成为了一个新的社会生产力。我们封闭的有理，我们酷的有理，因为我们更有钱，而且，更重要的是，技术这个事情，相比于传统行业，更容易白手起家，这对于社会阶层流动等等等等都是有积极作用的（这里如果是经济学家应该能分析出个长篇大论吧），因此种种外界因素作用之下，使得我见过很多代码狂人，整天就是写代码研究算法，并且觉得自己非常屌。**这个社会在助长他们的封闭性。**\n\n可以说，乔布斯热衷于图形操作系统，是希望解放人类的创造力和生产力，然而如今？我们需要新的突破。现在的操作系统，完全可以和Flow一样存在于云端，而客户端，也就是过去意义上的电脑，只有显示的设备和网络连接的设备，以及一个麦克风，它的成本可以做到极低，这在硬件的实现上已经没有了理论障碍。然而在软件层面，这仍然是一个没有解开的坎。\n\n当然，在这里我并不是认为类似Siri，Cortana或者Echo，Rokit之流没有什么意义，相反，他们在这个时代是一个勇敢的先驱者，只不过他们的意义没有那么夸张罢了。我所认为的下一个时代，也就是未来的时代，**现在还没有到来**。可以肯定的是**下一个时代的来临不是光靠一群程序员天天写着什么O2O什么打车软件就可以创造出来的，也不是一群程序员今天写个电商网站明天写个论坛就能创造出来的**，这些都只是商业模式，都只是创造财富的一种手段，做的极少数顶尖的独角兽和巨头也不过就是在或多或少的改变人类生活，却并不足以成为推动人类文明进化的重要力量（Ps. 写完之后校对的时候发现这句话也许有些过激，然而却是真真的反映了当下互联网时代缺乏真正的革命性创新的现状，读者不必太过较真）。所以，程序员们，有些时候不要老是被大家在做什么或者大公司在做什么所蒙蔽了双眼，有些时候冷静下来好好思考一下自己所处的时代，也许你会明白其实我们还有更大的使命去完成，更伟大的事情等着被创造。也许你就会明白，大部分人不过都是在重复别人走过的路，如果可以为整个人类去踩出一条新路，那岂不是此生无憾了？\n\n当我们用代码，算法，想去实现一个所谓的人工智能的时候，其实这和造物主创造我们是一样的过程。我们尚且无法明白人类是如何被创造出来的，我们尚且只能用基因进化论来搪塞，但是不能否认的是，生物学界并无法定义人类的意识是什么时候，什么条件下，具体又是如何产生的。尼安德特人？得了吧。所以我们的基因，我们的造物主为我们写下的基因，其实就和我们现在写的代码一样，都是去定义一个物体，并且教会它各种基本的方法，例如我们人类的肌肉运动，看，听，吃，拉屎，就相当于一个程序里的基本方法加减乘除开方等等。当有了这些之后，基因又继续教会了我们去思考，去学习，去识别，从而诞生了人类，而现在我们教会了我们要创造的这个“事物”去学习，但是还没有人能够真正教会它去思考和识别（当然如果那样一天已经到来了现在的世界可能就面目全非了）。所以我觉得，想要真正的，或者说最正确最合理的去创造一个人工智能的方式，如果你真的想要这么做的话，不是从你的行为出发，也不是从你想要它帮你放一首歌会如何说的话出发，而应该从我们的大脑和基因出发，去理解和反编译我们自己的代码，去明白我们的基因是如何变成控制我们成长，控制我们生老病死七情六欲的代码，这才是让我感觉真正热血沸腾的事情。当然，如果有一天这个技术能够获得突破，那就真的算是人类文明进化的一大步了吧。\n\n\n最后声明：**通篇扯淡，说的都是废话，不要相信，仅博一乐**。","slug":"“人工智能”邪教","published":1,"updated":"2016-08-25T01:51:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyvn0021j4rbl5ui23oj"},{"title":"tornado-TCP服务器间内部通讯TCP服务器性能验证","date":"2015-07-19T01:08:40.000Z","_content":"\n> 本文附带项目Github仓库地址，随手star是个好习惯：\n> [https://github.com/SergioChan/tornado-TCP](https://github.com/SergioChan/tornado-TCP)\n\n\n\n# 为什么要有tornado-TCP\n在实际的业务场景中，当一个系统复杂到一定程度后，很多服务都需要被独立地分割出来，部署到独立的服务器上。例如日志服务，图像服务，短信服务和一些数据分析服务这些可能会被许多功能模块共用的且对服务器性能有一定消耗的服务。当功能划分后，各服务器之间就需要通过内部调用连接在一起，通常来说简便的做法就是通过HTTP请求，这样外部和内部访问的服务器都是通用的，对于开发，维护和部署来说是省去了不少功夫。但是，一方面，有一些HTTP Server可能会同时处理内部和外部请求，如果从其他模块发来的内部请求过多，占用了HTTP Server的处理资源，外部客户端的请求可能会因此变慢，因此对于一个想要拥有更高可靠性和稳定性的大型系统来说，将内部调用和外部调用从逻辑上分离开是一个比较好的优化手段。另一方面，虽然在这种场景下HTTP请求的性能不会差到哪里去，在拥有局域网的情况下，这种内部调用的处理速度会相当快，它的连接也会很快的被释放和刷新，但是由于HTTP毕竟是TCP上的应用层，TCP省去了一些HTTP Header的传输和消耗，因此一定意义上采用更低级的TCP来作为内部调用的传输手段，既是一种较为标准和专业化的方法，也是一种更加优化的方法。  \n我们先要理解HTTP连接和TCP连接的区别。首先，HTTP连接是基于TCP连接的。HTTP（HyperText Transport Protocol）是超文本传输协议的缩写。 HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，其中，请求头包含请求的方法、URL、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，响应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。它的最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，客户端会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。这个特点也使得HTTP协议成为了包括移动和web浏览器在内的客户端和服务器端通信的标准途径，因为大部分客户端和服务器的交互都是一次性的，例如一次读和一次写。当每次交互都是原子的时候，在没有特别需求的场景维持长连接对于资源是一种浪费，因此大部分客户端和服务器通信都采用了HTTP协议。虽然现在已经有一些HTTP长连接的实现，但它的机制其实也是基于HTTP协议的，通过类似心跳的模式保持HTTP连接不会被释放。  \nTCP提供一种面向连接的、可靠的字节流服务。面向连接意味着两个使用TCP的应用，通常是一个客户和一个服务器。在彼此交换数据包之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信。在普遍的场景中，TCP长连接常用于客户端推送、即时通信的实现。当然，在很多情况下，TCP也被用来作为服务器内部服务调用的实现。像日志服务这种公用的服务模块，整个系统对它的调用是十分频繁的，因此采用“一次连接”模式的HTTP请求和采用保持连接的TCP请求的区别十分明显，采用TCP会使系统省下大量的资源去重新建立和释放连接。\n\n# 实际结果\n\n对于服务器内部通信采用HTTP协议和TCP协议的性能表现差异，我用对比实验的方式来验证结果。首先，我模拟了传统的HTTP Server的环境，采用了Django作为服务器，并实现了一个基于HTTP协议的内部调用的协议。同时，我将tornado-TCP也部署在相同机器上，在Django上同样实现了一个基于TCP协议的内部调用的协议。然后通过压力测试，得出了以下结果：\n## 每秒并发的流量测试：\n基于HTTP的内部调用的协议请求：  \nUsed 1.00223088264 s for requests, success count is: 289  \n基于TCP的内部调用的协议请求：  \nUsed 1.00016713142 s for requests, success count is: 633  \n\n\n## 一定数量并发请求的处理速度：\n\n基于HTTP的内部调用的协议请求：  \nUsed 47.3748078346 s for 10,000 requests, success count is: 9998  \nUsed 281.623967171 s for 50,000 requests, success count is: 49999  \n基于TCP的内部调用的协议请求：  \nUsed 14.8007540703 s for 10,000 requests, success count is: 9999  \nUsed 123.114969015 s for 50,000 requests, success count is: 49999   \n以上的测试结果均基于相同的Django环境，由于测试的时候使用的是单进程的Django自带的HTTP Server，因此TCP Server也采用了单进程模式。如果切换成多进程模式，采用的原理和tornado相同。也就是说，当基于Django的HTTP Server以单进程模式运行的时候，其处理速度大概是相同条件的tornado-TCP服务器的一半以上。  \n这是这三个服务器的进程情况：\n\n```\n501 68455  1492   0 10:11上午 ??         0:08.05 /usr/bin/python /Users/useruser/tornado-TCP/Server/Manage.py\n501 68465 68433   0 10:12上午 ttys001    0:00.63 /usr/bin/python manage.py runserver 127.0.0.1:9555\n501 68468 68465   0 10:12上午 ttys001    0:08.13 /usr/bin/python manage.py runserver 127.0.0.1:9555\n501 68475 68472   0 10:12上午 ttys002    0:00.43 /usr/bin/python manage.py runserver 127.0.0.1:9556\n501 68478 68475   0 10:12上午 ttys002    0:43.47 /usr/bin/python manage.py runserver 127.0.0.1:9556\n```\n其中9555端口运行的是内部调用的HTTP Server，9556端口运行的是主测试服务器，TCP服务器运行在8889端口上。\n\n# 框架介绍\n\n## tornado-TCP framework\ntornado-TCP的框架可以由以上的架构图来表示。和传统的HTTP Server相比，它相当于是在不同的Server之间建立了一个长连接，而这个连接的主体是一个IOStream，由Connection类来保持监听和字节流的读取。其余模块都是参考传统HTTP Server的架构来添加的。  \n任意其他连接到tornado-TCP的服务器实际上都是一个客户端。每个客户端都需要自己维护一个和tornado-TCP服务器的TCP Socket连接。如果这种内部调用在可预见的范围内十分的频繁，这个连接最好在全局建立和维护，随着服务器的启动初始化。保持IOStream的连接可以使得服务器之间的局域网通信比传统的HTTP请求更快。\n\n## Connection\n\n\nAny other server that was connected to this tornado-TCP server will be represented as a client-server. Each client-server will maintain a TCP connection with tornado-TCP server. If the connection will be used very frequently, it’s better not to close it. Keeping an IOStream for the connection will make the communication in the server-side Local Area Network faster than typical HTTP request.  \nConnection will read the request from IOStream and handle the requests. When a request handling is over, the Connection will automatically read the stream to get the next request. As the source code shown below:\n\n```Python\ndef handle_request(self, data):\n    tmp_body = data[:-1]\n\n    request = Request(address=self._address, Body=tmp_body)\n    handler = urls.Handler_mapping.get(request.cmdid)\n\n    handler_instance = handler()\n\n    if isinstance(handler_instance,BaseHandler):\n        try:\n            handler_instance.process(request=request)\n            self._stream.write(handler_instance.res)\n        except Exception as e:\n            baseLogger.error(e.message)\n\nself.read_request()\n```\n\n## Handler\n\n\nHandler is the class type for processing the request object. You can sub-class your own Handler from BaseHandler to implement custom processing method. This is the sample of TestHandler:\n\n```Python\n@urls.handler(constant.TEST_CMDID)\nclass TestHandler(BaseHandler):\n\n    def process(self,request):\n        if isinstance(request, Request):\n            print request.params\n        else:\n            raise TypeError\n        \n```\n\nNotice the decorator @urls.handler which is used to add mapping between cmdId and Handler. The definition of this decorator is in the urls.py. Each custom Handler should decorated by this decorator.\n\n## Request\n\n\nRequest is the basic object type in the IOStream. Each Request is delimited by a delimiter ‘\\n’.Request is transported in a serialization mode, using normal json type.   \nTo extend Request, define a subclass and there is no need to override anything.\nRequest has following parameters:  \n\n* 1.address: simple ip address combined with port number representing the request origin server.\n* 2.rawBody: raw content of the request body\n* 3.cmdid: command id defines in Command\n* 4.timestamp: the date when request was sent\n* 5.params: a dict that storage all the data it takes\n\n详细介绍和代码请前往[https://github.com/SergioChan/tornado-TCP](https://github.com/SergioChan/tornado-TCP)\n欢迎关注和批评指导！","source":"_posts/tornado-TCP服务器间内部通讯TCP服务器性能验证.md","raw":"title: tornado-TCP服务器间内部通讯TCP服务器性能验证\ndate: 2015-07-19 09:08:40\ncategories: Python学习笔记\ntags: [tornado, TCP]\n---\n\n> 本文附带项目Github仓库地址，随手star是个好习惯：\n> [https://github.com/SergioChan/tornado-TCP](https://github.com/SergioChan/tornado-TCP)\n\n\n\n# 为什么要有tornado-TCP\n在实际的业务场景中，当一个系统复杂到一定程度后，很多服务都需要被独立地分割出来，部署到独立的服务器上。例如日志服务，图像服务，短信服务和一些数据分析服务这些可能会被许多功能模块共用的且对服务器性能有一定消耗的服务。当功能划分后，各服务器之间就需要通过内部调用连接在一起，通常来说简便的做法就是通过HTTP请求，这样外部和内部访问的服务器都是通用的，对于开发，维护和部署来说是省去了不少功夫。但是，一方面，有一些HTTP Server可能会同时处理内部和外部请求，如果从其他模块发来的内部请求过多，占用了HTTP Server的处理资源，外部客户端的请求可能会因此变慢，因此对于一个想要拥有更高可靠性和稳定性的大型系统来说，将内部调用和外部调用从逻辑上分离开是一个比较好的优化手段。另一方面，虽然在这种场景下HTTP请求的性能不会差到哪里去，在拥有局域网的情况下，这种内部调用的处理速度会相当快，它的连接也会很快的被释放和刷新，但是由于HTTP毕竟是TCP上的应用层，TCP省去了一些HTTP Header的传输和消耗，因此一定意义上采用更低级的TCP来作为内部调用的传输手段，既是一种较为标准和专业化的方法，也是一种更加优化的方法。  \n我们先要理解HTTP连接和TCP连接的区别。首先，HTTP连接是基于TCP连接的。HTTP（HyperText Transport Protocol）是超文本传输协议的缩写。 HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，其中，请求头包含请求的方法、URL、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，响应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。它的最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，客户端会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。这个特点也使得HTTP协议成为了包括移动和web浏览器在内的客户端和服务器端通信的标准途径，因为大部分客户端和服务器的交互都是一次性的，例如一次读和一次写。当每次交互都是原子的时候，在没有特别需求的场景维持长连接对于资源是一种浪费，因此大部分客户端和服务器通信都采用了HTTP协议。虽然现在已经有一些HTTP长连接的实现，但它的机制其实也是基于HTTP协议的，通过类似心跳的模式保持HTTP连接不会被释放。  \nTCP提供一种面向连接的、可靠的字节流服务。面向连接意味着两个使用TCP的应用，通常是一个客户和一个服务器。在彼此交换数据包之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信。在普遍的场景中，TCP长连接常用于客户端推送、即时通信的实现。当然，在很多情况下，TCP也被用来作为服务器内部服务调用的实现。像日志服务这种公用的服务模块，整个系统对它的调用是十分频繁的，因此采用“一次连接”模式的HTTP请求和采用保持连接的TCP请求的区别十分明显，采用TCP会使系统省下大量的资源去重新建立和释放连接。\n\n# 实际结果\n\n对于服务器内部通信采用HTTP协议和TCP协议的性能表现差异，我用对比实验的方式来验证结果。首先，我模拟了传统的HTTP Server的环境，采用了Django作为服务器，并实现了一个基于HTTP协议的内部调用的协议。同时，我将tornado-TCP也部署在相同机器上，在Django上同样实现了一个基于TCP协议的内部调用的协议。然后通过压力测试，得出了以下结果：\n## 每秒并发的流量测试：\n基于HTTP的内部调用的协议请求：  \nUsed 1.00223088264 s for requests, success count is: 289  \n基于TCP的内部调用的协议请求：  \nUsed 1.00016713142 s for requests, success count is: 633  \n\n\n## 一定数量并发请求的处理速度：\n\n基于HTTP的内部调用的协议请求：  \nUsed 47.3748078346 s for 10,000 requests, success count is: 9998  \nUsed 281.623967171 s for 50,000 requests, success count is: 49999  \n基于TCP的内部调用的协议请求：  \nUsed 14.8007540703 s for 10,000 requests, success count is: 9999  \nUsed 123.114969015 s for 50,000 requests, success count is: 49999   \n以上的测试结果均基于相同的Django环境，由于测试的时候使用的是单进程的Django自带的HTTP Server，因此TCP Server也采用了单进程模式。如果切换成多进程模式，采用的原理和tornado相同。也就是说，当基于Django的HTTP Server以单进程模式运行的时候，其处理速度大概是相同条件的tornado-TCP服务器的一半以上。  \n这是这三个服务器的进程情况：\n\n```\n501 68455  1492   0 10:11上午 ??         0:08.05 /usr/bin/python /Users/useruser/tornado-TCP/Server/Manage.py\n501 68465 68433   0 10:12上午 ttys001    0:00.63 /usr/bin/python manage.py runserver 127.0.0.1:9555\n501 68468 68465   0 10:12上午 ttys001    0:08.13 /usr/bin/python manage.py runserver 127.0.0.1:9555\n501 68475 68472   0 10:12上午 ttys002    0:00.43 /usr/bin/python manage.py runserver 127.0.0.1:9556\n501 68478 68475   0 10:12上午 ttys002    0:43.47 /usr/bin/python manage.py runserver 127.0.0.1:9556\n```\n其中9555端口运行的是内部调用的HTTP Server，9556端口运行的是主测试服务器，TCP服务器运行在8889端口上。\n\n# 框架介绍\n\n## tornado-TCP framework\ntornado-TCP的框架可以由以上的架构图来表示。和传统的HTTP Server相比，它相当于是在不同的Server之间建立了一个长连接，而这个连接的主体是一个IOStream，由Connection类来保持监听和字节流的读取。其余模块都是参考传统HTTP Server的架构来添加的。  \n任意其他连接到tornado-TCP的服务器实际上都是一个客户端。每个客户端都需要自己维护一个和tornado-TCP服务器的TCP Socket连接。如果这种内部调用在可预见的范围内十分的频繁，这个连接最好在全局建立和维护，随着服务器的启动初始化。保持IOStream的连接可以使得服务器之间的局域网通信比传统的HTTP请求更快。\n\n## Connection\n\n\nAny other server that was connected to this tornado-TCP server will be represented as a client-server. Each client-server will maintain a TCP connection with tornado-TCP server. If the connection will be used very frequently, it’s better not to close it. Keeping an IOStream for the connection will make the communication in the server-side Local Area Network faster than typical HTTP request.  \nConnection will read the request from IOStream and handle the requests. When a request handling is over, the Connection will automatically read the stream to get the next request. As the source code shown below:\n\n```Python\ndef handle_request(self, data):\n    tmp_body = data[:-1]\n\n    request = Request(address=self._address, Body=tmp_body)\n    handler = urls.Handler_mapping.get(request.cmdid)\n\n    handler_instance = handler()\n\n    if isinstance(handler_instance,BaseHandler):\n        try:\n            handler_instance.process(request=request)\n            self._stream.write(handler_instance.res)\n        except Exception as e:\n            baseLogger.error(e.message)\n\nself.read_request()\n```\n\n## Handler\n\n\nHandler is the class type for processing the request object. You can sub-class your own Handler from BaseHandler to implement custom processing method. This is the sample of TestHandler:\n\n```Python\n@urls.handler(constant.TEST_CMDID)\nclass TestHandler(BaseHandler):\n\n    def process(self,request):\n        if isinstance(request, Request):\n            print request.params\n        else:\n            raise TypeError\n        \n```\n\nNotice the decorator @urls.handler which is used to add mapping between cmdId and Handler. The definition of this decorator is in the urls.py. Each custom Handler should decorated by this decorator.\n\n## Request\n\n\nRequest is the basic object type in the IOStream. Each Request is delimited by a delimiter ‘\\n’.Request is transported in a serialization mode, using normal json type.   \nTo extend Request, define a subclass and there is no need to override anything.\nRequest has following parameters:  \n\n* 1.address: simple ip address combined with port number representing the request origin server.\n* 2.rawBody: raw content of the request body\n* 3.cmdid: command id defines in Command\n* 4.timestamp: the date when request was sent\n* 5.params: a dict that storage all the data it takes\n\n详细介绍和代码请前往[https://github.com/SergioChan/tornado-TCP](https://github.com/SergioChan/tornado-TCP)\n欢迎关注和批评指导！","slug":"tornado-TCP服务器间内部通讯TCP服务器性能验证","published":1,"updated":"2015-12-19T01:19:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyvq0027j4rb0168gl3r"},{"title":"runloop初窥","date":"2015-10-22T11:36:23.000Z","author":"Sergio Chan","_content":"\n## 先来说一个很简单的实例\n\n在scrollView中添加一个timer来刷新视图的时候，如果只是简单的声明\n\n\n```\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(timeUpdate:) userInfo:nil repeats:YES];\n```\n\n\n那么当你滑动或者保持你的手指在scrollView上的时候，timer是不会被响应的，这不是因为刷新视图的操作被占用，而是因为当你没有显式声明的时候，你所定义的timer默认都是加在主线程上，并且，当你在对scrollView进行操作的时候，你的timer的事件根本不会被响应到，这就得说到runloop了。而runloop也是底层原理中相当重要的一部分。我们先从它说起。\n\n## 什么是runloop\n\n\nRunloop，顾名思义就是运行的循环。简单理解就是多线程机制中的基础，它能够接收外部事件的输入，并且在有事件的时候保持运行，在没有事件的时候进入休眠。并且它对于线程的消息处理机制进行了很好的封装。\n\n对于线程来说，每一个线程都有一个runloop对象，是否能向某个线程的runloop发送事件取决于你是否启动了这个runloop，系统会默认在你的程序启动的时候运行主线程上的runloop，但是你自定义创建出来的线程可以不需要运行runloop，一些第三方框架，例如AFNetworking，就有在自己的线程上维护一个runloop对象。\n\n在 Core Foundation 里面关于 RunLoop 有5个类:\n\n*     CFRunLoopRef\n*     CFRunLoopModeRef\n*     CFRunLoopSourceRef \n*     CFRunLoopTimerRef \n*     CFRunLoopObserverRef\n\n他们的关系可以从NSRunloop对象的结构定义中得出。首先，runloop对象在Cocoa和Core Foundation中都有实现，但是他们做了很好的桥接，你可以直接调用\n\n```\nCFRunLoopRef runLoopRef = currentThreadRunLoop.getCFRunLoop;\n```\n\n来获取一个CoreFoundation中的runloop对象。然后，当你在查看NSRunloop的结构的时候，你应该能看到：\n\n```\n<CFRunLoop 0x7fd360f5af30 [0x1090a1180]>{wakeup port = 0x4507, stopped = false, ignoreWakeUps = true, \ncurrent mode = (none),\ncommon modes = <CFBasicHash 0x7fd360f5a470 [0x1090a1180]>{type = mutable set, count = 1,\nentries =>\n\t2 : <CFString 0x10907d080 [0x1090a1180]>{contents = \"kCFRunLoopDefaultMode\"}},\ncommon mode items = (null),\nmodes = <CFBasicHash 0x7fd360f5b2b0 [0x1090a1180]>{type = mutable set, count = 1,\nentries =>\n\t2 : <CFRunLoopMode 0x7fd360f5aff0 [0x1090a1180]>{name = kCFRunLoopDefaultMode, port set = 0x4703, timer port = 0x4803, \n\tsources0 = (null),\n\tsources1 = (null),\n\tobservers = <CFArray 0x7fd360f5b1a0 [0x1090a1180]>{type = mutable-small, count = 1, values = (\n\t0 : <CFRunLoopObserver 0x7fd360f5c7f0 [0x1090a1180]>{valid = Yes, activities = 0xfffffff, repeats = Yes, order = 0, callout = currentRunLoopObserver (0x10855b340), context = <CFRunLoopObserver context 0x7fd361213d70>}\n)},\n\ttimers = <CFArray 0x7fd360e020d0 [0x1090a1180]>{type = mutable-small, count = 1, values = (\n\t0 : <CFRunLoopTimer 0x7fd360e01f90 [0x1090a1180]>{valid = Yes, firing = No, interval = 1, tolerance = 0, next fire date = 463742311 (-2.53606331 @ 23607719248079), callout = (NSTimer) [SCCustomThread handleTimerTask] (0x1086416f1 / 0x10855b560) (/Users/useruser/Library/Developer/CoreSimulator/Devices/424D3C6E-8DC0-418B-A2EC-8EDF89507348/data/Containers/Bundle/Application/4D07AF38-9BFC-4617-BAE0-4CB0D7966CC8/runloopTest.app/runloopTest), context = <CFRunLoopTimer context 0x7fd360e01f70>}\n)},\n\tcurrently 463742313 (23610255156065) / soft deadline in: 1.84467441e+10 sec (@ 23607719248079) / hard deadline in: 1.84467441e+10 sec (@ 23607719248079)\n},}}\n```\n\n可以看到一个runloop对象包含各种Mode——currentMode，common mode，modes等等，这里的示例我只指定了一个defaultMode。每个mode对应了source，observers和timers。\n\n> 也许你会注意到 source 包括了source0和source1两个版本。\n> \n> * Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。\n> * Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。\n\nCFRunLoopObserver类型的对象也可以称之为观察者。每个观察者都包含了一个回调，当runloop的状态发生变化时，你可以通过回调来知道当前的状态。\n\n## Mode\n\n![image](https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg)\n\n在你的程序中，runloop的过程实际上是一个无限循环的循环体，这个循环体是由你的程序来运行的。主线程的runloop由于系统已经实现并且没有它程序就不能运行，因此不需要我们手动去运行这个runloop。然而如果我们需要在自定义的线程中使用到runloop，我们则需要用一个do...while循环来驱动它。而runloop对象负责不断地在循环体中运行传进来的事件，然后将事件发给相应的响应。\n\n> 如果你打开你的程序的main.m，你就会发现其实主线程的runloop就是在main函数中进行的，并且系统已经为你生成好了autoreleasepool，因此你也无需操心主线程上的内存释放到底是在什么时候执行了：\n\n```\nint main(int argc, char * argv[]) {\n     @autoreleasepool {\n         return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n     }\n}\n```\n\n根据响应源的不同，runloop也被分成了许多种不同的模式，这就是被Cocoa和Core Foundation都封装了的runloopMode。主要是这么几种：\n\n* NSDefaultRunLoopMode: 大多数工作中默认的运行方式。\n* NSConnectionReplyMode: 使用这个Mode去监听NSConnection对象的状态。\n* NSModalPanelRunLoopMode: 使用这个Mode在Model Panel情况下去区分事件(OS X开发中会遇到)。\n* NSEventTrackingRunLoopMode: 使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动）。\n* NSRunLoopCommonModes: 这是一个伪模式，其为一组run loop mode的集合。如果将Input source加入此模式，意味着关联Input source到Common Modes中包含的所有模式下。在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、NSTaskDeathCheckMode、NSEventTrackingRunLoopMode.可使用CFRunLoopAddCommonMode方法向Common Modes中添加自定义mode。\n\n在文首的情况中，我们可以根据苹果官方文档的定义知道，当你在滑动页面的时候，主线程的runloop自动进入了NSEventTrackingRunLoopMode，而你的timer只是运行在DefaultMode下，所以不能响应。那么最简单的办法就是将你的timer添加在其他的mode下，像这样即可：\n\n```\n[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];\n```\n\n需要注意的是CommonModes其实并不是一种Mode，而是一个集合。因此runloop并不能在CommonModes下运行，相反，你可以将需要输入的事件源添加为这个mode，这样无论runloop运行在哪个mode下都可以响应这个输入事件，否则这个事件将不会得到响应。\n\n## Input Source\n    \n输入源包括三种，端口，自定义输入源和performSelector的消息。根据上面的图我们可以看出，在runloop接收到消息并执行了指定方法的时候，它会执行runUntilDate:这个方法来退出当前循环。\n\n端口源是基于Mach port的，其他进程或线程可以通过端口来发送消息。这里的知识点需要深入到Mach，就已经比较晦涩难懂了……这里你只需要知道你可以用Cocoa封装的NSPort对象来进行线程之间的通信，而这种通信方式所产生的事件就是通过端口源来传入runloop的。关于Mach port的更深层介绍可以看[这篇](http://segmentfault.com/a/1190000002400329)。\n\n自定义输入源。Core Foundation提供了CFRunLoopSourceRef类型的相关函数，可以用来创建自定义输入源。\n\nperformSelector输入源:\n\n```\n//在主线程的Run Loop下执行指定的 @selector 方法\nperformSelectorOnMainThread:withObject:waitUntilDone:\nperformSelectorOnMainThread:withObject:waitUntilDone:modes:\n\n//在当前线程的Run Loop下执行指定的 @selector 方法\nperformSelector:onThread:withObject:waitUntilDone:\nperformSelector:onThread:withObject:waitUntilDone:modes:\n\n//在当前线程的Run Loop下延迟加载指定的 @selector 方法\nperformSelector:withObject:afterDelay:\nperformSelector:withObject:afterDelay:inModes:\n\n//取消当前线程的调用\ncancelPreviousPerformRequestsWithTarget:\ncancelPreviousPerformRequestsWithTarget:selector:object:\n```\n\n## runloop生命周期\n\n每一次runloop其实都是一次循环，runloop会在循环中执行runUntilDate: 或者runMode: beforeDate: 来开始每一个循环。而每一个循环又分为下面几个阶段，也就是runloop的生命周期：\n\n* kCFRunLoopEntry 进入循环\n* kCFRunLoopBeforeTimers 先接收timer的事件\n* kCFRunLoopBeforeSources 接收来自input source的事件\n* kCFRunLoopBeforeWaiting 如果没有事件，则准备进入休眠模式，在这里，如果没有事件传入，runloop会运行直到循环中给定的日期，如果你给的是distantFuture，那么这个runloop会无限等待下去\n* kCFRunLoopAfterWaiting 从休眠中醒来，直接回到kCFRunLoopBeforeTimers状态\n* kCFRunLoopExit 退出循环\n\n这些状态也是一个枚举类型，系统是这么定义的，你可以使用observer来观测到这些状态：\n\n```\n/* Run Loop Observer Activities */\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),\n    kCFRunLoopBeforeTimers = (1UL << 1),\n    kCFRunLoopBeforeSources = (1UL << 2),\n    kCFRunLoopBeforeWaiting = (1UL << 5),\n    kCFRunLoopAfterWaiting = (1UL << 6),\n    kCFRunLoopExit = (1UL << 7),\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n```\n\n我们下面做一个测试，在demo中我们定义了一个新的线程类，这样我们可以自己启动和维护它的runloop对象。\n\n```\n- (void)main\n{\n    @autoreleasepool {\n        NSLog(@\"Thread Enter\");\n        [[NSThread currentThread] setName:@\"This is a test thread\"];\n        NSRunLoop *currentThreadRunLoop = [NSRunLoop currentRunLoop];\n        // 或者\n        // CFRunLoopRef currentThreadRunLoop = CFRunLoopGetCurrent();\n        \n        CFRunLoopObserverContext context = {0, (__bridge void *)(self), NULL, NULL, NULL};\n        CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &currentRunLoopObserver, &context);\n        \n        if (observer) {\n            CFRunLoopRef runLoopRef = currentThreadRunLoop.getCFRunLoop;\n            CFRunLoopAddObserver(runLoopRef, observer, kCFRunLoopDefaultMode);\n        }\n        \n        // 创建一个Timer，重复调用来驱动Run Loop\n        //[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(handleTimerTask) userInfo:nil repeats:YES];\n        do {\n            [currentThreadRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:3]];\n        } while (1);\n    }\n}\n```\n\n输入源或者timer对于runloop来说是必要条件，如果没有添加任何输入源，则runloop根本不会启动，所以上面的代码中添加timer的操作，实际上是添加了一个默认的事件输入源，能让runloop保持运行。但是实际上，当你创建好一个runloop对象后，任何输入的事件都可以触发runloop的启动。\n\n例如下面的：\n\n```\n[self performSelector:@selector(selectorTest) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n```\n\n记住，如果你需要自己来启动和维护runloop的话，核心就在于一个do...while循环，你可以为runloop的跳出设置一个条件，也可以让runloop无限进行下去。在runloop没有接收到事件进入休眠状态之后，如果调用performSelector，runloop的状态变化如下：\n\n```\nCurrent thread Run Loop activity: kCFRunLoopAfterWaiting\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck\nfuck_1\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nCurrent thread Run Loop activity: kCFRunLoopBeforeWaiting\n```\n\n在这里我连续调用了两次performSelector，可以看到runloop也经历了两个循环，而如果只调用一次的话，不会有多出来的那次runloop（你可以自己尝试一下），这是否说明每一次performSelector执行完毕之后都会立即结束当前runloop开始新的，苹果的官方文档里有一句话：\n\n> The run loop processes all queued perform selector calls each time through the loop, rather than processing one during each loop iteration\n\n应该意思是并不是像上面看到的结果那样每一次循环执行一次，而是有一个待执行的操作队列。如果我同时执行四次performSelector，像这样：\n\n\n```\n\t[self performSelector:@selector(selectorTest) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n    [self performSelector:@selector(selectorTest_1) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n    [self performSelector:@selector(selectorTest_2) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n    [self performSelector:@selector(selectorTest_2) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n```\n实际上得到的结果和上面是一样的，然而当我将他们的waitUntilDone参数都设置为YES之后，我们可以看到不一样的地方：\n\n```\nThread Enter\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck_1\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck_2\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck_2\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nCurrent thread Run Loop activity: kCFRunLoopBeforeWaiting\n```\n\n你可以看到每一个performSelector操作都单独执行了一个runloop，从苹果的文档中我们可以找到这个方法的定义：\n\n> * performSelector:onThread:withObject:waitUntilDone:\n> * performSelector:onThread:withObject:waitUntilDone:modes:\n> \n> Performs the specified selector on any thread for which you have an NSThread object. These methods give you the option of blocking the current thread until the selector is performed.\n\n也就是说，waitUntilDone意味着这个操作是否会在当前线程阻塞其他的输入源，如果等于True，则每一次runloop循环只会处理这一个selector的调用，如果为False，则队列中后面等待着的selector调用都会在同一次runloop循环中执行。至于上文的执行了两个runloop循环的现象，我猜测应该是当runloop从休眠模式被唤醒的时候，当前循环执行完唤醒的操作后就会立即结束，释放掉之前可能累积下来的内存，然后开始新的循环，将队列中的其他输入逐个放进runloop循环中执行。\n\n\n","source":"_posts/runloop初窥.md","raw":"title: runloop初窥\ndate: 2015-10-22 19:36:23\ncategories: iOS菜鸟心得\nauthor: Sergio Chan\ntags: [iOS, runloop, NSThread]\n---\n\n## 先来说一个很简单的实例\n\n在scrollView中添加一个timer来刷新视图的时候，如果只是简单的声明\n\n\n```\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(timeUpdate:) userInfo:nil repeats:YES];\n```\n\n\n那么当你滑动或者保持你的手指在scrollView上的时候，timer是不会被响应的，这不是因为刷新视图的操作被占用，而是因为当你没有显式声明的时候，你所定义的timer默认都是加在主线程上，并且，当你在对scrollView进行操作的时候，你的timer的事件根本不会被响应到，这就得说到runloop了。而runloop也是底层原理中相当重要的一部分。我们先从它说起。\n\n## 什么是runloop\n\n\nRunloop，顾名思义就是运行的循环。简单理解就是多线程机制中的基础，它能够接收外部事件的输入，并且在有事件的时候保持运行，在没有事件的时候进入休眠。并且它对于线程的消息处理机制进行了很好的封装。\n\n对于线程来说，每一个线程都有一个runloop对象，是否能向某个线程的runloop发送事件取决于你是否启动了这个runloop，系统会默认在你的程序启动的时候运行主线程上的runloop，但是你自定义创建出来的线程可以不需要运行runloop，一些第三方框架，例如AFNetworking，就有在自己的线程上维护一个runloop对象。\n\n在 Core Foundation 里面关于 RunLoop 有5个类:\n\n*     CFRunLoopRef\n*     CFRunLoopModeRef\n*     CFRunLoopSourceRef \n*     CFRunLoopTimerRef \n*     CFRunLoopObserverRef\n\n他们的关系可以从NSRunloop对象的结构定义中得出。首先，runloop对象在Cocoa和Core Foundation中都有实现，但是他们做了很好的桥接，你可以直接调用\n\n```\nCFRunLoopRef runLoopRef = currentThreadRunLoop.getCFRunLoop;\n```\n\n来获取一个CoreFoundation中的runloop对象。然后，当你在查看NSRunloop的结构的时候，你应该能看到：\n\n```\n<CFRunLoop 0x7fd360f5af30 [0x1090a1180]>{wakeup port = 0x4507, stopped = false, ignoreWakeUps = true, \ncurrent mode = (none),\ncommon modes = <CFBasicHash 0x7fd360f5a470 [0x1090a1180]>{type = mutable set, count = 1,\nentries =>\n\t2 : <CFString 0x10907d080 [0x1090a1180]>{contents = \"kCFRunLoopDefaultMode\"}},\ncommon mode items = (null),\nmodes = <CFBasicHash 0x7fd360f5b2b0 [0x1090a1180]>{type = mutable set, count = 1,\nentries =>\n\t2 : <CFRunLoopMode 0x7fd360f5aff0 [0x1090a1180]>{name = kCFRunLoopDefaultMode, port set = 0x4703, timer port = 0x4803, \n\tsources0 = (null),\n\tsources1 = (null),\n\tobservers = <CFArray 0x7fd360f5b1a0 [0x1090a1180]>{type = mutable-small, count = 1, values = (\n\t0 : <CFRunLoopObserver 0x7fd360f5c7f0 [0x1090a1180]>{valid = Yes, activities = 0xfffffff, repeats = Yes, order = 0, callout = currentRunLoopObserver (0x10855b340), context = <CFRunLoopObserver context 0x7fd361213d70>}\n)},\n\ttimers = <CFArray 0x7fd360e020d0 [0x1090a1180]>{type = mutable-small, count = 1, values = (\n\t0 : <CFRunLoopTimer 0x7fd360e01f90 [0x1090a1180]>{valid = Yes, firing = No, interval = 1, tolerance = 0, next fire date = 463742311 (-2.53606331 @ 23607719248079), callout = (NSTimer) [SCCustomThread handleTimerTask] (0x1086416f1 / 0x10855b560) (/Users/useruser/Library/Developer/CoreSimulator/Devices/424D3C6E-8DC0-418B-A2EC-8EDF89507348/data/Containers/Bundle/Application/4D07AF38-9BFC-4617-BAE0-4CB0D7966CC8/runloopTest.app/runloopTest), context = <CFRunLoopTimer context 0x7fd360e01f70>}\n)},\n\tcurrently 463742313 (23610255156065) / soft deadline in: 1.84467441e+10 sec (@ 23607719248079) / hard deadline in: 1.84467441e+10 sec (@ 23607719248079)\n},}}\n```\n\n可以看到一个runloop对象包含各种Mode——currentMode，common mode，modes等等，这里的示例我只指定了一个defaultMode。每个mode对应了source，observers和timers。\n\n> 也许你会注意到 source 包括了source0和source1两个版本。\n> \n> * Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。\n> * Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。\n\nCFRunLoopObserver类型的对象也可以称之为观察者。每个观察者都包含了一个回调，当runloop的状态发生变化时，你可以通过回调来知道当前的状态。\n\n## Mode\n\n![image](https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg)\n\n在你的程序中，runloop的过程实际上是一个无限循环的循环体，这个循环体是由你的程序来运行的。主线程的runloop由于系统已经实现并且没有它程序就不能运行，因此不需要我们手动去运行这个runloop。然而如果我们需要在自定义的线程中使用到runloop，我们则需要用一个do...while循环来驱动它。而runloop对象负责不断地在循环体中运行传进来的事件，然后将事件发给相应的响应。\n\n> 如果你打开你的程序的main.m，你就会发现其实主线程的runloop就是在main函数中进行的，并且系统已经为你生成好了autoreleasepool，因此你也无需操心主线程上的内存释放到底是在什么时候执行了：\n\n```\nint main(int argc, char * argv[]) {\n     @autoreleasepool {\n         return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n     }\n}\n```\n\n根据响应源的不同，runloop也被分成了许多种不同的模式，这就是被Cocoa和Core Foundation都封装了的runloopMode。主要是这么几种：\n\n* NSDefaultRunLoopMode: 大多数工作中默认的运行方式。\n* NSConnectionReplyMode: 使用这个Mode去监听NSConnection对象的状态。\n* NSModalPanelRunLoopMode: 使用这个Mode在Model Panel情况下去区分事件(OS X开发中会遇到)。\n* NSEventTrackingRunLoopMode: 使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动）。\n* NSRunLoopCommonModes: 这是一个伪模式，其为一组run loop mode的集合。如果将Input source加入此模式，意味着关联Input source到Common Modes中包含的所有模式下。在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、NSTaskDeathCheckMode、NSEventTrackingRunLoopMode.可使用CFRunLoopAddCommonMode方法向Common Modes中添加自定义mode。\n\n在文首的情况中，我们可以根据苹果官方文档的定义知道，当你在滑动页面的时候，主线程的runloop自动进入了NSEventTrackingRunLoopMode，而你的timer只是运行在DefaultMode下，所以不能响应。那么最简单的办法就是将你的timer添加在其他的mode下，像这样即可：\n\n```\n[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];\n```\n\n需要注意的是CommonModes其实并不是一种Mode，而是一个集合。因此runloop并不能在CommonModes下运行，相反，你可以将需要输入的事件源添加为这个mode，这样无论runloop运行在哪个mode下都可以响应这个输入事件，否则这个事件将不会得到响应。\n\n## Input Source\n    \n输入源包括三种，端口，自定义输入源和performSelector的消息。根据上面的图我们可以看出，在runloop接收到消息并执行了指定方法的时候，它会执行runUntilDate:这个方法来退出当前循环。\n\n端口源是基于Mach port的，其他进程或线程可以通过端口来发送消息。这里的知识点需要深入到Mach，就已经比较晦涩难懂了……这里你只需要知道你可以用Cocoa封装的NSPort对象来进行线程之间的通信，而这种通信方式所产生的事件就是通过端口源来传入runloop的。关于Mach port的更深层介绍可以看[这篇](http://segmentfault.com/a/1190000002400329)。\n\n自定义输入源。Core Foundation提供了CFRunLoopSourceRef类型的相关函数，可以用来创建自定义输入源。\n\nperformSelector输入源:\n\n```\n//在主线程的Run Loop下执行指定的 @selector 方法\nperformSelectorOnMainThread:withObject:waitUntilDone:\nperformSelectorOnMainThread:withObject:waitUntilDone:modes:\n\n//在当前线程的Run Loop下执行指定的 @selector 方法\nperformSelector:onThread:withObject:waitUntilDone:\nperformSelector:onThread:withObject:waitUntilDone:modes:\n\n//在当前线程的Run Loop下延迟加载指定的 @selector 方法\nperformSelector:withObject:afterDelay:\nperformSelector:withObject:afterDelay:inModes:\n\n//取消当前线程的调用\ncancelPreviousPerformRequestsWithTarget:\ncancelPreviousPerformRequestsWithTarget:selector:object:\n```\n\n## runloop生命周期\n\n每一次runloop其实都是一次循环，runloop会在循环中执行runUntilDate: 或者runMode: beforeDate: 来开始每一个循环。而每一个循环又分为下面几个阶段，也就是runloop的生命周期：\n\n* kCFRunLoopEntry 进入循环\n* kCFRunLoopBeforeTimers 先接收timer的事件\n* kCFRunLoopBeforeSources 接收来自input source的事件\n* kCFRunLoopBeforeWaiting 如果没有事件，则准备进入休眠模式，在这里，如果没有事件传入，runloop会运行直到循环中给定的日期，如果你给的是distantFuture，那么这个runloop会无限等待下去\n* kCFRunLoopAfterWaiting 从休眠中醒来，直接回到kCFRunLoopBeforeTimers状态\n* kCFRunLoopExit 退出循环\n\n这些状态也是一个枚举类型，系统是这么定义的，你可以使用observer来观测到这些状态：\n\n```\n/* Run Loop Observer Activities */\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),\n    kCFRunLoopBeforeTimers = (1UL << 1),\n    kCFRunLoopBeforeSources = (1UL << 2),\n    kCFRunLoopBeforeWaiting = (1UL << 5),\n    kCFRunLoopAfterWaiting = (1UL << 6),\n    kCFRunLoopExit = (1UL << 7),\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n```\n\n我们下面做一个测试，在demo中我们定义了一个新的线程类，这样我们可以自己启动和维护它的runloop对象。\n\n```\n- (void)main\n{\n    @autoreleasepool {\n        NSLog(@\"Thread Enter\");\n        [[NSThread currentThread] setName:@\"This is a test thread\"];\n        NSRunLoop *currentThreadRunLoop = [NSRunLoop currentRunLoop];\n        // 或者\n        // CFRunLoopRef currentThreadRunLoop = CFRunLoopGetCurrent();\n        \n        CFRunLoopObserverContext context = {0, (__bridge void *)(self), NULL, NULL, NULL};\n        CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &currentRunLoopObserver, &context);\n        \n        if (observer) {\n            CFRunLoopRef runLoopRef = currentThreadRunLoop.getCFRunLoop;\n            CFRunLoopAddObserver(runLoopRef, observer, kCFRunLoopDefaultMode);\n        }\n        \n        // 创建一个Timer，重复调用来驱动Run Loop\n        //[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(handleTimerTask) userInfo:nil repeats:YES];\n        do {\n            [currentThreadRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:3]];\n        } while (1);\n    }\n}\n```\n\n输入源或者timer对于runloop来说是必要条件，如果没有添加任何输入源，则runloop根本不会启动，所以上面的代码中添加timer的操作，实际上是添加了一个默认的事件输入源，能让runloop保持运行。但是实际上，当你创建好一个runloop对象后，任何输入的事件都可以触发runloop的启动。\n\n例如下面的：\n\n```\n[self performSelector:@selector(selectorTest) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n```\n\n记住，如果你需要自己来启动和维护runloop的话，核心就在于一个do...while循环，你可以为runloop的跳出设置一个条件，也可以让runloop无限进行下去。在runloop没有接收到事件进入休眠状态之后，如果调用performSelector，runloop的状态变化如下：\n\n```\nCurrent thread Run Loop activity: kCFRunLoopAfterWaiting\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck\nfuck_1\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nCurrent thread Run Loop activity: kCFRunLoopBeforeWaiting\n```\n\n在这里我连续调用了两次performSelector，可以看到runloop也经历了两个循环，而如果只调用一次的话，不会有多出来的那次runloop（你可以自己尝试一下），这是否说明每一次performSelector执行完毕之后都会立即结束当前runloop开始新的，苹果的官方文档里有一句话：\n\n> The run loop processes all queued perform selector calls each time through the loop, rather than processing one during each loop iteration\n\n应该意思是并不是像上面看到的结果那样每一次循环执行一次，而是有一个待执行的操作队列。如果我同时执行四次performSelector，像这样：\n\n\n```\n\t[self performSelector:@selector(selectorTest) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n    [self performSelector:@selector(selectorTest_1) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n    [self performSelector:@selector(selectorTest_2) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n    [self performSelector:@selector(selectorTest_2) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n```\n实际上得到的结果和上面是一样的，然而当我将他们的waitUntilDone参数都设置为YES之后，我们可以看到不一样的地方：\n\n```\nThread Enter\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck_1\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck_2\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck_2\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nCurrent thread Run Loop activity: kCFRunLoopBeforeWaiting\n```\n\n你可以看到每一个performSelector操作都单独执行了一个runloop，从苹果的文档中我们可以找到这个方法的定义：\n\n> * performSelector:onThread:withObject:waitUntilDone:\n> * performSelector:onThread:withObject:waitUntilDone:modes:\n> \n> Performs the specified selector on any thread for which you have an NSThread object. These methods give you the option of blocking the current thread until the selector is performed.\n\n也就是说，waitUntilDone意味着这个操作是否会在当前线程阻塞其他的输入源，如果等于True，则每一次runloop循环只会处理这一个selector的调用，如果为False，则队列中后面等待着的selector调用都会在同一次runloop循环中执行。至于上文的执行了两个runloop循环的现象，我猜测应该是当runloop从休眠模式被唤醒的时候，当前循环执行完唤醒的操作后就会立即结束，释放掉之前可能累积下来的内存，然后开始新的循环，将队列中的其他输入逐个放进runloop循环中执行。\n\n\n","slug":"runloop初窥","published":1,"updated":"2015-12-18T13:13:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyvx002dj4rbgtof0onr"},{"title":"objective-c_runtime是什么","date":"2015-10-22T11:03:54.000Z","author":"Sergio Chan","_content":"## 当你调用一个方法的时候，发生了什么\n\n在Objective-C里，当你调用一个方法的时候，例如\n\n```\n[foo method];\n```\n\n的时候，实际上编译器会将它转化为这样\n\n```\nobjc_msgSend(foo,selector)\n```\n\n`selector`就是你能够经常用到的那个addTarget中使用到的，它在runtime机制中相当于一个函数的名牌，而IMP则是函数的实现。\n消息机制的关键是编译器是如何处理每一个类和对象的。一般来说，一个类会被编译成这样的结构，一个指向父类的指针，一个类的分派表。这个列表里存的是所有的`selector`和他们对应的方法的地址。没错，每个方法都有一个地址，通过地址来调用方法。而这个地址，就是由函数指针IMP来得到的。\n> 如果你学过编译原理，并且用其他语言自己写过一个编译器的话，你应该了解写一个基础语言调用方法的时候都会有一个全局的方法表，然后调用的过程实际上是去这个方法表中查找对应方法地址的过程。而Objective-C也是类似的，但是由于它是面向对象的，而且又有着这个runtime的特性，也就意味着在Objective-C中的函数调用实际上是在运行时动态的查询当前类和其父类的分派表。\n> 在分派表中，每一个selector都是由SEL对应IMP的形式存储着。我们可以找到SEL的定义\n> \n> \n```\ntypedef struct objc_selector   *SEL;  \n```\n> 所以SEL实际上表示的是方法的签名。在不同的类中如果有相同名称相同参数的方法，则他们的SEL是一样的。但是对应的IMP，也就是函数指针，是在runtime的时候才会动态的去查询然后调用的。\n> IMP的定义则是：\n> \n> \n```\ntypedef id (*IMP)(id, SEL, ...);\n```\n> \n> 我们可以看出，这个被指向的函数包含一个接收消息的对象id, 调用方法的签名 SEL，以及不定个数的方法参数，并返回一个id。也就是说 IMP 是消息最终调用的执行代码，是方法真正的实现代码。对于对象来说，当一个对象被分配空间并初始化之后，对象有一个指向它的类结构，也就是上面提到的这些东西的指针。这就是你所熟悉的`isa`，这样可以通过自身访问到自身的类以及无穷的父类里的方法列表。\n比方说，有一个继承于`NSObject`的foo类，然后又有一个foo1类继承于foo，这时候我们初始化一个foo1的实例对象A，然后调用A的某个方法B，这时候其实也就是向A发了一个消息，要调用B的`selector`。首先会做的是判断接收对象是不是nil，要记住空对象可以接收消息，因为当你向一个空对象发消息的时候，实际上处理的是一个`nil-handler`，而这个handler是啥也不会做的，因此什么也不会发生。\n接下来系统在运行时会先从foo1的分派表中寻找B的`selector`，如果没有，则向foo类找，如果有，则直接调用了，然后直到找到`NSObject`，如果这时候还找不到，那么就会报经典的**‘UnRecognized selector sent to instance’**，如果找到了，那就按照对应的地址找到函数，然后把需要的参数一起传过去。\n\n> 这里有个黑科技，其实也很简单，这个报错和崩溃来源于动态查询函数实现最终失败的调用`doesNotRecognizeSelector`，如果你重写了这个方法，那么对于这个类的对象的错误函数调用就可以避免crash了。但是实际上并没有什么卵用，这反而还掩盖了在消息发送和转发的过程中出现的一些异常。\n当然，系统为了加快这个速度，在上面这一步之前加上了分派表的缓存，秉承着你调用过的函数就有可能再次被调用的原则，你所调用过的函数会被加入到这个缓存表里来。因此，你可以认为当你的应用运行了一会儿之后，这个缓存会变大，然后这时候消息机制也会越变越快。\n最关键的点是在当这个查询最后在分派表中没有找到相应实现的时候，会进行一系列调用。而在这个过程中，我们可以做到动态绑定函数地址，动态重定向实现对象和动态重定向实现的函数地址。函数的地址也就是你常见的`IMP`。\n如果找到函数实现，则不会进入下面的流程。如果没有找到函数的实现，则会先调用`resolveInstanceMethod`这个函数。这个函数是在没有找到函数实现的情况下的第一道补救，这时候你可以通过`class_addMethod`动态添加函数。\n一个Objective-C的函数实际上就是一个简单地带有至少两个参数self和_cmd的C方法体。如官方文档给出的这样结构：\n\n```\nvoid dynamicMethodIMP(id self, SEL _cmd) {\n    // implementation ....\n}\n```\n\n在`resolveInstanceMethod`的时候，你可以这样动态添加一个函数，并且如果当你添加了函数的时候，你需要return YES。\n\n```\n@implementation MyClass\n+ (BOOL)resolveInstanceMethod:(SEL)aSEL\n{   \n    if (aSEL == @selector(resolveThisMethodDynamically)) {\n          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, \"v@:\");\n          return YES;\n    }\n    return [super resolveInstanceMethod:aSEL];}\n@end\n```\n\n这是第一个解决办法，当然，如果你返回了YES，则消息就将被发送到你刚添加的这个IMP去了，也就不会继续下面的消息转发机制了。因此苹果的官方文档就说，动态添加函数是在消息转发机制之前进行的。如果你动态添加了某些函数的实现，但还是希望他们能进入下面的消息转发机制里，你也可以让指定的`selector`返回NO就好了。\n接下去就是消息转发的流程了。\n一进入消息转发机制之后，runtime首先会调用`forwardingTargetForSelector`。这是让你能够指定对象来响应这个方法的地方，返回值是一个id对象，如果返回的是非空且不是自身的时候，runtime会将消息发送给这个对象，试图获得返回。当这一步仍然为空，则会进入下一步的流程。\n在下一步调用`forwardInvocation`之前，会走一个函数调用叫做`- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector`，在这里你可以为没有找到对应IMP的selector添加修改他们的方法签名，这里如果你抛出了一个函数的签名，则会继续传递到下一步中，如果抛出了nil，则你再也不会进到下一步了，在这里就直接报错了。你可以在这里做一些有趣的事情，例如修改一些没有实现的selector签名为一些已知的或者固定格式的，然后再由下面的`forwardInvocation`来提供分发之类的实现。\n当通过了上一步仍然没有函数实现能够响应这条消息的时候，runtime会向对象发送一个 `forwardInvocation：`的消息，并且会把**对函数的调用和附带的参数**封装成一个`NSInvocation`对象传过来。下面设想的是这么一个场景，你希望对A类对象的B方法调用由C类对象的B方法来响应。是的，你可以让A类来继承B类，但是很多情况下这会让情况变得更糟糕，特别是OC并不支持多继承的情况下。这时候就可以用消息转发机制来实现动态绑定啦！当消息不能被正确响应的时候，你需要确定消息将要发送的对象，然后将最开始的调用和参数列表一起发送过去。消息可以用`invokeWithTarget`来发送：\n\n```\n- (void)forwardInvocation:(NSInvocation *)anInvocation\n{\n    if ([someOtherObject respondsToSelector:\n            [anInvocation selector]])\n        [anInvocation invokeWithTarget:someOtherObject];\n    else\n        [super forwardInvocation:anInvocation];\n}\n```\n\n还有，记住每个`NSObject`的子类都继承了这个方法，但是如果你没有手动去重写的话，NSObject里的实现只会马上调用`doesNotRecognizeSelector`，也就是前面经典的报错。因此你需要手动重写它。\n这个方法所获得的返回都会返回给最初调用的发送者，不管他是谁。\n`forwardInvocation`可以作为未知消息的分发器，让他们各自发送到合理的对象那里去，也可以在这里就过滤掉一些可能会出错的返回和错误信息。\n利用消息转发机制我们也可以实现类似多继承的功能。如果A类中不存在B方法，而C类中有B方法，通过消息转发，我们就可以从A类调用B方法，并且通过`forwardInvocation`来分发，我们可以实现类似多继承的功能。但是这两者毕竟还是有区别的，因为多继承是一个可以在一个类中拥有许多父类的方法和属性。但是通过消息转发，我们也只是在消息层面上实现了拥有许多父类方法的能力。\n另外要提的就是，即使你做了消息转发来实现类似多继承的能力，当你调用`respondToSelector`或`isKindOfClass`的时候，他们只会去你自身的继承树里面去寻找`selector`，而并不会去识别你的消息转发机制。\n因此，当你需要为你的超级对象生成一个小的代理对象（surrodate object）的时候，或者你确实需要动态扩展你的类的时候，你需要重写很多方法。\n\n```\n- (BOOL)respondsToSelector:(SEL)aSelector\n{\n    if ( [super respondsToSelector:aSelector] )\n        return YES;\n    else {\n        /* Here, test whether the aSelector message can     *\n         * be forwarded to another object and whether that  *\n         * object can respond to it. Return YES if it can.  */\n    }\n    return NO;\n}\n```\n\n按照官方文档，你总共需要重写下面几个方法，并且都加上你的消息转发机制。\n* `respondsToSelector`\n* `isKindOfClass`\n* `instancesRespondToSelector`\n* `conformsToProtocol`（如果有用到协议）\n* `methodSignatureForSelector`\n\n哎，可是谁又会用得到呢。官方文档最后的小贴士说，这项技术不在走投无路的时候不要用，它不是用来替代继承的。对于我们最多只能是了解并且用到最表层的例如消息转发还有错误的拦截之类，在实际运用中也只对程序运行时的机制有了更好的了解，但是仍然并没有什么卵用。\n","source":"_posts/objective-c-runtime是什么.md","raw":"title: objective-c_runtime是什么\ndate: 2015-10-22 19:03:54\ncategories: iOS菜鸟心得\nauthor: Sergio Chan\ntags: [runtime,Objective-C,objc_msgSend]\n---\n## 当你调用一个方法的时候，发生了什么\n\n在Objective-C里，当你调用一个方法的时候，例如\n\n```\n[foo method];\n```\n\n的时候，实际上编译器会将它转化为这样\n\n```\nobjc_msgSend(foo,selector)\n```\n\n`selector`就是你能够经常用到的那个addTarget中使用到的，它在runtime机制中相当于一个函数的名牌，而IMP则是函数的实现。\n消息机制的关键是编译器是如何处理每一个类和对象的。一般来说，一个类会被编译成这样的结构，一个指向父类的指针，一个类的分派表。这个列表里存的是所有的`selector`和他们对应的方法的地址。没错，每个方法都有一个地址，通过地址来调用方法。而这个地址，就是由函数指针IMP来得到的。\n> 如果你学过编译原理，并且用其他语言自己写过一个编译器的话，你应该了解写一个基础语言调用方法的时候都会有一个全局的方法表，然后调用的过程实际上是去这个方法表中查找对应方法地址的过程。而Objective-C也是类似的，但是由于它是面向对象的，而且又有着这个runtime的特性，也就意味着在Objective-C中的函数调用实际上是在运行时动态的查询当前类和其父类的分派表。\n> 在分派表中，每一个selector都是由SEL对应IMP的形式存储着。我们可以找到SEL的定义\n> \n> \n```\ntypedef struct objc_selector   *SEL;  \n```\n> 所以SEL实际上表示的是方法的签名。在不同的类中如果有相同名称相同参数的方法，则他们的SEL是一样的。但是对应的IMP，也就是函数指针，是在runtime的时候才会动态的去查询然后调用的。\n> IMP的定义则是：\n> \n> \n```\ntypedef id (*IMP)(id, SEL, ...);\n```\n> \n> 我们可以看出，这个被指向的函数包含一个接收消息的对象id, 调用方法的签名 SEL，以及不定个数的方法参数，并返回一个id。也就是说 IMP 是消息最终调用的执行代码，是方法真正的实现代码。对于对象来说，当一个对象被分配空间并初始化之后，对象有一个指向它的类结构，也就是上面提到的这些东西的指针。这就是你所熟悉的`isa`，这样可以通过自身访问到自身的类以及无穷的父类里的方法列表。\n比方说，有一个继承于`NSObject`的foo类，然后又有一个foo1类继承于foo，这时候我们初始化一个foo1的实例对象A，然后调用A的某个方法B，这时候其实也就是向A发了一个消息，要调用B的`selector`。首先会做的是判断接收对象是不是nil，要记住空对象可以接收消息，因为当你向一个空对象发消息的时候，实际上处理的是一个`nil-handler`，而这个handler是啥也不会做的，因此什么也不会发生。\n接下来系统在运行时会先从foo1的分派表中寻找B的`selector`，如果没有，则向foo类找，如果有，则直接调用了，然后直到找到`NSObject`，如果这时候还找不到，那么就会报经典的**‘UnRecognized selector sent to instance’**，如果找到了，那就按照对应的地址找到函数，然后把需要的参数一起传过去。\n\n> 这里有个黑科技，其实也很简单，这个报错和崩溃来源于动态查询函数实现最终失败的调用`doesNotRecognizeSelector`，如果你重写了这个方法，那么对于这个类的对象的错误函数调用就可以避免crash了。但是实际上并没有什么卵用，这反而还掩盖了在消息发送和转发的过程中出现的一些异常。\n当然，系统为了加快这个速度，在上面这一步之前加上了分派表的缓存，秉承着你调用过的函数就有可能再次被调用的原则，你所调用过的函数会被加入到这个缓存表里来。因此，你可以认为当你的应用运行了一会儿之后，这个缓存会变大，然后这时候消息机制也会越变越快。\n最关键的点是在当这个查询最后在分派表中没有找到相应实现的时候，会进行一系列调用。而在这个过程中，我们可以做到动态绑定函数地址，动态重定向实现对象和动态重定向实现的函数地址。函数的地址也就是你常见的`IMP`。\n如果找到函数实现，则不会进入下面的流程。如果没有找到函数的实现，则会先调用`resolveInstanceMethod`这个函数。这个函数是在没有找到函数实现的情况下的第一道补救，这时候你可以通过`class_addMethod`动态添加函数。\n一个Objective-C的函数实际上就是一个简单地带有至少两个参数self和_cmd的C方法体。如官方文档给出的这样结构：\n\n```\nvoid dynamicMethodIMP(id self, SEL _cmd) {\n    // implementation ....\n}\n```\n\n在`resolveInstanceMethod`的时候，你可以这样动态添加一个函数，并且如果当你添加了函数的时候，你需要return YES。\n\n```\n@implementation MyClass\n+ (BOOL)resolveInstanceMethod:(SEL)aSEL\n{   \n    if (aSEL == @selector(resolveThisMethodDynamically)) {\n          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, \"v@:\");\n          return YES;\n    }\n    return [super resolveInstanceMethod:aSEL];}\n@end\n```\n\n这是第一个解决办法，当然，如果你返回了YES，则消息就将被发送到你刚添加的这个IMP去了，也就不会继续下面的消息转发机制了。因此苹果的官方文档就说，动态添加函数是在消息转发机制之前进行的。如果你动态添加了某些函数的实现，但还是希望他们能进入下面的消息转发机制里，你也可以让指定的`selector`返回NO就好了。\n接下去就是消息转发的流程了。\n一进入消息转发机制之后，runtime首先会调用`forwardingTargetForSelector`。这是让你能够指定对象来响应这个方法的地方，返回值是一个id对象，如果返回的是非空且不是自身的时候，runtime会将消息发送给这个对象，试图获得返回。当这一步仍然为空，则会进入下一步的流程。\n在下一步调用`forwardInvocation`之前，会走一个函数调用叫做`- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector`，在这里你可以为没有找到对应IMP的selector添加修改他们的方法签名，这里如果你抛出了一个函数的签名，则会继续传递到下一步中，如果抛出了nil，则你再也不会进到下一步了，在这里就直接报错了。你可以在这里做一些有趣的事情，例如修改一些没有实现的selector签名为一些已知的或者固定格式的，然后再由下面的`forwardInvocation`来提供分发之类的实现。\n当通过了上一步仍然没有函数实现能够响应这条消息的时候，runtime会向对象发送一个 `forwardInvocation：`的消息，并且会把**对函数的调用和附带的参数**封装成一个`NSInvocation`对象传过来。下面设想的是这么一个场景，你希望对A类对象的B方法调用由C类对象的B方法来响应。是的，你可以让A类来继承B类，但是很多情况下这会让情况变得更糟糕，特别是OC并不支持多继承的情况下。这时候就可以用消息转发机制来实现动态绑定啦！当消息不能被正确响应的时候，你需要确定消息将要发送的对象，然后将最开始的调用和参数列表一起发送过去。消息可以用`invokeWithTarget`来发送：\n\n```\n- (void)forwardInvocation:(NSInvocation *)anInvocation\n{\n    if ([someOtherObject respondsToSelector:\n            [anInvocation selector]])\n        [anInvocation invokeWithTarget:someOtherObject];\n    else\n        [super forwardInvocation:anInvocation];\n}\n```\n\n还有，记住每个`NSObject`的子类都继承了这个方法，但是如果你没有手动去重写的话，NSObject里的实现只会马上调用`doesNotRecognizeSelector`，也就是前面经典的报错。因此你需要手动重写它。\n这个方法所获得的返回都会返回给最初调用的发送者，不管他是谁。\n`forwardInvocation`可以作为未知消息的分发器，让他们各自发送到合理的对象那里去，也可以在这里就过滤掉一些可能会出错的返回和错误信息。\n利用消息转发机制我们也可以实现类似多继承的功能。如果A类中不存在B方法，而C类中有B方法，通过消息转发，我们就可以从A类调用B方法，并且通过`forwardInvocation`来分发，我们可以实现类似多继承的功能。但是这两者毕竟还是有区别的，因为多继承是一个可以在一个类中拥有许多父类的方法和属性。但是通过消息转发，我们也只是在消息层面上实现了拥有许多父类方法的能力。\n另外要提的就是，即使你做了消息转发来实现类似多继承的能力，当你调用`respondToSelector`或`isKindOfClass`的时候，他们只会去你自身的继承树里面去寻找`selector`，而并不会去识别你的消息转发机制。\n因此，当你需要为你的超级对象生成一个小的代理对象（surrodate object）的时候，或者你确实需要动态扩展你的类的时候，你需要重写很多方法。\n\n```\n- (BOOL)respondsToSelector:(SEL)aSelector\n{\n    if ( [super respondsToSelector:aSelector] )\n        return YES;\n    else {\n        /* Here, test whether the aSelector message can     *\n         * be forwarded to another object and whether that  *\n         * object can respond to it. Return YES if it can.  */\n    }\n    return NO;\n}\n```\n\n按照官方文档，你总共需要重写下面几个方法，并且都加上你的消息转发机制。\n* `respondsToSelector`\n* `isKindOfClass`\n* `instancesRespondToSelector`\n* `conformsToProtocol`（如果有用到协议）\n* `methodSignatureForSelector`\n\n哎，可是谁又会用得到呢。官方文档最后的小贴士说，这项技术不在走投无路的时候不要用，它不是用来替代继承的。对于我们最多只能是了解并且用到最表层的例如消息转发还有错误的拦截之类，在实际运用中也只对程序运行时的机制有了更好的了解，但是仍然并没有什么卵用。\n","slug":"objective-c-runtime是什么","published":1,"updated":"2015-12-18T13:13:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyw2002lj4rb5ja8dmte"},{"title":"iOS 静态库封装和使用方法","date":"2014-12-10T12:47:54.000Z","author":"Sergio Chan","_content":"\n由于现在的任务是将之前已经进行了第一步demo的验证，我需要将demo里的需要的部分整理出来，封装成静态库，从而给其他开发者使用。iOS封装静态库在百度上已经有很多教程了，但是实际中我却遇到了这样的问题：\n\n* 静态库里的代码需要引用到其他静态库，不是简单的控件封装。\n* 之前的项目大部分引用的文件都只是加在了Library和Header search path中，并没有真正添加在项目中。\n\n第一步，新建一个Framework&Library ->Cocoa Touch Static Library 的工程。\n将我需要的代码文件添加进项目目录下。修改build setting，和之前完整的工程的配置基本一样即可。\n对于引用到的其他静态库，确认它处于Link Binary With Libraries下。\n再确认Library和Header search path指向了正确的头文件或库文件的路径。删除多余的库文件以保证最后的静态库体积最小。\n\n第二步，选择真机环境编译，这里编译的target选的不一样，编译出来的静态库可运行环境就不一样。由于我需要编译的这个功能也只能运行在真机上，所以就直接在真机环境下编译即可。\n\n第三步，编译之前注意选择Build Phase->Copy Files，将之后需要展示出来的头文件添加进去。注意Copy only when installing不要选中。\n\n第四步可以编译了，跑出来的静态库如果没有报错就是可以使用的了。在使用这个静态库的时候也一定要注意所有的头文件和库文件，包括静态库需要指向的头文件，都要在新工程的build setting里设置清楚。实验证明= =如果一个静态库里会用到其他静态库的话，是可以把静态库压的更小的。。。并且引用还是比较好解决的，只要保证各种路径都指向正确。\n","source":"_posts/iOS-静态库封装和使用方法.md","raw":"title: iOS 静态库封装和使用方法\ndate: 2014-12-10 20:47:54\ncategories: iOS菜鸟心得\nauthor: Sergio Chan\ntags: [iOS静态库]\n---\n\n由于现在的任务是将之前已经进行了第一步demo的验证，我需要将demo里的需要的部分整理出来，封装成静态库，从而给其他开发者使用。iOS封装静态库在百度上已经有很多教程了，但是实际中我却遇到了这样的问题：\n\n* 静态库里的代码需要引用到其他静态库，不是简单的控件封装。\n* 之前的项目大部分引用的文件都只是加在了Library和Header search path中，并没有真正添加在项目中。\n\n第一步，新建一个Framework&Library ->Cocoa Touch Static Library 的工程。\n将我需要的代码文件添加进项目目录下。修改build setting，和之前完整的工程的配置基本一样即可。\n对于引用到的其他静态库，确认它处于Link Binary With Libraries下。\n再确认Library和Header search path指向了正确的头文件或库文件的路径。删除多余的库文件以保证最后的静态库体积最小。\n\n第二步，选择真机环境编译，这里编译的target选的不一样，编译出来的静态库可运行环境就不一样。由于我需要编译的这个功能也只能运行在真机上，所以就直接在真机环境下编译即可。\n\n第三步，编译之前注意选择Build Phase->Copy Files，将之后需要展示出来的头文件添加进去。注意Copy only when installing不要选中。\n\n第四步可以编译了，跑出来的静态库如果没有报错就是可以使用的了。在使用这个静态库的时候也一定要注意所有的头文件和库文件，包括静态库需要指向的头文件，都要在新工程的build setting里设置清楚。实验证明= =如果一个静态库里会用到其他静态库的话，是可以把静态库压的更小的。。。并且引用还是比较好解决的，只要保证各种路径都指向正确。\n","slug":"iOS-静态库封装和使用方法","published":1,"updated":"2015-12-18T13:13:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyw6002tj4rbg478us3j"},{"title":"iOS Airplay 中的 Airtunes Server 服务协议和机制详解以及 Android Demo 的实现","date":"2016-08-29T02:03:22.000Z","_content":"\n在 Android 设备上搭建一个 Airplay Server 其实是一件很浩大的工程，因为这需要逆向苹果的 Airplay 协议流程啊格式啊什么的，万幸这件事情已经由许许多多国外的大神们帮我们做好了，因此我们只要基于他们逆向出来的 Airplay 协议来搭建一个服务就可以了。话虽如此，整个过程中的工作量和需要掌握的知识点还是非常非常多的。\n\n在局域网中实现流媒体传输的主流协议有两种，一种是苹果封闭的 Airplay 协议，一种是 DLNA 。\n\n> **D**IGITAL **L**IVING **N**ETWORK **A**LLIANCE 数字生活网络联盟，是索尼、英特尔、微软等发起的一套 PC、移动设备、消费电器之间互联互通的协议。它们的宗旨是“随时随地享受音乐、照片和视频”。据说苹果当时也是 DLNA 联盟的成员，而后来退出了并自立门户。\n\n对于 iOS 系统来说，对用户最友好且体验最好的方式自然还是通过 Airplay 协议了（其实我是不太喜欢在每个单独的视频或者音乐播放器里面去找到 DLNA 或者 Airplay 的按钮然后切换模式，系统级的服务体验还是更好一些，因此我更倾向使用 Airplay）。因此在很多场景下，你需要让你的**安卓硬件**或者**设备**支持 Airplay 服务，本文就是通过一步步解释和分析这个基于 DroidPlay 改出的稳定可用的 Airtunes 服务，给大家展示一个比较清晰的 Airplay 中的 Airtunes 的机制和服务流程。\n\n> 代码在 Git\bHub 上开放给大家学习和改动。地址在[这里](https://github.com/SergioChan/Android-Airplay-Server)。\n\n## 首先，如何让 iOS 设备发现你\n\n这是万事开头的第一步：你需要让自己的安卓设备出现在 iOS 设备 Airplay 的设备列表中。由于 Airplay 是基于局域网的，苹果设备会在当前局域网里搜寻支持 Airplay 服务的设备，因此在这里你就需要通过 mDNS 服务向局域网发送一个组播来让 iOS 设备能够在内网中发现你。在 Android 上你可以使用 **jmDNS** 库来实现这个功能:\n\n```\nfinal JmDNS jmDNS = JmDNS.create(addr, hostName + \"-jmdns\");\njmDNSInstances.add(jmDNS);\n\n/* Publish RAOP service */\nfinal ServiceInfo airTunesServiceInfo = ServiceInfo.create(\nAIR_TUNES_SERVICE_TYPE,\nhardwareAddressString + \"@\" + hostName,\ngetRtspPort(),\n0 /* weight */, 0 /* priority */,\nAIRTUNES_SERVICE_PROPERTIES\n);\njmDNS.registerService(airTunesServiceInfo);\n```\n\n这个注册的服务类型和参数都是固定的，服务类型为 `_raop._tcp.local.`，参数列表如下:\n\n```\n\"txtvers\", \"1\",\n\"tp\", \"UDP\",\n\"ch\", \"2\",\n\"ss\", \"16\",\n\"sr\", \"44100\",\n\"pw\", \"false\",\n\"sm\", \"false\",\n\"sv\", \"false\",\n\"ek\", \"1\",\n\"et\", \"0,1\",\n\"cn\", \"0,1\",\n\"vn\", \"3\"\n```\n\n通过注册上这个 mDNS 服务，现在你应该可以在你的 iOS 设备上的 Airplay 列表里看到一个名字为你设置的 `hostName` 的设备了。当然，现在点击连接应该是没有任何反应的，因为接下来需要进行好几次的  RTSP 请求来进行校验和连接，我们要做的也主要就是接下来这几个步骤了。\n\n> **Airplay 连接一开始的延迟貌似是没有办法解决的**。参考这篇[SO回答](http://stackoverflow.com/questions/9997882/detecting-the-airplay-latency)，里面明确指出，Airplay 连接的延迟来源于发送方需要多次 RTSP 请求握手，大概在**两秒左右**，当然，如果你在客户端层面去做自己的传输协议当然是没有问题的，但是你并不能按照 Airplay 的包格式来实现系统级的 Airplay 到其他不论是原生的 iOS 设备还是支持了 Airplay 的 Android 设备上去，这会被苹果 Reject。所以如果在之后的开发中最后遇到了一点几秒的延迟没法解决的时候，记住不要钻进坑里了。实际测试中延迟大概在 1.6 秒左右。\n\n## 开启你的服务端\n\n告知了 iOS 设备你的端口信息之后，接下来就是在指定的端口开启你的服务端等候 iOS 设备传来的包了。在这里我们使用的是 Netty 库的 bootstrap 来搭建一个服务器，关于 Netty 你可以在百度和谷歌上找到更多介绍。总之它的机制是每一个新的 TCP 连接都会建立一个子的 channel 然后每一个 channel 的处理都是一个 pipeline 的处理模式，接收到消息的时候消息会在 pipeline 中流动，直到不再往下流动，发送消息反之亦然。\n\n苹果的 Airplay 协议主要是通过 RTSP 协议的 Header 中的几个参数来进行身份的验证和包的校验，所以为了满足苹果自己需要的校验规则，我们需要在 pipeline 中加上这几个处理校验的 Handler：\n\n```\npipeline.addLast(\"challengeResponse\", new RaopRtspChallengeResponseHandler(NetworkUtils.getInstance().getHardwareAddress()));\npipeline.addLast(\"header\", new RaopRtspHeaderHandler());\npipeline.addLast(\"options\", new RaopRtspOptionsHandler());\n```\n\n其中：\n\n- 由 iOS 设备向 Android 设备发送的 Request 的 Header 中 （注意这里你的 Android 是作为服务端的）包含一个叫做 `Apple-Challenge` 的字段，它的值需要经过 Base64 解密之后获得一个凭证，这个凭证是要在每一次的 Response 中使用到的。\n- 由 Android 设备向 iOS 设备发送的 Response 的 Header 中需要包含一个叫做 `Apple-Response` 的字段，它的值需要经过一层 RSA 加密和一层 Base64 加密，原始数据则是 16 位 `Apple-Challenge` 解密后的凭证 + 16位 InetAddress.getAddress() 获取到的 byte 数组 + 6 位 硬件地址。分别是从 Request 中，`InetAddress.getAddress()` 和下面这段代码中的 `NetworkInterface` 来获得硬件地址。带有 `Apple-Challenge` Header 的包只会在 RTSP 连接建立的时候发送一次，因此稍微判断一下是否需要返回 `Apple-Response` 的 Header 就可以了。另外，在这里的 RSA 加密中用到的秘钥是一个私钥，也就是双方提前约定好的一个串，这个串会不定期的更新，破解的事情应该只有少数大神才做的了吧……对于我们主要还是从国外的一些博客和网站上经常去关注是否有私钥更新比较靠谱。这个私钥在所有的 RSA 解密操作中都要用到。\n\n```\nfor(final NetworkInterface iface: Collections.list(NetworkInterface.getNetworkInterfaces())) {\nif (iface.isLoopback()){\ncontinue;\n}\nif (iface.isPointToPoint()){\ncontinue;\n}\n\ntry {\nfinal byte[] ifaceMacAddress = iface.getHardwareAddress();\nif ((ifaceMacAddress != null) && (ifaceMacAddress.length == 6) && !isBlockedHardwareAddress(ifaceMacAddress)) {\nreturn Arrays.copyOfRange(ifaceMacAddress, 0, 6);\n}\n}\ncatch (final Throwable e) {\n/* Ignore */\n}\n}\n```\n\n- 对于 RTSP Header 的处理，每个 RTSP 包都会带有 `CSeq` 的头，这个头需要在 Response 和 Request 中保持一致。它指定了 RTSP 请求回应对的序列号，在每个请求或回应中都必须包括这个头字段。对每个包含一个给定序列号的请求消息，都会有一个相同序列号的回应消息。\n- 每个 RTSP Header 还要带上一个值为 `connected; type=analog` 的头 `Audio-Jack-Status`。\n- 你还要响应 RTSP 的 OPTION 请求，这个请求是由客户端向服务端发起，要求服务端告知支持的所有请求类型，因此这里我们需要将所有的 RTSP 请求方法带在 Response 中返回给客户端。\n\n## 接收并处理你的数据流\n\n当请求经过了上面几层 Handler 还在往下传递的时候，这个时候数据包应该就到了 RTSP 的正常处理流程中了。而这些所有的关于 RTSP 的处理都是在 `AudioHandler` 中来完成的。我们会收到下面这几种请求\n\n- ANNOUNCE 初始化步骤，传输媒体信息，编码和加密秘钥\n- SETUP 连接步骤\n- RECORD 不需要做什么，在这里所有的工作都在前两步里面完成了\n- FLUSH 当客户端终止了 Airtunes 传输的时候发送，用来清空数据队列\n- TEARDOWN 直接关闭连接\n\n### ANNOUNCE\n\nANNOUNCE 中主要是带来了一些 RTP 数据的参数，Android 可以根据这些参数来初始化相应的 **RTP 处理队列**，**ALAC Decoder** 和 **AES 解密处理器**（注意所有之后的 RTP 包都是 AES 加密过的，需要用这里初始化的解密处理器解一遍，但是 RTSP 包不是 ）。ANNOUNCE 在传输的时候遵循 **SDP 描述格式**来传输媒体信息：\n\n> **关于 SDP**\n>\n> SDP 是一种会话描述格式，它不属于传输协议。\n>\n> SDP协议是基于文本的协议，这样就能保证协议的可扩展性比较强。SDP 不支持会话内容或媒体编码的协商，所以在流媒体中只用来描述媒体信息。\n>\n> SDP描述由许多文本行组成，文本行的格式为:\n>\n> **类型 = 值**\n>\n> 其中，类型是一个字母，值是结构化的文本串，其格式依类型而定。\n>\n> **sdp的格式:**\n>\n> ```\n> v=<version>\n> o=<username> <session id> <version> <network type> <address type> <address>\n> s=<session name>\n> i=<session description>\n> u=<URI>\n> e=<email address>\n> p=<phone number>\n> c=<network type> <address type> <connection address>\n> b=<modifier>:<bandwidth-value>\n> t=<start time> <stop time>\n> r=<repeat interval> <active duration> <list of offsets from start-time>\n> z=<adjustment time> <offset> <adjustment time> <offset> ....\n> k=<method>\n> k=<method>:<encryption key>\n> a=<attribute>\n> a=<attribute>:<value>\n> m=<media> <port> <transport> <fmt list>\n>\n> v = (协议版本)\n> o = (所有者/创建者和会话标识符)\n> s = (会话名称)\n> i = * (会话信息)\n> u = * (URI 描述)\n> e = * (Email 地址)\n> p = * (电话号码)\n> c = * (连接信息)\n> b = * (带宽信息)\n> z = * (时间区域调整)\n> k = * (加密密钥)\n> a = * (0 个或多个会话属性行)\n>\n> 时间描述: \n> t = (会话活动时间)\n> r = * (0或多次重复次数)\n>\n> 媒体描述: \n> m = (媒体名称和传输地址)\n> i = * (媒体标题)\n> c = * (连接信息 — 如果包含在会话层则该字段可选)\n> b = * (带宽信息)\n> k = * (加密密钥)\n> a = * (0 个或多个媒体属性行)\n> ```\n\nAirplay 服务所定义的 ANNOUNCE 包的 SDP 格式如下：\n\n```\n/**\n* Sample sdp content:\n* \nv=0\no=iTunes 3413821438 0 IN IP4 fe80::217:f2ff:fe0f:e0f6\ns=iTunes\nc=IN IP4 fe80::5a55:caff:fe1a:e187\nt=0 0\nm=audio 0 RTP/AVP 96\na=rtpmap:96 AppleLossless\na=fmtp:96 352 0 16 40 10 14 2 255 0 0 44100\na=fpaeskey:RlBMWQECAQAAAAA8AAAAAPFOnNe+zWb5/n4L5KZkE2AAAAAQlDx69reTdwHF9LaNmhiRURTAbcL4brYAceAkZ49YirXm62N4\na=aesiv:5b+YZi9Ikb845BmNhaVo+Q\n*/\n```\n\n根据样例格式我们可以解析出 AES 解密的**秘钥**和**初始化矩阵IV**以及流的数据格式，从而初始化 **ALAC Decoder**。其中，参数 m 的最后一个值和 rtpmap 的第一个值需要保持一致，rtpmap 的第一个值和 fmtp 的第一个值需要保持一致，他们都是 **payload type** 的值，因此在解析完包的数据之后要进行校验。fmtp 第一个参数之后的所有参数表示的都是媒体格式的指定参数。我们用这些参数来初始化 ALAC Decoder。*关于 SDP 的详细参数描述你可以在谷歌上找到更多*。\n\n> a=fmtp:<format> <format specific parameters>\n> ​       This attribute allows parameters that are specific to a particular format to be conveyed in a way that SDP doesn't have to understand them.  The format must be one of the formats specified for the media.  Format-specific parameters may be any set of parameters required to be conveyed by SDP and given unchanged to the media tool that will use this format.\n>\n> ​       It is a media attribute, and is not dependent on charset.\n\n接下来是 AES 解密的秘钥和初始化矩阵 IV：\n\n```\nif (\"rsaaeskey\".equals(key)) {\n/* Sets the AES key required to decrypt the audio data. The key is\n* encrypted wih the AirTunes private key\n*/\nbyte[] aesKeyRaw;\n\nrsaPkCS1OaepCipher.init(Cipher.DECRYPT_MODE, AirTunesCryptography.PrivateKey);\naesKeyRaw = rsaPkCS1OaepCipher.doFinal(Base64.decodeUnpadded(value));\n\naesKey = new SecretKeySpec(aesKeyRaw, \"AES\");\n}\nelse if (\"aesiv\".equals(key)) {\n/* Sets the AES initialization vector */\naesIv = new IvParameterSpec(Base64.decodeUnpadded(value));\n}\n```\n\n这两个值都是用 Base64 加密过的，所以我们要先 Base64 解密得到原始数据，然后 **AES Key** 需要再通过 Airtunes 的秘钥来 RSA 解密，最后得到 AES 解密需要的 Key。\n\n### SETUP\n\n在 ANNOUNCE 中我们主要是得到了数据格式，数据解密的方法参数这些基本信息，那么 SETUP 的时候客户端就是在和我们交换一些连接信息：主要也就是三个 port 的信息，对应三个 channel，分别是 **control port -> control channel**，**timing port -> timing channel** 和 **server port -> audio channel**，这是三个 **UDP 连接**的端口。这也是整个 Airtunes 服务结构中最重要的部分了：\n\n- **control port** 是用来发送 resendTransmitRequest 的 channel，也就是当 Android 这边发现我收到的音乐流数据包中有丢失帧的时候，可以通过 control port 发送 resendTransmit 的 request 给 iOS 设备，设备收到后会将帧在 response 中补发回来\n- **timing port** 用来传输 Airplay 的时间同步包，同时也可以主动向 iOS 设备请求当前的时间戳来校准流的时间戳\n- **server port** 则是用来传输最主要的音乐流数据包\n\n> 在这里我们将 control 和 timing 的包统一 reroute 到 audio 的 channel 上来处理。接收到的 UpStream 将包从 control 和 timing 集中到 audio 来处理，而发送出去的 DownStream 则是将指定类型的包从 audio 分发到 control 和 timing 去发送和接收 response。下面会详细展开。\n\n```\n/* Split Transport header into individual options and prepare response options list */\nfinal Deque<String> requestOptions = new java.util.LinkedList<String>(Arrays.asList(req.getHeader(HEADER_TRANSPORT).split(\";\")));\nfinal List<String> responseOptions = new java.util.LinkedList<String>();\n\n/* Transport header. Protocol must be RTP/AVP/UDP */\nfinal String requestProtocol = requestOptions.removeFirst();\nif ( ! \"RTP/AVP/UDP\".equals(requestProtocol)){\nthrow new ProtocolException(\"Transport protocol must be RTP/AVP/UDP, but was \" + requestProtocol);\n}\n\nresponseOptions.add(requestProtocol);\n```\n\n> HEADER 中 key 为 **Transport** 的字段值必须为 `RTP/AVP/UDP` 。\n\n首先对 SETUP 的参数列表进行解析，解出来的 `requestOptions` 仍然是用正则匹配的形式获取到 key - value 对：\n\n```\n/* Parse incoming transport options and build response options */\nfor(final String requestOption: requestOptions) {\n/* Split option into key and value */\nfinal Matcher transportOption = PATTERN_TRANSPORT_OPTION.matcher(requestOption);\nif ( ! transportOption.matches() ){\nthrow new ProtocolException(\"Cannot parse Transport option \" + requestOption);\n}\nfinal String key = transportOption.group(1);\nfinal String value = transportOption.group(3);\n```\n\n其中我们只要对指定几个 key 进行 response 就可以了，其中，除了 `interleaved` 和 `mode` 返回的参数是固定的之外，`control_port` 和 `timing_port` 在 request 中所对应的 value 是客户端的端口，而 response 中需要带上服务端的端口。同时，这两个 UDP 连接由服务端发起去连接客户端对应的端口。最后再告知客户端 `server_port` 的端口。\n\n**interleaved** 指的是由于这条 TCP 连接 RTP 和 RTCP 都要使用，因此两个连接的数据包会交叉传输在同一个 TCP 连接上，每个包都会再加一层标识，而标识 Channel 的值就由这里的 interleaved 后面的值 0-1 来决定，表示有 0 和 1 两种交叉混用的 Channel 类型。\n\n```\n/* Probably means that two channels are interleaved in the stream. Included in the response options */\nif ( ! \"0-1\".equals(value)){\nthrow new ProtocolException(\"Unsupported Transport option, interleaved must be 0-1 but was \" + value);\n}\nresponseOptions.add(\"interleaved=0-1\");\n```\n\n**mode** 则是校验客户端要求我们做的事情，这是 RTSP 协议中规定的一部分，在 Airplay 中，Server 永远承担的是接收数据的工作，因此 mode 的值也应当保持为 **record** 。\n\n```\n/* Means the we're supposed to receive audio data, not send it. Included in the response options */\nif ( ! \"record\".equals(value)){\nthrow new ProtocolException(\"Unsupported Transport option, mode must be record but was \" + value);\n}\nresponseOptions.add(\"mode=record\");\n```\n\n**control_port** 是 control channel 对应的客户端的端口号，而我们返回的 response 中需要改成服务端的端口号。可以随便分配一个比较大的端口号就行。\n\n```\n/* Port number of the client's control socket. Response includes port number of *our* control port */\nfinal int clientControlPort = Integer.valueOf(value);\n\ncontrolChannel = createRtpChannel(\nsubstitutePort((InetSocketAddress)ctx.getChannel().getLocalAddress(), 53670),\nsubstitutePort((InetSocketAddress)ctx.getChannel().getRemoteAddress(), clientControlPort),\nRaopRtpChannelType.Control\n);\nresponseOptions.add(\"control_port=\" + ((InetSocketAddress)controlChannel.getLocalAddress()).getPort());\n```\n\n**timing_port** 则是 timing channel 对应的客户端的端口号。\n\n```\n/* Port number of the client's timing socket. Response includes port number of *our* timing port */\nfinal int clientTimingPort = Integer.valueOf(value);\n\ntimingChannel = createRtpChannel(\nsubstitutePort((InetSocketAddress)ctx.getChannel().getLocalAddress(), 53669),\nsubstitutePort((InetSocketAddress)ctx.getChannel().getRemoteAddress(), clientTimingPort),\nRaopRtpChannelType.Timing\n);\n\nresponseOptions.add(\"timing_port=\" + ((InetSocketAddress)timingChannel.getLocalAddress()).getPort());\n```\n\n**server_port** 这个 key 并不在 SETUP 的参数列表中，但是你需要在 response 中带上，告知客户端你在哪个端口打开了你的 audio 数据接收。因此它不需要主动去连接客户端的端口。\n\n```\n/* Create audio socket and include it's port in our response */\naudioChannel = createRtpChannel(\nsubstitutePort((InetSocketAddress)ctx.getChannel().getLocalAddress(), 53671),\nnull,\nRaopRtpChannelType.Audio\n);\n\nresponseOptions.add(\"server_port=\" + ((InetSocketAddress)audioChannel.getLocalAddress()).getPort());\n```\n\n其中的 `createRtpChannel` 方法中，我们同样也为每一个端口新建一个 bootstrap 实例，添加 pipeline Handler，然后将 timing 和 control 两个 port 连接到 SETUP 包带来的 iOS 客户端端口上去。连接成功后 SETUP 也就处理完毕了。\n\n```\n/* Set pipeline factory for the RTP channel */\nbootstrap.setPipelineFactory(new ChannelPipelineFactory() {\n@Override\npublic ChannelPipeline getPipeline() throws Exception {\nfinal ChannelPipeline pipeline = Channels.pipeline();\n\nfinal AirPlayServer airPlayServer = AirPlayServer.getIstance();\n\npipeline.addLast(\"executionHandler\", airPlayServer.getChannelExecutionHandler());\npipeline.addLast(\"exceptionLogger\", exceptionLoggingHandler);\npipeline.addLast(\"decoder\", decodeHandler);\npipeline.addLast(\"encoder\", encodeHandler);\n\n/* We pretend that all communication takes place on the audio channel,\n* and simply re-route packets from and to the control and timing channels\n*/\nif ( ! channelType.equals(RaopRtpChannelType.Audio)) {\npipeline.addLast(\"inputToAudioRouter\", inputToAudioRouterDownstreamHandler);\n\n/* Must come *after* the router, otherwise incoming packets are logged twice */\npipeline.addLast(\"packetLogger\", packetLoggingHandler);\n}\nelse {\n/* Must come *before* the router, otherwise outgoing packets are logged twice */\npipeline.addLast(\"packetLogger\", packetLoggingHandler);\npipeline.addLast(\"audioToOutputRouter\", audioToOutputRouterUpstreamHandler);\npipeline.addLast(\"timing\", timingHandler);\npipeline.addLast(\"resendRequester\", resendRequestHandler);\n\nif (decryptionHandler != null){\npipeline.addLast(\"decrypt\", decryptionHandler);\n}\n\nif (audioDecodeHandler != null){\npipeline.addLast(\"audioDecode\", audioDecodeHandler);\n}\n\npipeline.addLast(\"enqueue\", audioEnqueueHandler);\n}\n\nreturn pipeline;\n}\n});\n```\n\n这里的 pipeline 模型如图，也是三个 channel 处理流程的结构图，接下来的小节会展开说明：\n\n![](https://ooo.0o0.ooo/2016/08/28/57c300b59b89e.png)\n\n## Audio Pipeline 和 三个 Channel 之间的关系\n\nSETUP 结束之后就会开始收到 Audio 的数据包了。那么正式的处理就要开始了。\n\n根据上面这张我总结出来的流程图，Airplay Service 可以根据 bootstrap 的 pipeline 的特性可以分为 `Up Stream` 和 `Down Stream`，一个是从客户端向服务端传递的消息，一个是从服务端向客户端传递的消息。\n\n##### Up Stream\n\n首先不论是 Up 还是 Down Stream，都要先经过一个 Executor Handler，这个 Handler 中包括了一个线程池 Executor，当收到新的 UpStream 的数据包的时候，都会交给这个线程池来分配线程处理，在这里声明的线程池是一个 `OrderedMemoryAwareThreadPoolExecutor`。至于为什么在 Netty 的 pipeline 处理中要用到线程池来分配任务，可以参考[这篇文章](http://www.techv5.com/topic/85/)。简要地说就是由于 Handler 处理的工作量很大，为了不堵塞线程，Netty 会开好几个线程来处理，并且 `OrderedMemoryAwareThreadPoolExecutor` 能够保证处理的事件流的顺序，所以这里要加这一层。\n\n数据进入 pipeline 之后，先是按照 RTP Packet 的格式进行 decode。在 Airplay 协议中，总共有如下几种 Packet Type：\n\n- TimingRequest\n- TimingResponse\n- Sync\n- RetransmitRequest\n- AudioRetransmit\n- AudioTransmit\n\n其中 `TimingRequest`，`TimingResponse` 和 `Sync` 三种包类型都是属于 timing channel的，`RetransmitRequest` 是由 control channel 发起的对丢失包重传的请求，而 `AudioRetransmit` 和 `AudioTransmit` 都是由 audio channel 处理的包含了音乐数据的包。\n\n消息继续往下传递，过了 Logger 之后就到了 router。router 维护了 audio channel 和另外两个 channel 之间的关系：router 将另外两个 channel 应该处理的包发送给对应的 Handler 去处理。\n\ntiming channel 不仅处理 Sync 数据包，同时在 channel 启动的时候也会启动一个单独的线程，每三秒钟执行一次 timing request，来确认本地时钟和客户端时钟的同步。而 control channel 做的事情则是在**每收到一个**新的 audio 数据包的时候都会**确认一次数据包的 sequence number 是否和当前的是连续的**，如果不是连续的，则将中间缺失的 number 标记为 missing 的数据包，并且向客户端发送一个 resend 的请求。当客户端发来了 `AudioRetransmit` 类型的数据包后，它的内容其实也是由 audio channel 接收的，control channcel 只是负责将刚才标记为 missing 的 sequence number 清除掉。\n\n这两个 channel 在发送 request 的时候，也会发回到 audio channel 的 Handler 上来，通过 audio channel 这边的 encode 之后再发送出去。\n\n而音乐数据包，则需要经过 AES 解密，这个解密器我们已经在 ANNOUNCE 的时候初始化好了，再经过 ALACDecoder，也是在 ANNOUNCE 的时候根据获得的媒体信息初始化的音频解码器，最后在 EnqueueHandler 中决定是否进入音频输出队列。\n\n##### Down Stream\n\n往客户端发送的信息主要就是 timine 和 control 两个 channel 发起的一些请求了，audio channel 没有参与 down stream 的传递。\n\n## EnqueueHandler 音乐数据队列 Handler\n\n当一个数据包经过层层解密和解析进入队列 Handler 之后，还要进行一大堆的时间戳合法性校验。**每一个数据包都包含了很多帧，每一个帧都包含了一个帧序号，而每一个包也都有一个开始的帧序号。**这里涉及到好几个地方的时间和与时间相对应的帧序列：\n\n- Android 上  Audio Track 当前的 time\n- 服务端队列中当前的 frame time\n- audio channel 中客户端传来的数据包中的 frame time\n- timing channel 中客户端传来的 Sync 和 timing response 包中的 frame time\n\n首先，我们允许一定范围的延迟，因为数据的传输，最开始的握手包括 iOS 端 Airplay 的机制都可能导致一定的延迟，因此 **timing channel 最重要的作用之一就是维护和当前主队列最新 frame time的 offset**。在每一个 timing response 的包中，我可以知道当前客户端的帧序号和服务端已经播放到的帧序号的 offset，在每解析一个数据包的时候，都要使用当前的 offset 来将客户端的帧序号转换成服务端的帧序号。每个包所带的 frame time 都可能有下面三种情况：\n\n- **太迟了**\n\n\n![](https://ooo.0o0.ooo/2016/08/29/57c42046195f6.png)\n\n太迟了的情况如图所示，Line Time 这条轴就是 Audio Track ，**Now Time** 指的是当前音乐数据已经播放到什么时间了，这时候服务端接收到的一个 Packet，在包中的开始帧序列为 frame time，将这个帧序列转换为本地 Audio Track 对应的 Line Time，加上整个 Packet 包含的帧数，这个值与 Now Time 的差距**转化成时间**就是它的 Delay，当这个 delay 大于一个包长度的时候，由于它已经是播放过的时间线了，因此当一个包迟到了一个包的长度以上，它就不再被需要了，这时候这个包也就不会被加进 queue 了。\n\n- **太早**\n\n![](https://ooo.0o0.ooo/2016/08/29/57c42030293f6.png)\n\n太早的情况如图所示。有别于迟到的包，提前来的包其实是件好事，但是提前来的太早的包也不一定是件好事，它很可能要么是个错误的包，要么是个传输错误的包。因此对于提前到来的包一般都有一个时间长度的阈值，提前了大于多少秒到来的包才会被认定是 too early 然后被丢掉。在这个项目中这个阈值为 10 秒。\n\n- **正正好，还行**\n\n![](https://ooo.0o0.ooo/2016/08/29/57c42013d2672.png)\n\n正正好的情况如图所示。当一个数据包上述两种情况都不满足的时候，那就说明这个包的时间戳和帧序列是我们可以接受的，于是我们将这个包加进最后的音频处理队列。\n\n进入了队列之后，我们还要将数据从这个队列中按顺序写到 Audio Track 上去。首先确保 Audio Track 的模式为 **MODE_STREAM** ，然后按照先进先出的顺序处理队列。其实在这里的处理中对于每一个包的开始帧的序列号又做了一次校验，类似上面对于 Delay 的做法，在这里又会从队列中再次筛选掉一些无用帧。接下去在将帧最后添加到 Audio Track 上去的时候，由于我们添加到队列中的包只是上面的**正正好，还行**的情况，很有可能会出现下一个包的开始和当前 Audio Track 的 Line Time 无法完全吻合的情况出现，这时候我们就需要在缺少帧的地方补上空帧，在多余帧的地方等待一会直到帧的序号完全对上，然后再将帧写入 Audio Track，这样能够保证最终播放的帧一定是序列正确的。\n\n## 更多\n\n其实这篇博客没有涉及太多安卓相关的东西，说白了也只是 Airplay Server 的一种 Java 实现。在实现的基础上，掌握了 Airplay 实现的原理的话，在不论是什么平台上都可以按照相应的原理来实现一个 Airplay Server。用这个将你闲置废弃的安卓手机变成你的无线音箱吧！\n","source":"_posts/iOS-Airplay-中的-Airtunes-Server-服务协议和机制详解以及-Android-Demo-的实现.md","raw":"title: iOS Airplay 中的 Airtunes Server 服务协议和机制详解以及 Android Demo 的实现\ndate: 2016-08-29 10:03:22\ncategories: 细心写的技术博客\n\n\ntags: [Airplay, Android, iOS]\n---\n\n在 Android 设备上搭建一个 Airplay Server 其实是一件很浩大的工程，因为这需要逆向苹果的 Airplay 协议流程啊格式啊什么的，万幸这件事情已经由许许多多国外的大神们帮我们做好了，因此我们只要基于他们逆向出来的 Airplay 协议来搭建一个服务就可以了。话虽如此，整个过程中的工作量和需要掌握的知识点还是非常非常多的。\n\n在局域网中实现流媒体传输的主流协议有两种，一种是苹果封闭的 Airplay 协议，一种是 DLNA 。\n\n> **D**IGITAL **L**IVING **N**ETWORK **A**LLIANCE 数字生活网络联盟，是索尼、英特尔、微软等发起的一套 PC、移动设备、消费电器之间互联互通的协议。它们的宗旨是“随时随地享受音乐、照片和视频”。据说苹果当时也是 DLNA 联盟的成员，而后来退出了并自立门户。\n\n对于 iOS 系统来说，对用户最友好且体验最好的方式自然还是通过 Airplay 协议了（其实我是不太喜欢在每个单独的视频或者音乐播放器里面去找到 DLNA 或者 Airplay 的按钮然后切换模式，系统级的服务体验还是更好一些，因此我更倾向使用 Airplay）。因此在很多场景下，你需要让你的**安卓硬件**或者**设备**支持 Airplay 服务，本文就是通过一步步解释和分析这个基于 DroidPlay 改出的稳定可用的 Airtunes 服务，给大家展示一个比较清晰的 Airplay 中的 Airtunes 的机制和服务流程。\n\n> 代码在 Git\bHub 上开放给大家学习和改动。地址在[这里](https://github.com/SergioChan/Android-Airplay-Server)。\n\n## 首先，如何让 iOS 设备发现你\n\n这是万事开头的第一步：你需要让自己的安卓设备出现在 iOS 设备 Airplay 的设备列表中。由于 Airplay 是基于局域网的，苹果设备会在当前局域网里搜寻支持 Airplay 服务的设备，因此在这里你就需要通过 mDNS 服务向局域网发送一个组播来让 iOS 设备能够在内网中发现你。在 Android 上你可以使用 **jmDNS** 库来实现这个功能:\n\n```\nfinal JmDNS jmDNS = JmDNS.create(addr, hostName + \"-jmdns\");\njmDNSInstances.add(jmDNS);\n\n/* Publish RAOP service */\nfinal ServiceInfo airTunesServiceInfo = ServiceInfo.create(\nAIR_TUNES_SERVICE_TYPE,\nhardwareAddressString + \"@\" + hostName,\ngetRtspPort(),\n0 /* weight */, 0 /* priority */,\nAIRTUNES_SERVICE_PROPERTIES\n);\njmDNS.registerService(airTunesServiceInfo);\n```\n\n这个注册的服务类型和参数都是固定的，服务类型为 `_raop._tcp.local.`，参数列表如下:\n\n```\n\"txtvers\", \"1\",\n\"tp\", \"UDP\",\n\"ch\", \"2\",\n\"ss\", \"16\",\n\"sr\", \"44100\",\n\"pw\", \"false\",\n\"sm\", \"false\",\n\"sv\", \"false\",\n\"ek\", \"1\",\n\"et\", \"0,1\",\n\"cn\", \"0,1\",\n\"vn\", \"3\"\n```\n\n通过注册上这个 mDNS 服务，现在你应该可以在你的 iOS 设备上的 Airplay 列表里看到一个名字为你设置的 `hostName` 的设备了。当然，现在点击连接应该是没有任何反应的，因为接下来需要进行好几次的  RTSP 请求来进行校验和连接，我们要做的也主要就是接下来这几个步骤了。\n\n> **Airplay 连接一开始的延迟貌似是没有办法解决的**。参考这篇[SO回答](http://stackoverflow.com/questions/9997882/detecting-the-airplay-latency)，里面明确指出，Airplay 连接的延迟来源于发送方需要多次 RTSP 请求握手，大概在**两秒左右**，当然，如果你在客户端层面去做自己的传输协议当然是没有问题的，但是你并不能按照 Airplay 的包格式来实现系统级的 Airplay 到其他不论是原生的 iOS 设备还是支持了 Airplay 的 Android 设备上去，这会被苹果 Reject。所以如果在之后的开发中最后遇到了一点几秒的延迟没法解决的时候，记住不要钻进坑里了。实际测试中延迟大概在 1.6 秒左右。\n\n## 开启你的服务端\n\n告知了 iOS 设备你的端口信息之后，接下来就是在指定的端口开启你的服务端等候 iOS 设备传来的包了。在这里我们使用的是 Netty 库的 bootstrap 来搭建一个服务器，关于 Netty 你可以在百度和谷歌上找到更多介绍。总之它的机制是每一个新的 TCP 连接都会建立一个子的 channel 然后每一个 channel 的处理都是一个 pipeline 的处理模式，接收到消息的时候消息会在 pipeline 中流动，直到不再往下流动，发送消息反之亦然。\n\n苹果的 Airplay 协议主要是通过 RTSP 协议的 Header 中的几个参数来进行身份的验证和包的校验，所以为了满足苹果自己需要的校验规则，我们需要在 pipeline 中加上这几个处理校验的 Handler：\n\n```\npipeline.addLast(\"challengeResponse\", new RaopRtspChallengeResponseHandler(NetworkUtils.getInstance().getHardwareAddress()));\npipeline.addLast(\"header\", new RaopRtspHeaderHandler());\npipeline.addLast(\"options\", new RaopRtspOptionsHandler());\n```\n\n其中：\n\n- 由 iOS 设备向 Android 设备发送的 Request 的 Header 中 （注意这里你的 Android 是作为服务端的）包含一个叫做 `Apple-Challenge` 的字段，它的值需要经过 Base64 解密之后获得一个凭证，这个凭证是要在每一次的 Response 中使用到的。\n- 由 Android 设备向 iOS 设备发送的 Response 的 Header 中需要包含一个叫做 `Apple-Response` 的字段，它的值需要经过一层 RSA 加密和一层 Base64 加密，原始数据则是 16 位 `Apple-Challenge` 解密后的凭证 + 16位 InetAddress.getAddress() 获取到的 byte 数组 + 6 位 硬件地址。分别是从 Request 中，`InetAddress.getAddress()` 和下面这段代码中的 `NetworkInterface` 来获得硬件地址。带有 `Apple-Challenge` Header 的包只会在 RTSP 连接建立的时候发送一次，因此稍微判断一下是否需要返回 `Apple-Response` 的 Header 就可以了。另外，在这里的 RSA 加密中用到的秘钥是一个私钥，也就是双方提前约定好的一个串，这个串会不定期的更新，破解的事情应该只有少数大神才做的了吧……对于我们主要还是从国外的一些博客和网站上经常去关注是否有私钥更新比较靠谱。这个私钥在所有的 RSA 解密操作中都要用到。\n\n```\nfor(final NetworkInterface iface: Collections.list(NetworkInterface.getNetworkInterfaces())) {\nif (iface.isLoopback()){\ncontinue;\n}\nif (iface.isPointToPoint()){\ncontinue;\n}\n\ntry {\nfinal byte[] ifaceMacAddress = iface.getHardwareAddress();\nif ((ifaceMacAddress != null) && (ifaceMacAddress.length == 6) && !isBlockedHardwareAddress(ifaceMacAddress)) {\nreturn Arrays.copyOfRange(ifaceMacAddress, 0, 6);\n}\n}\ncatch (final Throwable e) {\n/* Ignore */\n}\n}\n```\n\n- 对于 RTSP Header 的处理，每个 RTSP 包都会带有 `CSeq` 的头，这个头需要在 Response 和 Request 中保持一致。它指定了 RTSP 请求回应对的序列号，在每个请求或回应中都必须包括这个头字段。对每个包含一个给定序列号的请求消息，都会有一个相同序列号的回应消息。\n- 每个 RTSP Header 还要带上一个值为 `connected; type=analog` 的头 `Audio-Jack-Status`。\n- 你还要响应 RTSP 的 OPTION 请求，这个请求是由客户端向服务端发起，要求服务端告知支持的所有请求类型，因此这里我们需要将所有的 RTSP 请求方法带在 Response 中返回给客户端。\n\n## 接收并处理你的数据流\n\n当请求经过了上面几层 Handler 还在往下传递的时候，这个时候数据包应该就到了 RTSP 的正常处理流程中了。而这些所有的关于 RTSP 的处理都是在 `AudioHandler` 中来完成的。我们会收到下面这几种请求\n\n- ANNOUNCE 初始化步骤，传输媒体信息，编码和加密秘钥\n- SETUP 连接步骤\n- RECORD 不需要做什么，在这里所有的工作都在前两步里面完成了\n- FLUSH 当客户端终止了 Airtunes 传输的时候发送，用来清空数据队列\n- TEARDOWN 直接关闭连接\n\n### ANNOUNCE\n\nANNOUNCE 中主要是带来了一些 RTP 数据的参数，Android 可以根据这些参数来初始化相应的 **RTP 处理队列**，**ALAC Decoder** 和 **AES 解密处理器**（注意所有之后的 RTP 包都是 AES 加密过的，需要用这里初始化的解密处理器解一遍，但是 RTSP 包不是 ）。ANNOUNCE 在传输的时候遵循 **SDP 描述格式**来传输媒体信息：\n\n> **关于 SDP**\n>\n> SDP 是一种会话描述格式，它不属于传输协议。\n>\n> SDP协议是基于文本的协议，这样就能保证协议的可扩展性比较强。SDP 不支持会话内容或媒体编码的协商，所以在流媒体中只用来描述媒体信息。\n>\n> SDP描述由许多文本行组成，文本行的格式为:\n>\n> **类型 = 值**\n>\n> 其中，类型是一个字母，值是结构化的文本串，其格式依类型而定。\n>\n> **sdp的格式:**\n>\n> ```\n> v=<version>\n> o=<username> <session id> <version> <network type> <address type> <address>\n> s=<session name>\n> i=<session description>\n> u=<URI>\n> e=<email address>\n> p=<phone number>\n> c=<network type> <address type> <connection address>\n> b=<modifier>:<bandwidth-value>\n> t=<start time> <stop time>\n> r=<repeat interval> <active duration> <list of offsets from start-time>\n> z=<adjustment time> <offset> <adjustment time> <offset> ....\n> k=<method>\n> k=<method>:<encryption key>\n> a=<attribute>\n> a=<attribute>:<value>\n> m=<media> <port> <transport> <fmt list>\n>\n> v = (协议版本)\n> o = (所有者/创建者和会话标识符)\n> s = (会话名称)\n> i = * (会话信息)\n> u = * (URI 描述)\n> e = * (Email 地址)\n> p = * (电话号码)\n> c = * (连接信息)\n> b = * (带宽信息)\n> z = * (时间区域调整)\n> k = * (加密密钥)\n> a = * (0 个或多个会话属性行)\n>\n> 时间描述: \n> t = (会话活动时间)\n> r = * (0或多次重复次数)\n>\n> 媒体描述: \n> m = (媒体名称和传输地址)\n> i = * (媒体标题)\n> c = * (连接信息 — 如果包含在会话层则该字段可选)\n> b = * (带宽信息)\n> k = * (加密密钥)\n> a = * (0 个或多个媒体属性行)\n> ```\n\nAirplay 服务所定义的 ANNOUNCE 包的 SDP 格式如下：\n\n```\n/**\n* Sample sdp content:\n* \nv=0\no=iTunes 3413821438 0 IN IP4 fe80::217:f2ff:fe0f:e0f6\ns=iTunes\nc=IN IP4 fe80::5a55:caff:fe1a:e187\nt=0 0\nm=audio 0 RTP/AVP 96\na=rtpmap:96 AppleLossless\na=fmtp:96 352 0 16 40 10 14 2 255 0 0 44100\na=fpaeskey:RlBMWQECAQAAAAA8AAAAAPFOnNe+zWb5/n4L5KZkE2AAAAAQlDx69reTdwHF9LaNmhiRURTAbcL4brYAceAkZ49YirXm62N4\na=aesiv:5b+YZi9Ikb845BmNhaVo+Q\n*/\n```\n\n根据样例格式我们可以解析出 AES 解密的**秘钥**和**初始化矩阵IV**以及流的数据格式，从而初始化 **ALAC Decoder**。其中，参数 m 的最后一个值和 rtpmap 的第一个值需要保持一致，rtpmap 的第一个值和 fmtp 的第一个值需要保持一致，他们都是 **payload type** 的值，因此在解析完包的数据之后要进行校验。fmtp 第一个参数之后的所有参数表示的都是媒体格式的指定参数。我们用这些参数来初始化 ALAC Decoder。*关于 SDP 的详细参数描述你可以在谷歌上找到更多*。\n\n> a=fmtp:<format> <format specific parameters>\n> ​       This attribute allows parameters that are specific to a particular format to be conveyed in a way that SDP doesn't have to understand them.  The format must be one of the formats specified for the media.  Format-specific parameters may be any set of parameters required to be conveyed by SDP and given unchanged to the media tool that will use this format.\n>\n> ​       It is a media attribute, and is not dependent on charset.\n\n接下来是 AES 解密的秘钥和初始化矩阵 IV：\n\n```\nif (\"rsaaeskey\".equals(key)) {\n/* Sets the AES key required to decrypt the audio data. The key is\n* encrypted wih the AirTunes private key\n*/\nbyte[] aesKeyRaw;\n\nrsaPkCS1OaepCipher.init(Cipher.DECRYPT_MODE, AirTunesCryptography.PrivateKey);\naesKeyRaw = rsaPkCS1OaepCipher.doFinal(Base64.decodeUnpadded(value));\n\naesKey = new SecretKeySpec(aesKeyRaw, \"AES\");\n}\nelse if (\"aesiv\".equals(key)) {\n/* Sets the AES initialization vector */\naesIv = new IvParameterSpec(Base64.decodeUnpadded(value));\n}\n```\n\n这两个值都是用 Base64 加密过的，所以我们要先 Base64 解密得到原始数据，然后 **AES Key** 需要再通过 Airtunes 的秘钥来 RSA 解密，最后得到 AES 解密需要的 Key。\n\n### SETUP\n\n在 ANNOUNCE 中我们主要是得到了数据格式，数据解密的方法参数这些基本信息，那么 SETUP 的时候客户端就是在和我们交换一些连接信息：主要也就是三个 port 的信息，对应三个 channel，分别是 **control port -> control channel**，**timing port -> timing channel** 和 **server port -> audio channel**，这是三个 **UDP 连接**的端口。这也是整个 Airtunes 服务结构中最重要的部分了：\n\n- **control port** 是用来发送 resendTransmitRequest 的 channel，也就是当 Android 这边发现我收到的音乐流数据包中有丢失帧的时候，可以通过 control port 发送 resendTransmit 的 request 给 iOS 设备，设备收到后会将帧在 response 中补发回来\n- **timing port** 用来传输 Airplay 的时间同步包，同时也可以主动向 iOS 设备请求当前的时间戳来校准流的时间戳\n- **server port** 则是用来传输最主要的音乐流数据包\n\n> 在这里我们将 control 和 timing 的包统一 reroute 到 audio 的 channel 上来处理。接收到的 UpStream 将包从 control 和 timing 集中到 audio 来处理，而发送出去的 DownStream 则是将指定类型的包从 audio 分发到 control 和 timing 去发送和接收 response。下面会详细展开。\n\n```\n/* Split Transport header into individual options and prepare response options list */\nfinal Deque<String> requestOptions = new java.util.LinkedList<String>(Arrays.asList(req.getHeader(HEADER_TRANSPORT).split(\";\")));\nfinal List<String> responseOptions = new java.util.LinkedList<String>();\n\n/* Transport header. Protocol must be RTP/AVP/UDP */\nfinal String requestProtocol = requestOptions.removeFirst();\nif ( ! \"RTP/AVP/UDP\".equals(requestProtocol)){\nthrow new ProtocolException(\"Transport protocol must be RTP/AVP/UDP, but was \" + requestProtocol);\n}\n\nresponseOptions.add(requestProtocol);\n```\n\n> HEADER 中 key 为 **Transport** 的字段值必须为 `RTP/AVP/UDP` 。\n\n首先对 SETUP 的参数列表进行解析，解出来的 `requestOptions` 仍然是用正则匹配的形式获取到 key - value 对：\n\n```\n/* Parse incoming transport options and build response options */\nfor(final String requestOption: requestOptions) {\n/* Split option into key and value */\nfinal Matcher transportOption = PATTERN_TRANSPORT_OPTION.matcher(requestOption);\nif ( ! transportOption.matches() ){\nthrow new ProtocolException(\"Cannot parse Transport option \" + requestOption);\n}\nfinal String key = transportOption.group(1);\nfinal String value = transportOption.group(3);\n```\n\n其中我们只要对指定几个 key 进行 response 就可以了，其中，除了 `interleaved` 和 `mode` 返回的参数是固定的之外，`control_port` 和 `timing_port` 在 request 中所对应的 value 是客户端的端口，而 response 中需要带上服务端的端口。同时，这两个 UDP 连接由服务端发起去连接客户端对应的端口。最后再告知客户端 `server_port` 的端口。\n\n**interleaved** 指的是由于这条 TCP 连接 RTP 和 RTCP 都要使用，因此两个连接的数据包会交叉传输在同一个 TCP 连接上，每个包都会再加一层标识，而标识 Channel 的值就由这里的 interleaved 后面的值 0-1 来决定，表示有 0 和 1 两种交叉混用的 Channel 类型。\n\n```\n/* Probably means that two channels are interleaved in the stream. Included in the response options */\nif ( ! \"0-1\".equals(value)){\nthrow new ProtocolException(\"Unsupported Transport option, interleaved must be 0-1 but was \" + value);\n}\nresponseOptions.add(\"interleaved=0-1\");\n```\n\n**mode** 则是校验客户端要求我们做的事情，这是 RTSP 协议中规定的一部分，在 Airplay 中，Server 永远承担的是接收数据的工作，因此 mode 的值也应当保持为 **record** 。\n\n```\n/* Means the we're supposed to receive audio data, not send it. Included in the response options */\nif ( ! \"record\".equals(value)){\nthrow new ProtocolException(\"Unsupported Transport option, mode must be record but was \" + value);\n}\nresponseOptions.add(\"mode=record\");\n```\n\n**control_port** 是 control channel 对应的客户端的端口号，而我们返回的 response 中需要改成服务端的端口号。可以随便分配一个比较大的端口号就行。\n\n```\n/* Port number of the client's control socket. Response includes port number of *our* control port */\nfinal int clientControlPort = Integer.valueOf(value);\n\ncontrolChannel = createRtpChannel(\nsubstitutePort((InetSocketAddress)ctx.getChannel().getLocalAddress(), 53670),\nsubstitutePort((InetSocketAddress)ctx.getChannel().getRemoteAddress(), clientControlPort),\nRaopRtpChannelType.Control\n);\nresponseOptions.add(\"control_port=\" + ((InetSocketAddress)controlChannel.getLocalAddress()).getPort());\n```\n\n**timing_port** 则是 timing channel 对应的客户端的端口号。\n\n```\n/* Port number of the client's timing socket. Response includes port number of *our* timing port */\nfinal int clientTimingPort = Integer.valueOf(value);\n\ntimingChannel = createRtpChannel(\nsubstitutePort((InetSocketAddress)ctx.getChannel().getLocalAddress(), 53669),\nsubstitutePort((InetSocketAddress)ctx.getChannel().getRemoteAddress(), clientTimingPort),\nRaopRtpChannelType.Timing\n);\n\nresponseOptions.add(\"timing_port=\" + ((InetSocketAddress)timingChannel.getLocalAddress()).getPort());\n```\n\n**server_port** 这个 key 并不在 SETUP 的参数列表中，但是你需要在 response 中带上，告知客户端你在哪个端口打开了你的 audio 数据接收。因此它不需要主动去连接客户端的端口。\n\n```\n/* Create audio socket and include it's port in our response */\naudioChannel = createRtpChannel(\nsubstitutePort((InetSocketAddress)ctx.getChannel().getLocalAddress(), 53671),\nnull,\nRaopRtpChannelType.Audio\n);\n\nresponseOptions.add(\"server_port=\" + ((InetSocketAddress)audioChannel.getLocalAddress()).getPort());\n```\n\n其中的 `createRtpChannel` 方法中，我们同样也为每一个端口新建一个 bootstrap 实例，添加 pipeline Handler，然后将 timing 和 control 两个 port 连接到 SETUP 包带来的 iOS 客户端端口上去。连接成功后 SETUP 也就处理完毕了。\n\n```\n/* Set pipeline factory for the RTP channel */\nbootstrap.setPipelineFactory(new ChannelPipelineFactory() {\n@Override\npublic ChannelPipeline getPipeline() throws Exception {\nfinal ChannelPipeline pipeline = Channels.pipeline();\n\nfinal AirPlayServer airPlayServer = AirPlayServer.getIstance();\n\npipeline.addLast(\"executionHandler\", airPlayServer.getChannelExecutionHandler());\npipeline.addLast(\"exceptionLogger\", exceptionLoggingHandler);\npipeline.addLast(\"decoder\", decodeHandler);\npipeline.addLast(\"encoder\", encodeHandler);\n\n/* We pretend that all communication takes place on the audio channel,\n* and simply re-route packets from and to the control and timing channels\n*/\nif ( ! channelType.equals(RaopRtpChannelType.Audio)) {\npipeline.addLast(\"inputToAudioRouter\", inputToAudioRouterDownstreamHandler);\n\n/* Must come *after* the router, otherwise incoming packets are logged twice */\npipeline.addLast(\"packetLogger\", packetLoggingHandler);\n}\nelse {\n/* Must come *before* the router, otherwise outgoing packets are logged twice */\npipeline.addLast(\"packetLogger\", packetLoggingHandler);\npipeline.addLast(\"audioToOutputRouter\", audioToOutputRouterUpstreamHandler);\npipeline.addLast(\"timing\", timingHandler);\npipeline.addLast(\"resendRequester\", resendRequestHandler);\n\nif (decryptionHandler != null){\npipeline.addLast(\"decrypt\", decryptionHandler);\n}\n\nif (audioDecodeHandler != null){\npipeline.addLast(\"audioDecode\", audioDecodeHandler);\n}\n\npipeline.addLast(\"enqueue\", audioEnqueueHandler);\n}\n\nreturn pipeline;\n}\n});\n```\n\n这里的 pipeline 模型如图，也是三个 channel 处理流程的结构图，接下来的小节会展开说明：\n\n![](https://ooo.0o0.ooo/2016/08/28/57c300b59b89e.png)\n\n## Audio Pipeline 和 三个 Channel 之间的关系\n\nSETUP 结束之后就会开始收到 Audio 的数据包了。那么正式的处理就要开始了。\n\n根据上面这张我总结出来的流程图，Airplay Service 可以根据 bootstrap 的 pipeline 的特性可以分为 `Up Stream` 和 `Down Stream`，一个是从客户端向服务端传递的消息，一个是从服务端向客户端传递的消息。\n\n##### Up Stream\n\n首先不论是 Up 还是 Down Stream，都要先经过一个 Executor Handler，这个 Handler 中包括了一个线程池 Executor，当收到新的 UpStream 的数据包的时候，都会交给这个线程池来分配线程处理，在这里声明的线程池是一个 `OrderedMemoryAwareThreadPoolExecutor`。至于为什么在 Netty 的 pipeline 处理中要用到线程池来分配任务，可以参考[这篇文章](http://www.techv5.com/topic/85/)。简要地说就是由于 Handler 处理的工作量很大，为了不堵塞线程，Netty 会开好几个线程来处理，并且 `OrderedMemoryAwareThreadPoolExecutor` 能够保证处理的事件流的顺序，所以这里要加这一层。\n\n数据进入 pipeline 之后，先是按照 RTP Packet 的格式进行 decode。在 Airplay 协议中，总共有如下几种 Packet Type：\n\n- TimingRequest\n- TimingResponse\n- Sync\n- RetransmitRequest\n- AudioRetransmit\n- AudioTransmit\n\n其中 `TimingRequest`，`TimingResponse` 和 `Sync` 三种包类型都是属于 timing channel的，`RetransmitRequest` 是由 control channel 发起的对丢失包重传的请求，而 `AudioRetransmit` 和 `AudioTransmit` 都是由 audio channel 处理的包含了音乐数据的包。\n\n消息继续往下传递，过了 Logger 之后就到了 router。router 维护了 audio channel 和另外两个 channel 之间的关系：router 将另外两个 channel 应该处理的包发送给对应的 Handler 去处理。\n\ntiming channel 不仅处理 Sync 数据包，同时在 channel 启动的时候也会启动一个单独的线程，每三秒钟执行一次 timing request，来确认本地时钟和客户端时钟的同步。而 control channel 做的事情则是在**每收到一个**新的 audio 数据包的时候都会**确认一次数据包的 sequence number 是否和当前的是连续的**，如果不是连续的，则将中间缺失的 number 标记为 missing 的数据包，并且向客户端发送一个 resend 的请求。当客户端发来了 `AudioRetransmit` 类型的数据包后，它的内容其实也是由 audio channel 接收的，control channcel 只是负责将刚才标记为 missing 的 sequence number 清除掉。\n\n这两个 channel 在发送 request 的时候，也会发回到 audio channel 的 Handler 上来，通过 audio channel 这边的 encode 之后再发送出去。\n\n而音乐数据包，则需要经过 AES 解密，这个解密器我们已经在 ANNOUNCE 的时候初始化好了，再经过 ALACDecoder，也是在 ANNOUNCE 的时候根据获得的媒体信息初始化的音频解码器，最后在 EnqueueHandler 中决定是否进入音频输出队列。\n\n##### Down Stream\n\n往客户端发送的信息主要就是 timine 和 control 两个 channel 发起的一些请求了，audio channel 没有参与 down stream 的传递。\n\n## EnqueueHandler 音乐数据队列 Handler\n\n当一个数据包经过层层解密和解析进入队列 Handler 之后，还要进行一大堆的时间戳合法性校验。**每一个数据包都包含了很多帧，每一个帧都包含了一个帧序号，而每一个包也都有一个开始的帧序号。**这里涉及到好几个地方的时间和与时间相对应的帧序列：\n\n- Android 上  Audio Track 当前的 time\n- 服务端队列中当前的 frame time\n- audio channel 中客户端传来的数据包中的 frame time\n- timing channel 中客户端传来的 Sync 和 timing response 包中的 frame time\n\n首先，我们允许一定范围的延迟，因为数据的传输，最开始的握手包括 iOS 端 Airplay 的机制都可能导致一定的延迟，因此 **timing channel 最重要的作用之一就是维护和当前主队列最新 frame time的 offset**。在每一个 timing response 的包中，我可以知道当前客户端的帧序号和服务端已经播放到的帧序号的 offset，在每解析一个数据包的时候，都要使用当前的 offset 来将客户端的帧序号转换成服务端的帧序号。每个包所带的 frame time 都可能有下面三种情况：\n\n- **太迟了**\n\n\n![](https://ooo.0o0.ooo/2016/08/29/57c42046195f6.png)\n\n太迟了的情况如图所示，Line Time 这条轴就是 Audio Track ，**Now Time** 指的是当前音乐数据已经播放到什么时间了，这时候服务端接收到的一个 Packet，在包中的开始帧序列为 frame time，将这个帧序列转换为本地 Audio Track 对应的 Line Time，加上整个 Packet 包含的帧数，这个值与 Now Time 的差距**转化成时间**就是它的 Delay，当这个 delay 大于一个包长度的时候，由于它已经是播放过的时间线了，因此当一个包迟到了一个包的长度以上，它就不再被需要了，这时候这个包也就不会被加进 queue 了。\n\n- **太早**\n\n![](https://ooo.0o0.ooo/2016/08/29/57c42030293f6.png)\n\n太早的情况如图所示。有别于迟到的包，提前来的包其实是件好事，但是提前来的太早的包也不一定是件好事，它很可能要么是个错误的包，要么是个传输错误的包。因此对于提前到来的包一般都有一个时间长度的阈值，提前了大于多少秒到来的包才会被认定是 too early 然后被丢掉。在这个项目中这个阈值为 10 秒。\n\n- **正正好，还行**\n\n![](https://ooo.0o0.ooo/2016/08/29/57c42013d2672.png)\n\n正正好的情况如图所示。当一个数据包上述两种情况都不满足的时候，那就说明这个包的时间戳和帧序列是我们可以接受的，于是我们将这个包加进最后的音频处理队列。\n\n进入了队列之后，我们还要将数据从这个队列中按顺序写到 Audio Track 上去。首先确保 Audio Track 的模式为 **MODE_STREAM** ，然后按照先进先出的顺序处理队列。其实在这里的处理中对于每一个包的开始帧的序列号又做了一次校验，类似上面对于 Delay 的做法，在这里又会从队列中再次筛选掉一些无用帧。接下去在将帧最后添加到 Audio Track 上去的时候，由于我们添加到队列中的包只是上面的**正正好，还行**的情况，很有可能会出现下一个包的开始和当前 Audio Track 的 Line Time 无法完全吻合的情况出现，这时候我们就需要在缺少帧的地方补上空帧，在多余帧的地方等待一会直到帧的序号完全对上，然后再将帧写入 Audio Track，这样能够保证最终播放的帧一定是序列正确的。\n\n## 更多\n\n其实这篇博客没有涉及太多安卓相关的东西，说白了也只是 Airplay Server 的一种 Java 实现。在实现的基础上，掌握了 Airplay 实现的原理的话，在不论是什么平台上都可以按照相应的原理来实现一个 Airplay Server。用这个将你闲置废弃的安卓手机变成你的无线音箱吧！\n","slug":"iOS-Airplay-中的-Airtunes-Server-服务协议和机制详解以及-Android-Demo-的实现","published":1,"updated":"2016-08-30T07:02:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnywa002xj4rbxj9wp7pu"},{"title":"Ubuntu下重置MySQL的root密码","date":"2014-12-12T02:10:45.000Z","author":"Sergio Chan","_content":"\nsudo vi /etc/mysql/my.cnf，在[mysqld]段中加入一行“skip-grant-tables”\n具体环境中可能my.cnf已经存在且在其他目录，记得要找到有效的my.cnf配置文件路径\n\nsudo service mysql restart，重启mySQL服务\n具体参考实际的重启MySQL的命令\n\nsudo mysql -u root -p mysql，用空密码进入mysql管理命令行\n\n(进入mysql,或者用use mysql指令)\n\nupdate user set password=PASSWORD(\"123\") where user='root';，把密码重置为123\n\n(注意，如果是表中没有的用户名，使用insert)\n\nquit，退出数据库管理\n\nsudo vim /etc/mysql/my.cnf，把刚才加入的那一行“skip-grant-tables”注释或删除\n\nsudo service mysql restart，OK，搞定！","source":"_posts/Ubuntu下重置MySQL的root密码.md","raw":"title: Ubuntu下重置MySQL的root密码\ndate: 2014-12-12 10:10:45\ncategories: Linux服务器笔记\nauthor: Sergio Chan\ntags: [Ubuntu, MySQL]\n---\n\nsudo vi /etc/mysql/my.cnf，在[mysqld]段中加入一行“skip-grant-tables”\n具体环境中可能my.cnf已经存在且在其他目录，记得要找到有效的my.cnf配置文件路径\n\nsudo service mysql restart，重启mySQL服务\n具体参考实际的重启MySQL的命令\n\nsudo mysql -u root -p mysql，用空密码进入mysql管理命令行\n\n(进入mysql,或者用use mysql指令)\n\nupdate user set password=PASSWORD(\"123\") where user='root';，把密码重置为123\n\n(注意，如果是表中没有的用户名，使用insert)\n\nquit，退出数据库管理\n\nsudo vim /etc/mysql/my.cnf，把刚才加入的那一行“skip-grant-tables”注释或删除\n\nsudo service mysql restart，OK，搞定！","slug":"Ubuntu下重置MySQL的root密码","published":1,"updated":"2015-12-18T13:13:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnywh0035j4rbhu7ighqo"},{"title":"[UIColor colorWithRed: green: blue: alpha:] 的正确用法","date":"2015-02-02T13:37:10.000Z","author":"Sergio Chan","_content":"\n[UIColor colorWithRed: green: blue: alpha:] 颜色值范围都是在0.0~1.0之间的，并不是我们误认为的0~255。\n\n正确用法：\n\n```\n[UIColor colorWithRed:240.0/255 green:240.0/255 blue:240.0/255 alpha:1.0];\n```\n\n> colorWithRed:green:blue:alpha:\n> Creates and returns a color object using the specified opacity and RGB component values.\n> \n> Declaration\n> OBJECTIVE-C\n> + (UIColor *)colorWithRed:(CGFloat)red\n> green:(CGFloat)green\n> blue:(CGFloat)blue\n> alpha:(CGFloat)alpha\n> \n> Parameters\n> \n> red\n> \n> The red component of the color object, specified as a value from 0.0 to 1.0.\n> \n> green\n> \n> The green component of the color object, specified as a value from 0.0 to 1.0.\n> \n> blue\n> \n> The blue component of the color object, specified as a value from 0.0 to 1.0.\n> \n> alpha\n> \n> The opacity value of the color object, specified as a value from 0.0 to 1.0.\n> \n> Return Value\n> \n> The color object. The color information represented by this object is in the device RGB colorspace.\n> \n> Discussion\n> Values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0.\n> \n> Import Statement\n> Availability\n> Available in iOS 2.0 and later.\n\n","source":"_posts/UIColor-colorWithRed-green-blue-alpha-的正确用法.md","raw":"title: '[UIColor colorWithRed: green: blue: alpha:] 的正确用法'\ndate: 2015-2-2 21:37:10\ncategories: iOS菜鸟心得\nauthor: Sergio Chan\ntags: [UIColor]\n---\n\n[UIColor colorWithRed: green: blue: alpha:] 颜色值范围都是在0.0~1.0之间的，并不是我们误认为的0~255。\n\n正确用法：\n\n```\n[UIColor colorWithRed:240.0/255 green:240.0/255 blue:240.0/255 alpha:1.0];\n```\n\n> colorWithRed:green:blue:alpha:\n> Creates and returns a color object using the specified opacity and RGB component values.\n> \n> Declaration\n> OBJECTIVE-C\n> + (UIColor *)colorWithRed:(CGFloat)red\n> green:(CGFloat)green\n> blue:(CGFloat)blue\n> alpha:(CGFloat)alpha\n> \n> Parameters\n> \n> red\n> \n> The red component of the color object, specified as a value from 0.0 to 1.0.\n> \n> green\n> \n> The green component of the color object, specified as a value from 0.0 to 1.0.\n> \n> blue\n> \n> The blue component of the color object, specified as a value from 0.0 to 1.0.\n> \n> alpha\n> \n> The opacity value of the color object, specified as a value from 0.0 to 1.0.\n> \n> Return Value\n> \n> The color object. The color information represented by this object is in the device RGB colorspace.\n> \n> Discussion\n> Values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0.\n> \n> Import Statement\n> Availability\n> Available in iOS 2.0 and later.\n\n","slug":"UIColor-colorWithRed-green-blue-alpha-的正确用法","published":1,"updated":"2015-12-18T13:13:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnywm003cj4rbcfqv1ual"},{"title":"Python利用深度优先搜索解数独程序的实现","date":"2015-05-19T13:30:29.000Z","author":"Sergio Chan","_content":"\n\n> 本文附带项目Github仓库地址，随手star是个好习惯：\n> [https://github.com/SergioChan/Python-Sudoku](https://github.com/SergioChan/Python-Sudoku)\n\n前两天吃饭的时候听到旁边一桌估计是搜狐或者网易的程序猿在说要是新员工给我面试我就让他写个解数独的Python程序，他二十分钟就能连伪代码加实现一起搞定……我上网一看，解数独这个问题确实挺有趣的，主要是纯凭自己好像很偶尔才能解出一个数独来的样子，于是根据以前学的数据结构的基础和最近新学的Python功底，小试牛刀一下，就使用最简单的回溯方法来实现，我知道百度上其实挺多的，但是说实话那些乱七八糟的代码我也看不太懂，自己想自己写可能思路属于自己，会比较清晰吧。回溯搜索是深度优先搜索（DFS）的一种\n对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。\n“芬兰数学家因卡拉，花费3个月时间设计出的世界上迄今难度最大的数独游戏，而且它只有一个答案。因卡拉说只有思考能力最快、头脑最聪明的人才能破解这个游戏。”这是英国《每日邮报》2012年6月30日的一篇报道。我接下来就会用这个数独来做示范，说明利用回溯解决这个问题的思路。\n\n![image](/image/sodoku.png)\n\n解决数独的关键思想在于找到一个入口点，将解决树一层层撸下去，遇到无法继续生长下去的结点，就往上回溯，回溯之后从上一个结点的其他分支继续往下走，如果没有其他分支则继续往上回溯。\n先将整个数独矩阵用二维数组存储：\n\n```\nproblem = \\\n    [\n        [8,0,0,0,0,0,0,0,0],\n        [0,0,3,6,0,0,0,0,0],\n        [0,7,0,0,9,0,2,0,0],\n        [0,5,0,0,0,7,0,0,0],\n        [0,0,0,0,4,5,7,0,0],\n        [0,0,0,1,0,0,0,3,0],\n        [0,0,1,0,0,0,0,6,8],\n        [0,0,8,5,0,0,0,1,0],\n        [0,9,0,0,0,0,4,0,0]\n]\n```\n\n之后，在解的过程中，由于需要回溯，所以需要把经历过的节点记录下来，我并不知道有没有更好的处理方式，这里用的是栈的存储方式，将经历过的节点存储在solutionStack中，当需要回溯的时候，直接pop掉栈顶的solution，如果解完了，则栈顶就是最后的结果。当经历了一个新的分支，在矩阵中添加了一个新的值，则随之产生一个新的节点，压入栈中。\n然后，每个节点的数据并不只限于当前的矩阵状态（我其实觉得这里换成一个节点的数据结构会比较好），还包括矩阵中每个点可能的分支，这个栈的压入和弹出是和solutionStack同步的。每当进入新的分支，都需要将这个节点的可能解中修改过的值去掉，这样在往下走并且回溯的时候，就可以回到这个节点的修改后的可能解情况，即刚刚走过的那个分支不会再重复走一遍。\n主方法：\n\n```\nimport time\nimport copy\ndef resolve(problem):\n    solutionStack = [problem]\n    tmp = get_solution_array(problem)\n    solutionArrayStack = [tmp]\n    # problem = [[0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0]]\n    while 1:\n        # fetch the last solution in solution stack\n        next_item_cord = {}\n        solutionArray = []\n        # print 'still ',len(solutionStack),'in stack'\n        solutionNow = copy.deepcopy(solutionStack[len(solutionStack)-1])\n        solutionArray = solutionArrayStack[len(solutionArrayStack)-1]\n\n        flag = check_if_need_to_back(solutionNow,solutionArray)\n        if flag is True:\n            # print 'pop!'\n            solutionArrayStack.pop()\n            solutionStack.pop()\n        else:\n\n            next_item_cord = get_first_possible_item(solutionArray)\n            if next_item_cord == False:\n                break\n            # print 'next_item_cord:',next_item_cord\n            next_item_array = solutionArray[next_item_cord['x']][next_item_cord['y']]\n            solutionNow[next_item_cord['x']][next_item_cord['y']]=next_item_array[0]\n\n            solutionArray_tmp = get_solution_array(solutionNow)\n            if solutionArray[next_item_cord['x']][next_item_cord['y']].count(solutionNow[next_item_cord['x']][next_item_cord['y']])>0:\n                solutionArray[next_item_cord['x']][next_item_cord['y']].remove(solutionNow[next_item_cord['x']][next_item_cord['y']])\n            solutionStack.append(solutionNow)\n            solutionArrayStack.append(solutionArray_tmp)\n    for i in range(0,9,1):\n            print solutionStack[len(solutionStack)-1][i]\n```\n\n在开始循环之前，需要先获得初始状态的分支情况，因此独立的获取分支状况的方法如下：\n\n```\ndef get_solution_array(problem):\n    startTime=time.time()\n    tmp = []\n    for i in range(0,9,1):\n        tmp_line_array = []\n        for j in range(0,9,1):\n            # print '['+bytes(i)+','+bytes(j)+']: '+ bytes(problem[i][j])\n            if problem[i][j]==0:\n                # no value, get possible value array\n                tmp_value = [1,2,3,4,5,6,7,8,9]\n\n                # remove the existed value in line\n                for tmp_j in range(0,9,1):\n                    if problem[i][tmp_j]!=0:\n                        if problem[i][tmp_j] in tmp_value:\n                            tmp_value.remove(problem[i][tmp_j])\n\n                # remove the existed value in column\n                for tmp_i in range(0,9,1):\n                    if problem[tmp_i][j]!=0:\n                        if problem[tmp_i][j] in tmp_value:\n                            tmp_value.remove(problem[tmp_i][j])\n\n                # remove the existed value in the rectangle\n                for x in range(i/3*3,i/3*3+3):\n                    for y in range(j/3*3,j/3*3+3):\n                        if problem[x][y]!=0:\n                            if problem[x][y] in tmp_value:\n                                tmp_value.remove(problem[x][y])\n\n                tmp_line_array.append(tmp_value)\n            else:\n                tmp_line_array.append([])\n        tmp.append(tmp_line_array)\n        #print tmp_line_array\n    # print tmp\n    endTime=time.time()\n    print \"get_solution_array! Time consuming: \" + \"%.4f\" % (endTime-startTime) + \" Seconds\"\n    return tmp\n```\n\n这里需要说一点，其实每次压栈的时候节点状态做局部更新就好了，这样会减少很大的计算量，这个优化会在之后进行。每次到了新节点都要寻找下一个修改的坐标，这里就寻找的是下一个可能解最少的元素作为下一个节点。\n\n```\ndef get_first_possible_item(solution_array):\n    startTime=time.time()\n    is_finished = True\n    shortest_item_length = 9\n    shortest_item_x = 0\n    shortest_item_y = 0\n    for i in range(0,9,1):\n        for j in range(0,9,1):\n            tmp_length = len(solution_array[i][j])\n            if tmp_length!=0:\n                is_finished = False\n                if tmp_length<shortest_item_length:\n                    shortest_item_length = tmp_length\n                    shortest_item_x = i\n                    shortest_item_y = j\n\n    # print 'shortest item is:',shortest_item_length,shortest_item_x,shortest_item_y\n    endTime=time.time()\n    print \"get_first_possible_item! Time consuming: \" + \"%.4f\" % (endTime-startTime) + \" Seconds\"\n    if is_finished:\n        return False\n    else:\n        return {'x':shortest_item_x,'y':shortest_item_y}\n```\n\n补充一个判断是否需要回溯的方法：\n\n```\ndef check_if_need_to_back(solutionNow,solutionArray):\n    for i in range(0,9,1):\n        for j in range(0,9,1):\n            if len(solutionArray[i][j]) == 0 and solutionNow[i][j] == 0:\n                return True\n    return False\n```\n\n最后的输出：\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\nFinished! Time consuming: 5.2055 Seconds\n```\n\n这里的一处细节是最后的运行时间是5.2055秒，这相对于其他人的实现方式慢了一些，我在get_solution_array中用来判断所获取的值是否在可能解的候选数组中的时候，之前用的是list.count(object)这个方法来判断，后来改成了in，事实证明如果使用.count的话总消耗大概在5.6秒左右，会比in多出0.4S。\n\n恩。我改成局部更新数据了。新的获取可能解的方法：\n\n```\ndef get_resolution_array_new(solutionArray,x,y,value):\n    for tmp_j in range(0,9,1):\n        if value in solutionArray[x][tmp_j]:\n            solutionArray[x][tmp_j].remove(value)\n    for tmp_i in range(0,9,1):\n        if value in solutionArray[tmp_i][y]:\n            solutionArray[tmp_i][y].remove(value)\n    for tmp_i in range(x/3*3,x/3*3+3):\n        for tmp_j in range(y/3*3,y/3*3+3):\n            if value in solutionArray[tmp_i][tmp_j]:\n                solutionArray[tmp_i][tmp_j].remove(value)\n    return solutionArray\n```\n\n将主方法中38行代码改为：\n\n```\nsolutionArray_tmp = copy.deepcopy(solutionArray)\nsolutionArray_tmp = get_resolution_array_new(solutionArray_tmp,next_item_cord['x'],next_item_cord['y'],next_item_array[0])\n```\n\n最后的结果如下……也不咋地嘛，只是快了0.4S……看来还有优化空间吧\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\nFinished! Time consuming: 4.8577 Seconds\n```\n\n-->继续补充\n早上起来想了想又监控了一下，发现最主要耗时的还是在走的分支数量上，如果按照每次往下都默认走最左边的分支，那么前进会操作12000多次，回溯也差不多这个数，这是导致时间增大的主要原因。我没有想好如何在几个分支要选择的时候选择最优分支……毕竟我觉得去选择最优分支也要消耗时间，考虑太多意义不大……于是我就简单的尝试了一下随机分支，当程序运行到一个节点需要继续往下分支的时候随机选择一个分支，随机就用的最简单的随机方法，结果效果惊人，最快的时候可以达到：\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\nFinished! Time consuming: 1.8991 Seconds\n```\n\n当然由于采用了随机，所以时间并不稳定……在这种最优解的情况下只要前进5000次就能到达最终解。如何有一个稳定的最优算法也许永远会是个谜吧。\n随机选择分支的代码如下：\n\n```\nnext_item_array = solutionArray[next_item_cord['x']][next_item_cord['y']]\n                next_item = next_item_array[randint(0,len(next_item_array)-1)]\n                solutionNow[next_item_cord['x']][next_item_cord['y']] = next_item\n\n                # solutionArray_tmp = get_solution_array(solutionNow)\n                solutionArray_tmp = copy.deepcopy(solutionArray)\n                solutionArray_tmp = self.get_resolution_array_new(solutionArray_tmp, next_item_cord['x'], next_item_cord['y'],\n                                                             next_item)\n                if next_item in solutionArray[next_item_cord['x']][next_item_cord['y']]:\n                    solutionArray[next_item_cord['x']][next_item_cord['y']].remove(\n                        next_item)\n```\n\n-->又找出一个问题\n在获取下一个最优节点的过程中，没有算上当前矩阵中的那个值，所以会导致一个点连续的用了两次，最后可能还要回溯，所以修改了一下代码后，效率继续提升：\n\n```\ndef get_first_possible_item(self, solution_array, solutionNow = None):\n        is_finished = True\n        shortest_item_length = 9\n        shortest_item_x = 0\n        shortest_item_y = 0\n        for i in range(0, 9, 1):\n            for j in range(0, 9, 1):\n                tmp_length = len(solution_array[i][j])\n                if tmp_length != 0:\n                    is_finished = False\n                    if solutionNow[i][j] != 0:\n                        tmp_length += 1\n                    if tmp_length < shortest_item_length:\n                        shortest_item_length = tmp_length\n                        shortest_item_x = i\n                        shortest_item_y = j\n\n        # print 'shortest item is:',shortest_item_length,shortest_item_x,shortest_item_y\n        if is_finished:\n            return False\n        else:\n            return {'x': shortest_item_x, 'y': shortest_item_y}\n```\n\n在这种情况下，如果不用随机选择节点的方法，前进的次数稳定在9100次左右，比之前少了3000次左右，因此速度也提升到了3.6S，比4.8S提升了1.2S左右，变化显著。然后，尝试了一下随机选择节点的方式，目前计算出的最优解精确的是4142次，耗时1.6262S。另外，如何选择最优节点，继续减少解的路径应该是最终的优化办法了吧……\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\ntotal forward: 4142\nFinished! Time consuming: 1.6262 Seconds\n```","source":"_posts/Python利用深度优先搜索解数独程序的实现.md","raw":"title: Python利用深度优先搜索解数独程序的实现\ndate: 2015-5-19 21:30:29\ncategories: Python学习\nauthor: Sergio Chan\ntags: [python, python数独， 深度优先搜索]\n---\n\n\n> 本文附带项目Github仓库地址，随手star是个好习惯：\n> [https://github.com/SergioChan/Python-Sudoku](https://github.com/SergioChan/Python-Sudoku)\n\n前两天吃饭的时候听到旁边一桌估计是搜狐或者网易的程序猿在说要是新员工给我面试我就让他写个解数独的Python程序，他二十分钟就能连伪代码加实现一起搞定……我上网一看，解数独这个问题确实挺有趣的，主要是纯凭自己好像很偶尔才能解出一个数独来的样子，于是根据以前学的数据结构的基础和最近新学的Python功底，小试牛刀一下，就使用最简单的回溯方法来实现，我知道百度上其实挺多的，但是说实话那些乱七八糟的代码我也看不太懂，自己想自己写可能思路属于自己，会比较清晰吧。回溯搜索是深度优先搜索（DFS）的一种\n对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。\n“芬兰数学家因卡拉，花费3个月时间设计出的世界上迄今难度最大的数独游戏，而且它只有一个答案。因卡拉说只有思考能力最快、头脑最聪明的人才能破解这个游戏。”这是英国《每日邮报》2012年6月30日的一篇报道。我接下来就会用这个数独来做示范，说明利用回溯解决这个问题的思路。\n\n![image](/image/sodoku.png)\n\n解决数独的关键思想在于找到一个入口点，将解决树一层层撸下去，遇到无法继续生长下去的结点，就往上回溯，回溯之后从上一个结点的其他分支继续往下走，如果没有其他分支则继续往上回溯。\n先将整个数独矩阵用二维数组存储：\n\n```\nproblem = \\\n    [\n        [8,0,0,0,0,0,0,0,0],\n        [0,0,3,6,0,0,0,0,0],\n        [0,7,0,0,9,0,2,0,0],\n        [0,5,0,0,0,7,0,0,0],\n        [0,0,0,0,4,5,7,0,0],\n        [0,0,0,1,0,0,0,3,0],\n        [0,0,1,0,0,0,0,6,8],\n        [0,0,8,5,0,0,0,1,0],\n        [0,9,0,0,0,0,4,0,0]\n]\n```\n\n之后，在解的过程中，由于需要回溯，所以需要把经历过的节点记录下来，我并不知道有没有更好的处理方式，这里用的是栈的存储方式，将经历过的节点存储在solutionStack中，当需要回溯的时候，直接pop掉栈顶的solution，如果解完了，则栈顶就是最后的结果。当经历了一个新的分支，在矩阵中添加了一个新的值，则随之产生一个新的节点，压入栈中。\n然后，每个节点的数据并不只限于当前的矩阵状态（我其实觉得这里换成一个节点的数据结构会比较好），还包括矩阵中每个点可能的分支，这个栈的压入和弹出是和solutionStack同步的。每当进入新的分支，都需要将这个节点的可能解中修改过的值去掉，这样在往下走并且回溯的时候，就可以回到这个节点的修改后的可能解情况，即刚刚走过的那个分支不会再重复走一遍。\n主方法：\n\n```\nimport time\nimport copy\ndef resolve(problem):\n    solutionStack = [problem]\n    tmp = get_solution_array(problem)\n    solutionArrayStack = [tmp]\n    # problem = [[0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0]]\n    while 1:\n        # fetch the last solution in solution stack\n        next_item_cord = {}\n        solutionArray = []\n        # print 'still ',len(solutionStack),'in stack'\n        solutionNow = copy.deepcopy(solutionStack[len(solutionStack)-1])\n        solutionArray = solutionArrayStack[len(solutionArrayStack)-1]\n\n        flag = check_if_need_to_back(solutionNow,solutionArray)\n        if flag is True:\n            # print 'pop!'\n            solutionArrayStack.pop()\n            solutionStack.pop()\n        else:\n\n            next_item_cord = get_first_possible_item(solutionArray)\n            if next_item_cord == False:\n                break\n            # print 'next_item_cord:',next_item_cord\n            next_item_array = solutionArray[next_item_cord['x']][next_item_cord['y']]\n            solutionNow[next_item_cord['x']][next_item_cord['y']]=next_item_array[0]\n\n            solutionArray_tmp = get_solution_array(solutionNow)\n            if solutionArray[next_item_cord['x']][next_item_cord['y']].count(solutionNow[next_item_cord['x']][next_item_cord['y']])>0:\n                solutionArray[next_item_cord['x']][next_item_cord['y']].remove(solutionNow[next_item_cord['x']][next_item_cord['y']])\n            solutionStack.append(solutionNow)\n            solutionArrayStack.append(solutionArray_tmp)\n    for i in range(0,9,1):\n            print solutionStack[len(solutionStack)-1][i]\n```\n\n在开始循环之前，需要先获得初始状态的分支情况，因此独立的获取分支状况的方法如下：\n\n```\ndef get_solution_array(problem):\n    startTime=time.time()\n    tmp = []\n    for i in range(0,9,1):\n        tmp_line_array = []\n        for j in range(0,9,1):\n            # print '['+bytes(i)+','+bytes(j)+']: '+ bytes(problem[i][j])\n            if problem[i][j]==0:\n                # no value, get possible value array\n                tmp_value = [1,2,3,4,5,6,7,8,9]\n\n                # remove the existed value in line\n                for tmp_j in range(0,9,1):\n                    if problem[i][tmp_j]!=0:\n                        if problem[i][tmp_j] in tmp_value:\n                            tmp_value.remove(problem[i][tmp_j])\n\n                # remove the existed value in column\n                for tmp_i in range(0,9,1):\n                    if problem[tmp_i][j]!=0:\n                        if problem[tmp_i][j] in tmp_value:\n                            tmp_value.remove(problem[tmp_i][j])\n\n                # remove the existed value in the rectangle\n                for x in range(i/3*3,i/3*3+3):\n                    for y in range(j/3*3,j/3*3+3):\n                        if problem[x][y]!=0:\n                            if problem[x][y] in tmp_value:\n                                tmp_value.remove(problem[x][y])\n\n                tmp_line_array.append(tmp_value)\n            else:\n                tmp_line_array.append([])\n        tmp.append(tmp_line_array)\n        #print tmp_line_array\n    # print tmp\n    endTime=time.time()\n    print \"get_solution_array! Time consuming: \" + \"%.4f\" % (endTime-startTime) + \" Seconds\"\n    return tmp\n```\n\n这里需要说一点，其实每次压栈的时候节点状态做局部更新就好了，这样会减少很大的计算量，这个优化会在之后进行。每次到了新节点都要寻找下一个修改的坐标，这里就寻找的是下一个可能解最少的元素作为下一个节点。\n\n```\ndef get_first_possible_item(solution_array):\n    startTime=time.time()\n    is_finished = True\n    shortest_item_length = 9\n    shortest_item_x = 0\n    shortest_item_y = 0\n    for i in range(0,9,1):\n        for j in range(0,9,1):\n            tmp_length = len(solution_array[i][j])\n            if tmp_length!=0:\n                is_finished = False\n                if tmp_length<shortest_item_length:\n                    shortest_item_length = tmp_length\n                    shortest_item_x = i\n                    shortest_item_y = j\n\n    # print 'shortest item is:',shortest_item_length,shortest_item_x,shortest_item_y\n    endTime=time.time()\n    print \"get_first_possible_item! Time consuming: \" + \"%.4f\" % (endTime-startTime) + \" Seconds\"\n    if is_finished:\n        return False\n    else:\n        return {'x':shortest_item_x,'y':shortest_item_y}\n```\n\n补充一个判断是否需要回溯的方法：\n\n```\ndef check_if_need_to_back(solutionNow,solutionArray):\n    for i in range(0,9,1):\n        for j in range(0,9,1):\n            if len(solutionArray[i][j]) == 0 and solutionNow[i][j] == 0:\n                return True\n    return False\n```\n\n最后的输出：\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\nFinished! Time consuming: 5.2055 Seconds\n```\n\n这里的一处细节是最后的运行时间是5.2055秒，这相对于其他人的实现方式慢了一些，我在get_solution_array中用来判断所获取的值是否在可能解的候选数组中的时候，之前用的是list.count(object)这个方法来判断，后来改成了in，事实证明如果使用.count的话总消耗大概在5.6秒左右，会比in多出0.4S。\n\n恩。我改成局部更新数据了。新的获取可能解的方法：\n\n```\ndef get_resolution_array_new(solutionArray,x,y,value):\n    for tmp_j in range(0,9,1):\n        if value in solutionArray[x][tmp_j]:\n            solutionArray[x][tmp_j].remove(value)\n    for tmp_i in range(0,9,1):\n        if value in solutionArray[tmp_i][y]:\n            solutionArray[tmp_i][y].remove(value)\n    for tmp_i in range(x/3*3,x/3*3+3):\n        for tmp_j in range(y/3*3,y/3*3+3):\n            if value in solutionArray[tmp_i][tmp_j]:\n                solutionArray[tmp_i][tmp_j].remove(value)\n    return solutionArray\n```\n\n将主方法中38行代码改为：\n\n```\nsolutionArray_tmp = copy.deepcopy(solutionArray)\nsolutionArray_tmp = get_resolution_array_new(solutionArray_tmp,next_item_cord['x'],next_item_cord['y'],next_item_array[0])\n```\n\n最后的结果如下……也不咋地嘛，只是快了0.4S……看来还有优化空间吧\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\nFinished! Time consuming: 4.8577 Seconds\n```\n\n-->继续补充\n早上起来想了想又监控了一下，发现最主要耗时的还是在走的分支数量上，如果按照每次往下都默认走最左边的分支，那么前进会操作12000多次，回溯也差不多这个数，这是导致时间增大的主要原因。我没有想好如何在几个分支要选择的时候选择最优分支……毕竟我觉得去选择最优分支也要消耗时间，考虑太多意义不大……于是我就简单的尝试了一下随机分支，当程序运行到一个节点需要继续往下分支的时候随机选择一个分支，随机就用的最简单的随机方法，结果效果惊人，最快的时候可以达到：\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\nFinished! Time consuming: 1.8991 Seconds\n```\n\n当然由于采用了随机，所以时间并不稳定……在这种最优解的情况下只要前进5000次就能到达最终解。如何有一个稳定的最优算法也许永远会是个谜吧。\n随机选择分支的代码如下：\n\n```\nnext_item_array = solutionArray[next_item_cord['x']][next_item_cord['y']]\n                next_item = next_item_array[randint(0,len(next_item_array)-1)]\n                solutionNow[next_item_cord['x']][next_item_cord['y']] = next_item\n\n                # solutionArray_tmp = get_solution_array(solutionNow)\n                solutionArray_tmp = copy.deepcopy(solutionArray)\n                solutionArray_tmp = self.get_resolution_array_new(solutionArray_tmp, next_item_cord['x'], next_item_cord['y'],\n                                                             next_item)\n                if next_item in solutionArray[next_item_cord['x']][next_item_cord['y']]:\n                    solutionArray[next_item_cord['x']][next_item_cord['y']].remove(\n                        next_item)\n```\n\n-->又找出一个问题\n在获取下一个最优节点的过程中，没有算上当前矩阵中的那个值，所以会导致一个点连续的用了两次，最后可能还要回溯，所以修改了一下代码后，效率继续提升：\n\n```\ndef get_first_possible_item(self, solution_array, solutionNow = None):\n        is_finished = True\n        shortest_item_length = 9\n        shortest_item_x = 0\n        shortest_item_y = 0\n        for i in range(0, 9, 1):\n            for j in range(0, 9, 1):\n                tmp_length = len(solution_array[i][j])\n                if tmp_length != 0:\n                    is_finished = False\n                    if solutionNow[i][j] != 0:\n                        tmp_length += 1\n                    if tmp_length < shortest_item_length:\n                        shortest_item_length = tmp_length\n                        shortest_item_x = i\n                        shortest_item_y = j\n\n        # print 'shortest item is:',shortest_item_length,shortest_item_x,shortest_item_y\n        if is_finished:\n            return False\n        else:\n            return {'x': shortest_item_x, 'y': shortest_item_y}\n```\n\n在这种情况下，如果不用随机选择节点的方法，前进的次数稳定在9100次左右，比之前少了3000次左右，因此速度也提升到了3.6S，比4.8S提升了1.2S左右，变化显著。然后，尝试了一下随机选择节点的方式，目前计算出的最优解精确的是4142次，耗时1.6262S。另外，如何选择最优节点，继续减少解的路径应该是最终的优化办法了吧……\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\ntotal forward: 4142\nFinished! Time consuming: 1.6262 Seconds\n```","slug":"Python利用深度优先搜索解数独程序的实现","published":1,"updated":"2016-02-09T02:26:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnywp003gj4rbx8jp7edv"},{"title":"PHP图片处理 透明水印的处理和添加","date":"2014-12-26T01:11:25.000Z","_content":"\n最近玩了下PHP的图片处理，实现了一个给图片添加水印或者是重叠两张图片的功能，把自己的解决过程记录下来。\n首先我需要将图片resize到640*480的尺寸，重绘的代码如下：\n\n```\n$thumb = imagecreatetruecolor($newwidth, $newheight);\n$source = imagecreatefromjpeg($filename);\nimagecopyresampled($thumb, $source, 0, 0, 0, 0, $newwidth, $newheight, $width, $height);\nimagejpeg($thumb, $filename);\n```\n\n在这段重绘的代码里，包含了几个很基本的东西：\n\n第一个是imagecreatetruecolor和imagecreate\n用imagecreatetruecolor(int x,int y)建立的是一幅大小为x和y的黑色图像(默认为黑色)，如想改变背景颜色则需要用填充颜色函数imagefill($img,0,0,$color)，imagecreate 新建一个空白图像资源，用imagecolorAllocate()添加背景色：\n\n```\n$img = imagecreatetruecolor(100,100);\n$color = imagecolorAllocate($img,200,200,200);\nimagefill($img,0,0,$color);\nheader('content-type:image/jpeg');\nimagejpeg($img);\n$img = imagecreate(100,100);\n$color = imagecolorallocate($img,200,200,200);\nheader('content-type:image/jpeg');\nimagejpeg($img);\n```\n\n第二个是imagecreatefromjpeg，这个是从图片文件创建一个新图像。\n支持下面这些格式的图片文件。\n\n```\nfunction imagecreatefrompng ($filename) {}\nfunction imagecreatefromgif ($filename) {}\nfunction imagecreatefromjpeg ($filename) {}\nfunction imagecreatefromwbmp ($filename) {}\nfunction imagecreatefromxbm ($filename) {}\nfunction imagecreatefromxpm ($filename) {}\nfunction imagecreatefromgd ($filename) {}\nfunction imagecreatefromgd2 ($filename) {}\n```\n\n第三个是imagecopyresampled，这个函数在裁剪，缩放图像时都特别有用：\n\n```\n/**\n* (PHP 4 &gt;= 4.0.6, PHP 5)\n* Copy and resize part of an image with resampling\n* @link http://php.net/manual/en/function.imagecopyresampled.php\n* @param resource $dst_image\n* @param resource $src_image\n* @param int $dst_x\n* x-coordinate of destination point.\n*\n* @param int $dst_y\n* y-coordinate of destination point.\n*\n* @param int $src_x\n* x-coordinate of source point.\n*\n* @param int $src_y\n* y-coordinate of source point.\n*\n* @param int $dst_w\n* Destination width.\n*\n* @param int $dst_h\n* Destination height.\n*\n* @param int $src_w\n* Source width.\n*\n* @param int $src_h\n* Source height.\n*\n* @return bool true on success or false on failure.\n*/\nfunction imagecopyresampled ($dst_image, $src_image, $dst_x, $dst_y, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h) {}\n```\n\n第四个是imagejpeg，这个函数如果不提供第二个filename的参数，会将图片文件直接输出出来，加上了这个参数就会按照方法名里的文件格式输出到文件中去。返回的是BOOL值。\n\n接下去就是加上水印的这个函数了，我添加了一个newwidth的参数，是希望在进入这个函数前计算出需要的水印大小，传入函数，这样生成的水印大小就会不一样了，可以根据不同的需要变化。\n\n```\nfunction mark_pic($background, $waterpic, $x, $y, $new_width)\n{\n$back = imagecreatefromjpeg($background);\n$water = imagecreatefrompng($waterpic);\n$w_w = imagesx($water);\n$w_h = imagesy($water);\nimagesavealpha($water, true);\nif ($new_width != $w_w)\n{\n$new_height = $w_h * ($new_width / $w_w);\n$thumb = imagecreatetruecolor($new_width, $new_height);\n$c = imagecolorallocatealpha($thumb, 0, 0, 0, 127);\n//拾取一个完全透明的颜色\nimagealphablending($thumb, false);\n//关闭混合模式，以便透明颜色能覆盖原画布\nimagefill($thumb, 0, 0, $c); //填充\nimagesavealpha($thumb, true); //设置保存PNG时保留透明通道信息\nimagecopyresampled($thumb, $water, 0, 0, 0, 0, $new_width, $new_height, $w_w, $w_h);\nimagepng($thumb, $waterpic);\nimagedestroy($water);\n$water = imagecreatefrompng($waterpic);\n$w_w = imagesx($water);\n$w_h = imagesy($water);\n}\n$b_w = imagesx($back);\n$b_h = imagesy($back);\nimagecopy($back, $water, $x, $y - $w_h , 0, 0, $w_w, $w_h);\nimagejpeg($back, \"./files/test.jpg\");\nimagedestroy($back);\nimagedestroy($water);\n}\n```\n\n在这个函数里，最重要的一个事情其实在于重绘一个具有透明通道的图像。如果使用imagecreate，透明通道就会被消灭掉，因此我最后只能采用了以上的办法，通过imagecreatetruecolor，往上面覆盖一个完全透明的颜色，来保留图片的透明通道，这对于添加水印这个功能应该是至关重要的。\n","source":"_posts/PHP图片处理-透明水印的处理和添加.md","raw":"title: PHP图片处理 透明水印的处理和添加\ndate: 2014-12-26 9:11:25\ncategories: PHP大神养成\ntags: [PHP图片处理，水印]\n---\n\n最近玩了下PHP的图片处理，实现了一个给图片添加水印或者是重叠两张图片的功能，把自己的解决过程记录下来。\n首先我需要将图片resize到640*480的尺寸，重绘的代码如下：\n\n```\n$thumb = imagecreatetruecolor($newwidth, $newheight);\n$source = imagecreatefromjpeg($filename);\nimagecopyresampled($thumb, $source, 0, 0, 0, 0, $newwidth, $newheight, $width, $height);\nimagejpeg($thumb, $filename);\n```\n\n在这段重绘的代码里，包含了几个很基本的东西：\n\n第一个是imagecreatetruecolor和imagecreate\n用imagecreatetruecolor(int x,int y)建立的是一幅大小为x和y的黑色图像(默认为黑色)，如想改变背景颜色则需要用填充颜色函数imagefill($img,0,0,$color)，imagecreate 新建一个空白图像资源，用imagecolorAllocate()添加背景色：\n\n```\n$img = imagecreatetruecolor(100,100);\n$color = imagecolorAllocate($img,200,200,200);\nimagefill($img,0,0,$color);\nheader('content-type:image/jpeg');\nimagejpeg($img);\n$img = imagecreate(100,100);\n$color = imagecolorallocate($img,200,200,200);\nheader('content-type:image/jpeg');\nimagejpeg($img);\n```\n\n第二个是imagecreatefromjpeg，这个是从图片文件创建一个新图像。\n支持下面这些格式的图片文件。\n\n```\nfunction imagecreatefrompng ($filename) {}\nfunction imagecreatefromgif ($filename) {}\nfunction imagecreatefromjpeg ($filename) {}\nfunction imagecreatefromwbmp ($filename) {}\nfunction imagecreatefromxbm ($filename) {}\nfunction imagecreatefromxpm ($filename) {}\nfunction imagecreatefromgd ($filename) {}\nfunction imagecreatefromgd2 ($filename) {}\n```\n\n第三个是imagecopyresampled，这个函数在裁剪，缩放图像时都特别有用：\n\n```\n/**\n* (PHP 4 &gt;= 4.0.6, PHP 5)\n* Copy and resize part of an image with resampling\n* @link http://php.net/manual/en/function.imagecopyresampled.php\n* @param resource $dst_image\n* @param resource $src_image\n* @param int $dst_x\n* x-coordinate of destination point.\n*\n* @param int $dst_y\n* y-coordinate of destination point.\n*\n* @param int $src_x\n* x-coordinate of source point.\n*\n* @param int $src_y\n* y-coordinate of source point.\n*\n* @param int $dst_w\n* Destination width.\n*\n* @param int $dst_h\n* Destination height.\n*\n* @param int $src_w\n* Source width.\n*\n* @param int $src_h\n* Source height.\n*\n* @return bool true on success or false on failure.\n*/\nfunction imagecopyresampled ($dst_image, $src_image, $dst_x, $dst_y, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h) {}\n```\n\n第四个是imagejpeg，这个函数如果不提供第二个filename的参数，会将图片文件直接输出出来，加上了这个参数就会按照方法名里的文件格式输出到文件中去。返回的是BOOL值。\n\n接下去就是加上水印的这个函数了，我添加了一个newwidth的参数，是希望在进入这个函数前计算出需要的水印大小，传入函数，这样生成的水印大小就会不一样了，可以根据不同的需要变化。\n\n```\nfunction mark_pic($background, $waterpic, $x, $y, $new_width)\n{\n$back = imagecreatefromjpeg($background);\n$water = imagecreatefrompng($waterpic);\n$w_w = imagesx($water);\n$w_h = imagesy($water);\nimagesavealpha($water, true);\nif ($new_width != $w_w)\n{\n$new_height = $w_h * ($new_width / $w_w);\n$thumb = imagecreatetruecolor($new_width, $new_height);\n$c = imagecolorallocatealpha($thumb, 0, 0, 0, 127);\n//拾取一个完全透明的颜色\nimagealphablending($thumb, false);\n//关闭混合模式，以便透明颜色能覆盖原画布\nimagefill($thumb, 0, 0, $c); //填充\nimagesavealpha($thumb, true); //设置保存PNG时保留透明通道信息\nimagecopyresampled($thumb, $water, 0, 0, 0, 0, $new_width, $new_height, $w_w, $w_h);\nimagepng($thumb, $waterpic);\nimagedestroy($water);\n$water = imagecreatefrompng($waterpic);\n$w_w = imagesx($water);\n$w_h = imagesy($water);\n}\n$b_w = imagesx($back);\n$b_h = imagesy($back);\nimagecopy($back, $water, $x, $y - $w_h , 0, 0, $w_w, $w_h);\nimagejpeg($back, \"./files/test.jpg\");\nimagedestroy($back);\nimagedestroy($water);\n}\n```\n\n在这个函数里，最重要的一个事情其实在于重绘一个具有透明通道的图像。如果使用imagecreate，透明通道就会被消灭掉，因此我最后只能采用了以上的办法，通过imagecreatetruecolor，往上面覆盖一个完全透明的颜色，来保留图片的透明通道，这对于添加水印这个功能应该是至关重要的。\n","slug":"PHP图片处理-透明水印的处理和添加","published":1,"updated":"2016-08-19T07:10:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnywt003nj4rbcj8qmeec"},{"title":"Multi-Touch Bar UI 开发入门指南","date":"2016-11-02T11:03:05.000Z","_content":"\n### 大致\n\n当你学会如何在你的 NSViewController 中用代码去初始化 Multi-Touch Bar 之后，我们就需要开始了解如何深入的开发 Touch Bar 上的 UI 了。根据 Apple 内部的一个说法就是 Multi-Touch Bar 实际上是运行了一个 watchOS 来管理它的视图和逻辑，所以与此同时我们也可以看到苹果官方为 Multi-Touch Bar 提供的一套 UI 控件，总共包含下面这些控件，第一个就是 Touch Bar。\n\n![](https://ooo.0o0.ooo/2016/11/01/58181fbf140db.jpg)\n\n- Touch Bar Fixed Space\n- Touch Bar Flexible Space\n\n这两个是用于在 UI 上用来填充的空间，Touch Bar 默认的 UI 是从左到右，默认左右就是挨着的，如果你需要将两个按钮什么的分开一些，定义他们之间的间隔，你需要在他们中间塞 Space。\n\n- Touch Bar Popover\n\n\n- Touch Bar Group\n\n/// BarItem 的集合，可以一起受到约束和用户的 Customization。\n\n- Touch Bar Other Items Proxy\n\n/// 后面详细描述，这是和 Responder Chain 相关的一个控件，可以让响应链下层的 Touch Bar 和上层的 Touch Bar 一起显示。\n\n- Touch Bar Scrubber\n\n![https://ooo.0o0.ooo/2016/11/01/581837cc4601b.png](https://ooo.0o0.ooo/2016/11/01/581837cc4601b.png)\n\n/// 这是一个放进 NSCustomTouchBarItem 的 NSScrubber 对象。\n\n- Touch Bar Color Picker\n\n![](https://ooo.0o0.ooo/2016/11/01/5818386c45463.png)\n\n/// 一个 NSColorPickerTouchBarItem 对象。\n\n- Touch Bar Character Picker\n\n![](https://ooo.0o0.ooo/2016/11/01/581838cf69274.png)\n\n/// 一个  NSCandidateListTouchBarItem 对象。\n\n- Touch Bar Sharing Service Picker\n\n![](https://ooo.0o0.ooo/2016/11/01/5818393054d89.png)\n\n/// 一个 NSSharingServicePickerTouchBarItem 对象。\n\n这里的 Scrubber，Color Picker 和 Character Picker 这些控件就会有些陌生了，虽然看过苹果发布会的同学们对他们应该也陌生不到哪里去。这几个控件在当时发布会都有展示。分别是滑动图片或文字选择器，颜色选择器，Emoji 表情选择器以及分享选择器，他们都有自己相应的 Delegate 来处理事件。\n\n- Touch Bar Label\n- Touch Bar Button\n- Touch Bar Slider\n- Touch Bar Segmented Control\n- Touch Bar View\n\n最后的五项对于大家都比较好理解，都是一些 AppKit 中的控件在 Touch Bar 中的移植，对于事件的响应和 AppKit 做法相同。\n\n> 当你的 macOS 应用中包含了一些自带 Touch Bar 的控件的时候，例如 NSTextField，如果你没有自定义你的 Touch Bar，那么在 Touch Bar 上也会显示相应的控件。这是预设好的。\n\n### NSTouchBar\n\n你可以将 NSTouchBar 看成是一个 NSTouchBarItem 的数组。在运行的时候，对于不同的 NSResponder 对应的 Touch Bar 和这些 Touch Bar 所对应的 BarItem，都是用 Identifier 来标识的，尽量使用 reverse-DNS 方式的 Identifier，例如 `com.company-name.app-name.alphanumeric-ID`。\n\n> 这里插一句，为了接下来的说明：由于现在并没有见到过新的 MBP 真机，尚不清楚 Touch Bar 提供给用户的 Customization 是什么样的机制，不过大概也就和 Finder 的自定义类似？按照官方文档来说，应该是用户在运行的时候可以选择显示或删除哪些 BarItem 或者修改 BarItem 的排列顺序，这大概也就是为什么 Touch Bar 的 UI 是始终向左靠齐的吧。\n\nNSTouchBar 自身有一个 Identifier： **customizationIdentifier**，这是在运行时允许用户自定义 UI 的标识，如果不设置，用户就无法通过系统来自定义 Touch Bar 的 UI。\n\n**customizationAllowedItemIdentifiers**，一个数组，在这里面存放的 Identifier 对应的 BarItem 是允许在运行时被用户修改样式的。\n\n**customizationRequiredItemIdentifiers**，这个数组里面存放的是不能被移除，一定会加载的 BarItem 对应的 Identifier。\n\n**defaultItemIdentifiers**，这是 Touch Bar 默认显示的全部 BarItem，这个参数是**必须**被初始化的。在这里面声明的 Identifier 随后就会在 `-itemForIdentifier:` 这个 Delegate 方法中初始化成 BarItem。给予 BarItem 的 Identifier 必须保持**全局唯一**，系统有另外四个预留的 Identifier：\n\n- NSTouchBarItemIdentifierFixedSpaceSmall\n- NSTouchBarItemIdentifierFixedSpaceLarge\n- NSTouchBarItemIdentifierFlexibleSpace\n- NSTouchBarItemIdentifierOtherItemsProxy\n\n另外，NSTouchBar 还有一个只读的属性 **itemIdentifiers**，这个数组里包含的是运行时当前显示的 BarItem 对应的 Identifier，无论用户在运行的时候对 Touch Bar 做了何种的 Customization，你都可以通过这个属性获得当前的状态。\n\n#### 如何让一个 BarItem 在 Touch Bar 上居中显示？\n\n**principalItemIdentifier** 这个属性所对应的 BarItem 会在 Touch Bar **居中**，是所谓的最高优先级的 Item，如果有多层 Touch Bar 存在，也只会有最上层的 principalItem 显示出来。这里，官方文档中特别提到：\n\n> Do not hard-code spacing in an attempt to ensure an item is centered. If you want a group of items to appear centered in the Touch Bar, designate the group NSTouchBarItem as the principal item.\n>\n> 不要尝试通过添加 Space 的方法来让一个 Item 居中，如果你需要让一组 Item 居中，你可以用一个 BarItem Group 将他们包起来然后将整个 Group 设置为居中。\n\n#### NSTouchBarDelegate\n\n**delegate**，NSTouchBarDelegate 只有一个方法，那就是  \n\n```\n- (nullable NSTouchBarItem *)touchBar:(NSTouchBar *)touchBar makeItemForIdentifier:(NSTouchBarItemIdentifier)identifier;\n```\n\n这个方法就是初始化所有 BarItem 的地方。一般来说写法就是根据 Identifier 来初始化对应的 BarItem，像这样\n\n```\nif ([identifier isEqualToString:@\"...\"])\n{ \n\t...\n\treturn BarItem;\n}\n```\n\n### Layout & Nesting\n\n由于用户可以自定义需要显示的 Touch Bar 宽度，你定义好的 Touch Bar 宽度是可变的。所以苹果的建议是**在设计的时候不要按照确定的宽度来设计，而植入一些动态布局的方**案。如果你需要更宽的宽度，你可以使用 Popover，scrubber 或者 scroll view。\n\n在 Layout 的时候，响应链上层的 Touch Bar 是可以包含下层的 Touch Bar 的，上面在综述的时候提到过的 **Other Items Proxy** 就是用来实现这个功能的。只要你在初始化 Touch Bar 的时候为它的 defaultIdentifiers 加上 NSTouchBarItemIdentifierOtherItemsProxy，他就会在运行时**需要的时候在这个 Identifier 所在的位置**包含上来自下层的合适的 Touch Bar。这个**需要的时候**指的是下层的 NSResponder 调用 becomeFirstResponder 的时候。例如有一个 ViewController 自身带有一个 Touch Bar，而这个 ViewController 中带有一个 NSTextView，那么当点击这个 NSTextview ，也就是**响应链下层 NSResponder 调用 becomeFirstResponder** 的时候，Touch Bar 显示的是：\n\n![](https://ooo.0o0.ooo/2016/11/01/5818435fa4fdd.png)\n\n而如果焦点从 TexView 失去，则恢复成 ViewController 这一层的 Touch Bar：\n\n![](https://ooo.0o0.ooo/2016/11/01/58184323610b8.png)\n\n如果一个 Touch Bar 没有植入 NSTouchBarItemIdentifierOtherItemsProxy ，那么如果在响应链更底层出现了一个可以加载的 Touch Bar，那么上层的 Touch Bar 都会被隐藏。哦，并且 NSTouchBar 的 visible 属性是可以 KVO 的。\n\n#### Responder Chain Search\n\n所以 Touch Bar UI 的加载顺序和 UIView 的响应链类似，都是穿过整个响应链，从最底层开始向上寻找，如果遇到了 otherItemsProxy ， 则会将两者合并起来之后继续往上遍历，直到找到最上层，生成一个最后加载出来的 Touch Bar。\n\n> Touch bars 的加载是通过查找指定的遵循了 NSTouchBarProvider Protocol 的组件来完成的。按照从响应链上层往下的顺序依次是：\n>\n> - the application delegate\n> - the application object itself\n> - the main window’s window controller\n> - the main window’s delegate\n> - the main window itself\n> - the main window’s first responder\n> - the key window’s window controller\n> - the key window’s delegate\n> - the key window itself\n> - the key window’s first responder\n>\n> 如果上面这些对象是 NSResponder 或者 NSResponder 的子类，以该对象为起点的响应链也会被包括进来。例如 AppDelegate 原本是 NSObject，但是[在 iOS 上 AppDelegate 就是继承于 UIResponder](http://stackoverflow.com/questions/6893221/why-does-appdelegate-inherit-from-uiresponder) ，这是因为这样 AppDelegate 就可以成为整个响应链的最上层了。因此**如果我们将 AppDelegate 改为继承于 NSResponder** ，那么在 AppDelegate 层也可以加上一层 Touch Bar。 \n>\n> 例如在一个一般结构的应用中，这个响应链的查找顺序是这样的：\n>\n> - Application delegate\n> - Application\n> - key window controller\n> - key window delegate\n> - key window\n> - view controller (closest to root of window)\n> - view (closest to root of window)\n> - intermediate view controllers and views\n> - key window’s first responder’s view controller\n> - key window’s first responder\n\n#### Customization Boundary\n\n那么对于最后显示的 Touch Bar 来说，每个 Touch Bar 的 Customization 属性依然管用。如果是 A Bar包含了 B Bar，那么对于 B Bar 的 Customization 是不能超出 B Bar 的范围的。例如有：\n\n```\nbar.defaultItemIdentifiers =@[IdentifierA,IdentifierB, NSTouchBarItemIdentifierOtherItemsProxy,IdentifierC];\n```\n\n这个 Bar 假设为 A Bar，在他的下层有一个 B Bar，那么在 AB 同时显示的时候，如果对 B Bar 的 Item 进行 Customization，那么是不能移动 IdentifierA，IdentifierB 和 IdentifierC 的位置的。\n\n#### Visual Priority\n\n**视图优先级**。由于你所开发的 Touch Bar 在运行的时候有可能被用户修改宽度，因此如果你有一排 BarItem，他们会从右往左依次被挤掉，这时候如果右边有一些重要的 BarItem 存在，你就需要为不同的 BarItem 设置不同的视图优先级，这样即使宽度变化，在重新 Layout 的时候也会按照定义好的视图优先级排列 BarItem。\n\n系统提供了三种默认的枚举类型视图优先级，分别为 NSTouchBarItemPriorityHigh， NSTouchBarItemPriorityNormal 和 NSTouchBarItemPriorityLow，对应了 1000，0 和 -1000 的 float 类型的值，因此你也可以直接为 BarItem 设置 float 类型的优先级。\n\n### 用 Storyboard 来定义你的 Multi-Touch Bar\n\n讲了这么多，用代码生成 Touch Bar 多累啊，我们来看看如何用 Storyboard 来创建吧。\n\n![](https://ooo.0o0.ooo/2016/11/01/581844c5bc04f.jpg)\n\n方法很简单，直接往你的 ViewController 里面从右下角拖一个 Touch Bar 过来就行了。然后往里面添加控件，对于不同的控件，Delegate，Datasource 和控件的触发事件，都是用 Control-Drag 的方法将引用加到你的 .m 文件里去。\n\n### 各种控件的具体用法\n\n接下来该是一个个来讲控件了，也是大家在之后的开发中最实用的部分啦。\n\n#### NSColorPickerTouchBarItem\n\ncolorPicker 有三种初始化方法：\n\n- colorPickerWithIdentifier\n- textColorPickerWithIdentifier\n- strokeColorPickerWithIdentifier\n\n这三种方法的区别其实就是在按钮显示的图标上，一个是常规的颜色选择器，第二个代表的是字体颜色选择器，第三种初始化代表的是边框颜色选择器。初始化之后的逻辑都是一样的：\n\n```\ncolorPickerItem.target = self;\ncolorPickerItem.action = @selector(ColorAction:);\n```\n\n然后在 `ColorAction` 这个方法中获得选择到的颜色：\n\n```\n((NSColorPickerTouchBarItem *)sender).color\n```\n\n**@property colorList**\n\n你也可以通过修改 **colorList** 这个属性来自定义 Color Picker 能够选取的颜色列表。如果不设置这个属性，则默认显示的是系统的取色盘，各种颜色都有：\n\n![](https://ooo.0o0.ooo/2016/11/02/5819676729847.png)\n\n当给了一个 list 之后：\n\n```\ncolorPickerItem.colorList = [[NSColorList alloc] init];\n[colorPickerItem.colorList setColor:[NSColor redColor] forKey:@\"Red\"];\n[colorPickerItem.colorList setColor:[NSColor greenColor] forKey:@\"Green\"];\n[colorPickerItem.colorList setColor:[NSColor blueColor] forKey:@\"Blue\"];\n```\n\n显示的就是这样：\n\n![](https://ooo.0o0.ooo/2016/11/02/58196802031d6.png)\n\n#### NSSliderTouchBarItem\n\n初始化：\n\n```\nsliderTouchBarItem.slider.minValue = 0.0f;\nsliderTouchBarItem.slider.maxValue = 100.0f;\nsliderTouchBarItem.slider.continuous = YES;\nsliderTouchBarItem.target = self;\nsliderTouchBarItem.action = @selector(sliderChanged:);\nsliderTouchBarItem.label = @\"Slider\";\nsliderTouchBarItem.customizationLabel = @\"Slider\";\n```\n\n这里面的 action 会在 slider 的值每一次发生改变的时候调用。\n\n值得一提的是 SliderItem 还提供了两个 AccessoryView 的自定义空间，左右各一个，分别叫做 **minimumValueAccessory** 和 **maximumValueAccessory**，可以用 NSImage 来初始化他们：\n\n```\nNSSliderAccessory *minSliderAccessory = [NSSliderAccessory accessoryWithImage:image];\n```\n\n其他的自定义都是围绕着 NSSlider 做的了。\n\n#### NSScrubber\n\n这是一个为了 Touch Bar 而全新创建的控件，在发布会上有着重的展示。他需要单独的添加到一个 TouchBarItem 里去：\n\n```\nscrubber = [[NSScrubber alloc] initWithFrame:NSMakeRect(0, 0, 310, 30)];\n// Height should be 30 \nscrubber.delegate = self;   \nscrubber.dataSource = self; \n```\n\nNSScrubber 类似 UICollectionView ，也是有基于 ItemView 的复用机制的，你可以继承 NSScrubberItemView 来写你自己需要的 CustomItemView。然后在初始化之后需要为 ItemView 加上一个复用的标识：\n\n```\n[scrubber registerClass:[NSScrubberItemView class] forItemIdentifier:ScrubberItemIdentifier];\n```\n\n**@property showsAdditionalContentIndicators** \n\n代表的是当左右滑动还有更多内容的时候，在左右侧会显示一块渐变的蒙层，用来表示滑动还有更多内容，你可以选择是否显示。\n\n**@property selectedIndex** \n\n即当前选中的 ItemView 的 index，可以直接设置。\n\n**@property showsArrowButtons** \n\n代表的是是否显示左右移动的箭头按钮，如果显示的话你也可以点击左右箭头的按钮来滑动列表。\n\n**@property backgroundColor** \n\nNSScrubber 的背景颜色，显示在内容之后，如果 **backgroundView** 为空才会显示，同时也是只有 NSScrubberTextItemView 类型的 ItemView 才会显示出后面的背景颜色。\n\n**@property DataSource**\n\n```\n- (NSInteger)numberOfItemsForScrubber:(NSScrubber *)scrubber\n{\n\treturn 1;\n}\n\n- (NSScrubberItemView *)scrubber:(NSScrubber *)scrubber viewForItemAtIndex:(NSInteger)index\n{\n\tNSScrubberItemVie *itemView = [scrubber makeItemWithIdentifier:ScrubberItemIdentifier owner:nil];\n\treturn itemView;\n}\n```\n\n数据源加载比较简单，一个给 Item 的总数，另一个给 ItemView 就行，上面给出了最简单的示例。\n\n**@property Delegate**\n\nNSScrubber 有好几个 Delegate 可以调用，也都比较好理解，一般来说实现第一个选中回调就足够了：\n\n- didSelectItemAtIndex:(NSInteger)selectedIndex \n- didHighlightItemAtIndex:(NSInteger)highlightedIndex \n- didChangeVisibleRange:(NSRange)visibleRange\n- didBeginInteractingWithScrubber:(NSScrubber *)scrubber\n- didFinishInteractingWithScrubber:(NSScrubber *)scrubber\n- didCancelInteractingWithScrubber:(NSScrubber *)scrubber\n\n**@property mode**\n\n这个代表的是 NSScrubber 的滑动模式，一共就两种，**NSScrubberModeFree** 和 **NSScrubberModeFixed**。\n\nFree 模式下的 Scrubber 可以自由的滑动，但是你必须在**滑动之后再次单击 Item** 来选中，而 Fixed 模式下的 Scrubber 是不能自由滑动的，但是对于 ItemView 的选中是**跟随手指的拖动**的，不需要让手指离开 Touch Bar 再次点击选中。对于宽度固定，或者不需要用户再滑出范围的 Scrubber 可以使用 Fixed 模式。\n\n**@property SelectionStyle**\n\nScrubber 给选中样式提供了很方便的自定义属性，有 **selectionBackgroundStyle** 和 **selectionOverlayStyle**，同时也可以通过设置 **floatsSelectionViews** 为 YES 让选中 View 切换的时候可以加上从 A 点到 B 点流畅的移动动画，而不是从 A 点消失然后从 B 点出现这样的动画。\n\nselectionBackgroundStyle 和 selectionOverlayStyle 分别是选中的时候**背景**和**表面蒙层**的样式，只提供了 outlineOverlayStyle\n\n![](https://ooo.0o0.ooo/2016/11/02/5819b0f9959ad.png)\n\n和 roundedBackgroundStyle 两种默认样式：\n\n![](https://ooo.0o0.ooo/2016/11/02/5819b17f754fb.png)\n\n当然，这个 SelectionStyle 也是高度自定义的，但是你需要继承两个视图的基类来实现：\n\n1. 定义一个继承于 NSScrubberSelectionStyle 的 CustomStyle \n2. 重载 `-(nullable __kindof NSScrubberSelectionView *)makeSelectionView` 这个方法\n3. 定义一个继承于 NSScrubberSelectionView 的 CustomSelectionView\n4. 自定义 CustomSelectionView 的样式\n5. 在重载的方法中返回 CustomSelectionView\n\n**@property scrubberLayout**\n\n类似于 UICollectionView ，NSScrubber 的 layout 也是由 **NSScrubberLayout** 来控制的。系统提供了两种默认的 Layout，**NSScrubberFlowLayout** 和 **NSScrubberProportionalLayout**。前者可以通过 LayoutDelegate 来给出每一个 Item 所占的宽度，后者则不需要通过 delegate 而是直接将 Item 的宽度设置为 Scrubber 的可视区域按照 Item 的数量平分之后的宽度。你可以这样设置：\n\n```\nNSScrubberLayout *scrubberLayout;\nscrubberLayout = [[NSScrubberFlowLayout alloc] init];\n// or:\nscrubberLayout = [[NSScrubberProportionalLayout alloc] init];\nscrubber.scrubberLayout = scrubberLayout;\n```\n\n对于 NSScrubberFlowLayoutDelegate 你需要实现这一个方法：\n\n```\n- (NSSize)scrubber:(NSScrubber *)scrubber layout:(NSScrubberFlowLayout *)layout sizeForItemAtIndex:(NSInteger)itemIndex\n{\n    return NSMakeSize(width, 30);\n}\n```\n\n#### NSSharingServicePickerTouchBarItem\n\nNSSharingServicePickerTouchBarItem 的 delegate 只有一个委托方法需要实现：\n\n```\n- (NSArray *)itemsForSharingServicePickerTouchBarItem:(NSSharingServicePickerTouchBarItem *)pickerTouchBarItem\n{\n    return @[...];\n}\n```\n\n在这里返回的对象一定要是能够支持 NSPasteboardWriting 协议或者是继承于 NSItemProvider 的对象，例如文本，图片或者 NSURL，可以参考 [NSItemProvider 的官方文档](https://developer.apple.com/reference/foundation/nsitemprovider?language=objc)。然后就会在分享的时候传到分享的应用里去。\n\n#### NSPopoverTouchBarItem\n\n首先，我们来看如何自定义 Popover 在未点击状态下的显示 Button。\n\n- collapsedRepresentation 如果不为空，则显示一个自定义的 NSView，如果为空，则加载不为空的下面两个属性\n- collapsedRepresentationImage 给 Popover 的 button 添加一个 NSImage\n- collapsedRepresentationLabel 给 Popover 的 button 添加一个 **NSString**\n\nPopover 其实是在点击按钮之后弹出一个**新的 Touch Bar**，你需要再初始化一个新的 Touch Bar 并在同样的 Delegate 中返回对应的 BarItem，注意它和你之前的 Touch Bar 不是响应链上下层的关系，因此不会出现 Nesting 即上层的 Touch Bar 包含下层的 Touch Bar，而是完全覆盖了下面的 Touch Bar。如果你将新的 Touch Bar 赋值给了 **pressAndHoldTouchBar** 而不是 **popoverTouchBar**，你还可以实现按住按钮显示 Popover 且松开手指返回。\n\n#### Touch Bar Image Template\n\n最后还要为大家提供一个便利，苹果为了支持 Touch Bar 的开发，同时也为了统一设计样式，在 NSImage 中添加了非常多 Button 的模板图片，由于提供的模板太多了，不一一列出，就把列表附上，如果有同学开发的时候有需要可以去 NSImage 的头文件里面找，如果系统模板有的话可以直接使用。\n\n![](https://ooo.0o0.ooo/2016/11/02/5819c14c90072.png)\n\n### 最后\n\nTouch Bar 开发的新特性和坑肯定还有很多，现在新的 MBP 都还没发货，相信等更多的开发者开始真正开发上面的插件之后会有更丰富的经验和总结产生，我这篇博客也就是投石问路。然而，对 Touch Bar 十分感兴趣的我已经等不及开始研究它并且开始准备在上面做一些有意思的东西了！","source":"_posts/Multi-Touch-Bar-UI-开发入门指南.md","raw":"title: Multi-Touch Bar UI 开发入门指南\ndate: 2016-11-02 19:03:05\ntags: [Cocoa]\n---\n\n### 大致\n\n当你学会如何在你的 NSViewController 中用代码去初始化 Multi-Touch Bar 之后，我们就需要开始了解如何深入的开发 Touch Bar 上的 UI 了。根据 Apple 内部的一个说法就是 Multi-Touch Bar 实际上是运行了一个 watchOS 来管理它的视图和逻辑，所以与此同时我们也可以看到苹果官方为 Multi-Touch Bar 提供的一套 UI 控件，总共包含下面这些控件，第一个就是 Touch Bar。\n\n![](https://ooo.0o0.ooo/2016/11/01/58181fbf140db.jpg)\n\n- Touch Bar Fixed Space\n- Touch Bar Flexible Space\n\n这两个是用于在 UI 上用来填充的空间，Touch Bar 默认的 UI 是从左到右，默认左右就是挨着的，如果你需要将两个按钮什么的分开一些，定义他们之间的间隔，你需要在他们中间塞 Space。\n\n- Touch Bar Popover\n\n\n- Touch Bar Group\n\n/// BarItem 的集合，可以一起受到约束和用户的 Customization。\n\n- Touch Bar Other Items Proxy\n\n/// 后面详细描述，这是和 Responder Chain 相关的一个控件，可以让响应链下层的 Touch Bar 和上层的 Touch Bar 一起显示。\n\n- Touch Bar Scrubber\n\n![https://ooo.0o0.ooo/2016/11/01/581837cc4601b.png](https://ooo.0o0.ooo/2016/11/01/581837cc4601b.png)\n\n/// 这是一个放进 NSCustomTouchBarItem 的 NSScrubber 对象。\n\n- Touch Bar Color Picker\n\n![](https://ooo.0o0.ooo/2016/11/01/5818386c45463.png)\n\n/// 一个 NSColorPickerTouchBarItem 对象。\n\n- Touch Bar Character Picker\n\n![](https://ooo.0o0.ooo/2016/11/01/581838cf69274.png)\n\n/// 一个  NSCandidateListTouchBarItem 对象。\n\n- Touch Bar Sharing Service Picker\n\n![](https://ooo.0o0.ooo/2016/11/01/5818393054d89.png)\n\n/// 一个 NSSharingServicePickerTouchBarItem 对象。\n\n这里的 Scrubber，Color Picker 和 Character Picker 这些控件就会有些陌生了，虽然看过苹果发布会的同学们对他们应该也陌生不到哪里去。这几个控件在当时发布会都有展示。分别是滑动图片或文字选择器，颜色选择器，Emoji 表情选择器以及分享选择器，他们都有自己相应的 Delegate 来处理事件。\n\n- Touch Bar Label\n- Touch Bar Button\n- Touch Bar Slider\n- Touch Bar Segmented Control\n- Touch Bar View\n\n最后的五项对于大家都比较好理解，都是一些 AppKit 中的控件在 Touch Bar 中的移植，对于事件的响应和 AppKit 做法相同。\n\n> 当你的 macOS 应用中包含了一些自带 Touch Bar 的控件的时候，例如 NSTextField，如果你没有自定义你的 Touch Bar，那么在 Touch Bar 上也会显示相应的控件。这是预设好的。\n\n### NSTouchBar\n\n你可以将 NSTouchBar 看成是一个 NSTouchBarItem 的数组。在运行的时候，对于不同的 NSResponder 对应的 Touch Bar 和这些 Touch Bar 所对应的 BarItem，都是用 Identifier 来标识的，尽量使用 reverse-DNS 方式的 Identifier，例如 `com.company-name.app-name.alphanumeric-ID`。\n\n> 这里插一句，为了接下来的说明：由于现在并没有见到过新的 MBP 真机，尚不清楚 Touch Bar 提供给用户的 Customization 是什么样的机制，不过大概也就和 Finder 的自定义类似？按照官方文档来说，应该是用户在运行的时候可以选择显示或删除哪些 BarItem 或者修改 BarItem 的排列顺序，这大概也就是为什么 Touch Bar 的 UI 是始终向左靠齐的吧。\n\nNSTouchBar 自身有一个 Identifier： **customizationIdentifier**，这是在运行时允许用户自定义 UI 的标识，如果不设置，用户就无法通过系统来自定义 Touch Bar 的 UI。\n\n**customizationAllowedItemIdentifiers**，一个数组，在这里面存放的 Identifier 对应的 BarItem 是允许在运行时被用户修改样式的。\n\n**customizationRequiredItemIdentifiers**，这个数组里面存放的是不能被移除，一定会加载的 BarItem 对应的 Identifier。\n\n**defaultItemIdentifiers**，这是 Touch Bar 默认显示的全部 BarItem，这个参数是**必须**被初始化的。在这里面声明的 Identifier 随后就会在 `-itemForIdentifier:` 这个 Delegate 方法中初始化成 BarItem。给予 BarItem 的 Identifier 必须保持**全局唯一**，系统有另外四个预留的 Identifier：\n\n- NSTouchBarItemIdentifierFixedSpaceSmall\n- NSTouchBarItemIdentifierFixedSpaceLarge\n- NSTouchBarItemIdentifierFlexibleSpace\n- NSTouchBarItemIdentifierOtherItemsProxy\n\n另外，NSTouchBar 还有一个只读的属性 **itemIdentifiers**，这个数组里包含的是运行时当前显示的 BarItem 对应的 Identifier，无论用户在运行的时候对 Touch Bar 做了何种的 Customization，你都可以通过这个属性获得当前的状态。\n\n#### 如何让一个 BarItem 在 Touch Bar 上居中显示？\n\n**principalItemIdentifier** 这个属性所对应的 BarItem 会在 Touch Bar **居中**，是所谓的最高优先级的 Item，如果有多层 Touch Bar 存在，也只会有最上层的 principalItem 显示出来。这里，官方文档中特别提到：\n\n> Do not hard-code spacing in an attempt to ensure an item is centered. If you want a group of items to appear centered in the Touch Bar, designate the group NSTouchBarItem as the principal item.\n>\n> 不要尝试通过添加 Space 的方法来让一个 Item 居中，如果你需要让一组 Item 居中，你可以用一个 BarItem Group 将他们包起来然后将整个 Group 设置为居中。\n\n#### NSTouchBarDelegate\n\n**delegate**，NSTouchBarDelegate 只有一个方法，那就是  \n\n```\n- (nullable NSTouchBarItem *)touchBar:(NSTouchBar *)touchBar makeItemForIdentifier:(NSTouchBarItemIdentifier)identifier;\n```\n\n这个方法就是初始化所有 BarItem 的地方。一般来说写法就是根据 Identifier 来初始化对应的 BarItem，像这样\n\n```\nif ([identifier isEqualToString:@\"...\"])\n{ \n\t...\n\treturn BarItem;\n}\n```\n\n### Layout & Nesting\n\n由于用户可以自定义需要显示的 Touch Bar 宽度，你定义好的 Touch Bar 宽度是可变的。所以苹果的建议是**在设计的时候不要按照确定的宽度来设计，而植入一些动态布局的方**案。如果你需要更宽的宽度，你可以使用 Popover，scrubber 或者 scroll view。\n\n在 Layout 的时候，响应链上层的 Touch Bar 是可以包含下层的 Touch Bar 的，上面在综述的时候提到过的 **Other Items Proxy** 就是用来实现这个功能的。只要你在初始化 Touch Bar 的时候为它的 defaultIdentifiers 加上 NSTouchBarItemIdentifierOtherItemsProxy，他就会在运行时**需要的时候在这个 Identifier 所在的位置**包含上来自下层的合适的 Touch Bar。这个**需要的时候**指的是下层的 NSResponder 调用 becomeFirstResponder 的时候。例如有一个 ViewController 自身带有一个 Touch Bar，而这个 ViewController 中带有一个 NSTextView，那么当点击这个 NSTextview ，也就是**响应链下层 NSResponder 调用 becomeFirstResponder** 的时候，Touch Bar 显示的是：\n\n![](https://ooo.0o0.ooo/2016/11/01/5818435fa4fdd.png)\n\n而如果焦点从 TexView 失去，则恢复成 ViewController 这一层的 Touch Bar：\n\n![](https://ooo.0o0.ooo/2016/11/01/58184323610b8.png)\n\n如果一个 Touch Bar 没有植入 NSTouchBarItemIdentifierOtherItemsProxy ，那么如果在响应链更底层出现了一个可以加载的 Touch Bar，那么上层的 Touch Bar 都会被隐藏。哦，并且 NSTouchBar 的 visible 属性是可以 KVO 的。\n\n#### Responder Chain Search\n\n所以 Touch Bar UI 的加载顺序和 UIView 的响应链类似，都是穿过整个响应链，从最底层开始向上寻找，如果遇到了 otherItemsProxy ， 则会将两者合并起来之后继续往上遍历，直到找到最上层，生成一个最后加载出来的 Touch Bar。\n\n> Touch bars 的加载是通过查找指定的遵循了 NSTouchBarProvider Protocol 的组件来完成的。按照从响应链上层往下的顺序依次是：\n>\n> - the application delegate\n> - the application object itself\n> - the main window’s window controller\n> - the main window’s delegate\n> - the main window itself\n> - the main window’s first responder\n> - the key window’s window controller\n> - the key window’s delegate\n> - the key window itself\n> - the key window’s first responder\n>\n> 如果上面这些对象是 NSResponder 或者 NSResponder 的子类，以该对象为起点的响应链也会被包括进来。例如 AppDelegate 原本是 NSObject，但是[在 iOS 上 AppDelegate 就是继承于 UIResponder](http://stackoverflow.com/questions/6893221/why-does-appdelegate-inherit-from-uiresponder) ，这是因为这样 AppDelegate 就可以成为整个响应链的最上层了。因此**如果我们将 AppDelegate 改为继承于 NSResponder** ，那么在 AppDelegate 层也可以加上一层 Touch Bar。 \n>\n> 例如在一个一般结构的应用中，这个响应链的查找顺序是这样的：\n>\n> - Application delegate\n> - Application\n> - key window controller\n> - key window delegate\n> - key window\n> - view controller (closest to root of window)\n> - view (closest to root of window)\n> - intermediate view controllers and views\n> - key window’s first responder’s view controller\n> - key window’s first responder\n\n#### Customization Boundary\n\n那么对于最后显示的 Touch Bar 来说，每个 Touch Bar 的 Customization 属性依然管用。如果是 A Bar包含了 B Bar，那么对于 B Bar 的 Customization 是不能超出 B Bar 的范围的。例如有：\n\n```\nbar.defaultItemIdentifiers =@[IdentifierA,IdentifierB, NSTouchBarItemIdentifierOtherItemsProxy,IdentifierC];\n```\n\n这个 Bar 假设为 A Bar，在他的下层有一个 B Bar，那么在 AB 同时显示的时候，如果对 B Bar 的 Item 进行 Customization，那么是不能移动 IdentifierA，IdentifierB 和 IdentifierC 的位置的。\n\n#### Visual Priority\n\n**视图优先级**。由于你所开发的 Touch Bar 在运行的时候有可能被用户修改宽度，因此如果你有一排 BarItem，他们会从右往左依次被挤掉，这时候如果右边有一些重要的 BarItem 存在，你就需要为不同的 BarItem 设置不同的视图优先级，这样即使宽度变化，在重新 Layout 的时候也会按照定义好的视图优先级排列 BarItem。\n\n系统提供了三种默认的枚举类型视图优先级，分别为 NSTouchBarItemPriorityHigh， NSTouchBarItemPriorityNormal 和 NSTouchBarItemPriorityLow，对应了 1000，0 和 -1000 的 float 类型的值，因此你也可以直接为 BarItem 设置 float 类型的优先级。\n\n### 用 Storyboard 来定义你的 Multi-Touch Bar\n\n讲了这么多，用代码生成 Touch Bar 多累啊，我们来看看如何用 Storyboard 来创建吧。\n\n![](https://ooo.0o0.ooo/2016/11/01/581844c5bc04f.jpg)\n\n方法很简单，直接往你的 ViewController 里面从右下角拖一个 Touch Bar 过来就行了。然后往里面添加控件，对于不同的控件，Delegate，Datasource 和控件的触发事件，都是用 Control-Drag 的方法将引用加到你的 .m 文件里去。\n\n### 各种控件的具体用法\n\n接下来该是一个个来讲控件了，也是大家在之后的开发中最实用的部分啦。\n\n#### NSColorPickerTouchBarItem\n\ncolorPicker 有三种初始化方法：\n\n- colorPickerWithIdentifier\n- textColorPickerWithIdentifier\n- strokeColorPickerWithIdentifier\n\n这三种方法的区别其实就是在按钮显示的图标上，一个是常规的颜色选择器，第二个代表的是字体颜色选择器，第三种初始化代表的是边框颜色选择器。初始化之后的逻辑都是一样的：\n\n```\ncolorPickerItem.target = self;\ncolorPickerItem.action = @selector(ColorAction:);\n```\n\n然后在 `ColorAction` 这个方法中获得选择到的颜色：\n\n```\n((NSColorPickerTouchBarItem *)sender).color\n```\n\n**@property colorList**\n\n你也可以通过修改 **colorList** 这个属性来自定义 Color Picker 能够选取的颜色列表。如果不设置这个属性，则默认显示的是系统的取色盘，各种颜色都有：\n\n![](https://ooo.0o0.ooo/2016/11/02/5819676729847.png)\n\n当给了一个 list 之后：\n\n```\ncolorPickerItem.colorList = [[NSColorList alloc] init];\n[colorPickerItem.colorList setColor:[NSColor redColor] forKey:@\"Red\"];\n[colorPickerItem.colorList setColor:[NSColor greenColor] forKey:@\"Green\"];\n[colorPickerItem.colorList setColor:[NSColor blueColor] forKey:@\"Blue\"];\n```\n\n显示的就是这样：\n\n![](https://ooo.0o0.ooo/2016/11/02/58196802031d6.png)\n\n#### NSSliderTouchBarItem\n\n初始化：\n\n```\nsliderTouchBarItem.slider.minValue = 0.0f;\nsliderTouchBarItem.slider.maxValue = 100.0f;\nsliderTouchBarItem.slider.continuous = YES;\nsliderTouchBarItem.target = self;\nsliderTouchBarItem.action = @selector(sliderChanged:);\nsliderTouchBarItem.label = @\"Slider\";\nsliderTouchBarItem.customizationLabel = @\"Slider\";\n```\n\n这里面的 action 会在 slider 的值每一次发生改变的时候调用。\n\n值得一提的是 SliderItem 还提供了两个 AccessoryView 的自定义空间，左右各一个，分别叫做 **minimumValueAccessory** 和 **maximumValueAccessory**，可以用 NSImage 来初始化他们：\n\n```\nNSSliderAccessory *minSliderAccessory = [NSSliderAccessory accessoryWithImage:image];\n```\n\n其他的自定义都是围绕着 NSSlider 做的了。\n\n#### NSScrubber\n\n这是一个为了 Touch Bar 而全新创建的控件，在发布会上有着重的展示。他需要单独的添加到一个 TouchBarItem 里去：\n\n```\nscrubber = [[NSScrubber alloc] initWithFrame:NSMakeRect(0, 0, 310, 30)];\n// Height should be 30 \nscrubber.delegate = self;   \nscrubber.dataSource = self; \n```\n\nNSScrubber 类似 UICollectionView ，也是有基于 ItemView 的复用机制的，你可以继承 NSScrubberItemView 来写你自己需要的 CustomItemView。然后在初始化之后需要为 ItemView 加上一个复用的标识：\n\n```\n[scrubber registerClass:[NSScrubberItemView class] forItemIdentifier:ScrubberItemIdentifier];\n```\n\n**@property showsAdditionalContentIndicators** \n\n代表的是当左右滑动还有更多内容的时候，在左右侧会显示一块渐变的蒙层，用来表示滑动还有更多内容，你可以选择是否显示。\n\n**@property selectedIndex** \n\n即当前选中的 ItemView 的 index，可以直接设置。\n\n**@property showsArrowButtons** \n\n代表的是是否显示左右移动的箭头按钮，如果显示的话你也可以点击左右箭头的按钮来滑动列表。\n\n**@property backgroundColor** \n\nNSScrubber 的背景颜色，显示在内容之后，如果 **backgroundView** 为空才会显示，同时也是只有 NSScrubberTextItemView 类型的 ItemView 才会显示出后面的背景颜色。\n\n**@property DataSource**\n\n```\n- (NSInteger)numberOfItemsForScrubber:(NSScrubber *)scrubber\n{\n\treturn 1;\n}\n\n- (NSScrubberItemView *)scrubber:(NSScrubber *)scrubber viewForItemAtIndex:(NSInteger)index\n{\n\tNSScrubberItemVie *itemView = [scrubber makeItemWithIdentifier:ScrubberItemIdentifier owner:nil];\n\treturn itemView;\n}\n```\n\n数据源加载比较简单，一个给 Item 的总数，另一个给 ItemView 就行，上面给出了最简单的示例。\n\n**@property Delegate**\n\nNSScrubber 有好几个 Delegate 可以调用，也都比较好理解，一般来说实现第一个选中回调就足够了：\n\n- didSelectItemAtIndex:(NSInteger)selectedIndex \n- didHighlightItemAtIndex:(NSInteger)highlightedIndex \n- didChangeVisibleRange:(NSRange)visibleRange\n- didBeginInteractingWithScrubber:(NSScrubber *)scrubber\n- didFinishInteractingWithScrubber:(NSScrubber *)scrubber\n- didCancelInteractingWithScrubber:(NSScrubber *)scrubber\n\n**@property mode**\n\n这个代表的是 NSScrubber 的滑动模式，一共就两种，**NSScrubberModeFree** 和 **NSScrubberModeFixed**。\n\nFree 模式下的 Scrubber 可以自由的滑动，但是你必须在**滑动之后再次单击 Item** 来选中，而 Fixed 模式下的 Scrubber 是不能自由滑动的，但是对于 ItemView 的选中是**跟随手指的拖动**的，不需要让手指离开 Touch Bar 再次点击选中。对于宽度固定，或者不需要用户再滑出范围的 Scrubber 可以使用 Fixed 模式。\n\n**@property SelectionStyle**\n\nScrubber 给选中样式提供了很方便的自定义属性，有 **selectionBackgroundStyle** 和 **selectionOverlayStyle**，同时也可以通过设置 **floatsSelectionViews** 为 YES 让选中 View 切换的时候可以加上从 A 点到 B 点流畅的移动动画，而不是从 A 点消失然后从 B 点出现这样的动画。\n\nselectionBackgroundStyle 和 selectionOverlayStyle 分别是选中的时候**背景**和**表面蒙层**的样式，只提供了 outlineOverlayStyle\n\n![](https://ooo.0o0.ooo/2016/11/02/5819b0f9959ad.png)\n\n和 roundedBackgroundStyle 两种默认样式：\n\n![](https://ooo.0o0.ooo/2016/11/02/5819b17f754fb.png)\n\n当然，这个 SelectionStyle 也是高度自定义的，但是你需要继承两个视图的基类来实现：\n\n1. 定义一个继承于 NSScrubberSelectionStyle 的 CustomStyle \n2. 重载 `-(nullable __kindof NSScrubberSelectionView *)makeSelectionView` 这个方法\n3. 定义一个继承于 NSScrubberSelectionView 的 CustomSelectionView\n4. 自定义 CustomSelectionView 的样式\n5. 在重载的方法中返回 CustomSelectionView\n\n**@property scrubberLayout**\n\n类似于 UICollectionView ，NSScrubber 的 layout 也是由 **NSScrubberLayout** 来控制的。系统提供了两种默认的 Layout，**NSScrubberFlowLayout** 和 **NSScrubberProportionalLayout**。前者可以通过 LayoutDelegate 来给出每一个 Item 所占的宽度，后者则不需要通过 delegate 而是直接将 Item 的宽度设置为 Scrubber 的可视区域按照 Item 的数量平分之后的宽度。你可以这样设置：\n\n```\nNSScrubberLayout *scrubberLayout;\nscrubberLayout = [[NSScrubberFlowLayout alloc] init];\n// or:\nscrubberLayout = [[NSScrubberProportionalLayout alloc] init];\nscrubber.scrubberLayout = scrubberLayout;\n```\n\n对于 NSScrubberFlowLayoutDelegate 你需要实现这一个方法：\n\n```\n- (NSSize)scrubber:(NSScrubber *)scrubber layout:(NSScrubberFlowLayout *)layout sizeForItemAtIndex:(NSInteger)itemIndex\n{\n    return NSMakeSize(width, 30);\n}\n```\n\n#### NSSharingServicePickerTouchBarItem\n\nNSSharingServicePickerTouchBarItem 的 delegate 只有一个委托方法需要实现：\n\n```\n- (NSArray *)itemsForSharingServicePickerTouchBarItem:(NSSharingServicePickerTouchBarItem *)pickerTouchBarItem\n{\n    return @[...];\n}\n```\n\n在这里返回的对象一定要是能够支持 NSPasteboardWriting 协议或者是继承于 NSItemProvider 的对象，例如文本，图片或者 NSURL，可以参考 [NSItemProvider 的官方文档](https://developer.apple.com/reference/foundation/nsitemprovider?language=objc)。然后就会在分享的时候传到分享的应用里去。\n\n#### NSPopoverTouchBarItem\n\n首先，我们来看如何自定义 Popover 在未点击状态下的显示 Button。\n\n- collapsedRepresentation 如果不为空，则显示一个自定义的 NSView，如果为空，则加载不为空的下面两个属性\n- collapsedRepresentationImage 给 Popover 的 button 添加一个 NSImage\n- collapsedRepresentationLabel 给 Popover 的 button 添加一个 **NSString**\n\nPopover 其实是在点击按钮之后弹出一个**新的 Touch Bar**，你需要再初始化一个新的 Touch Bar 并在同样的 Delegate 中返回对应的 BarItem，注意它和你之前的 Touch Bar 不是响应链上下层的关系，因此不会出现 Nesting 即上层的 Touch Bar 包含下层的 Touch Bar，而是完全覆盖了下面的 Touch Bar。如果你将新的 Touch Bar 赋值给了 **pressAndHoldTouchBar** 而不是 **popoverTouchBar**，你还可以实现按住按钮显示 Popover 且松开手指返回。\n\n#### Touch Bar Image Template\n\n最后还要为大家提供一个便利，苹果为了支持 Touch Bar 的开发，同时也为了统一设计样式，在 NSImage 中添加了非常多 Button 的模板图片，由于提供的模板太多了，不一一列出，就把列表附上，如果有同学开发的时候有需要可以去 NSImage 的头文件里面找，如果系统模板有的话可以直接使用。\n\n![](https://ooo.0o0.ooo/2016/11/02/5819c14c90072.png)\n\n### 最后\n\nTouch Bar 开发的新特性和坑肯定还有很多，现在新的 MBP 都还没发货，相信等更多的开发者开始真正开发上面的插件之后会有更丰富的经验和总结产生，我这篇博客也就是投石问路。然而，对 Touch Bar 十分感兴趣的我已经等不及开始研究它并且开始准备在上面做一些有意思的东西了！","slug":"Multi-Touch-Bar-UI-开发入门指南","published":1,"updated":"2016-11-02T11:08:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnywz003sj4rbi8r4tes2"},{"title":"Leetcode - Database 刷题记录","date":"2016-08-26T07:50:59.000Z","author":"Sergio Chan","_content":"\n\n\n偶然被 Cee 酱吸引打开了 Leetcode，这个大一的时候觉得自己一辈子都不会去做的事情……居然。发现 OJ 竟然有 Database 模块了，想当年大学学数据库的时候最想有的就是一个和 OJ 一样的 SQL 在线运行平台，不然数据库上机只会教你安装 SQL Server = = 想想都想哭，时间都浪费在那了。而且做了之后发现好多自己在生产环境都不会遇到的神奇的坑……因此抽着空闲做了大部分，留下此篇笔记。\n\n浮生若梦。\n\n## List\n\n- [175 . Combine Two Tables](#175_-_Combine_Two_Tables)\n- [177 . Nth Highest Salary](#177_-_Nth_Highest_Salary)\n- [181 . Employees Earning More Than Their Managers](#181_-_Employees_Earning_More_Than_Their_Managers)\n- [182 . Duplicate Emails](#182_-_Duplicate_Emails)\n- [183 . Customers Who Never Order](#183_-_Customers_Who_Never_Order)\n- [185 . Department Top Three Salaries](#185_-_Department_Top_Three_Salaries)\n- [196 . Delete Duplicate Emails](#196_-_Delete_Duplicate_Emails)\n- [197 . Rising Temperature](#197_-_Rising_Temperature)\n\n### 175 . Combine Two Tables\n\nTable: `Person`\n\n```\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| PersonId    | int     |\n| FirstName   | varchar |\n| LastName    | varchar |\n+-------------+---------+\nPersonId is the primary key column for this table.\n```\n\nTable: `Address`\n\n```\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| AddressId   | int     |\n| PersonId    | int     |\n| City        | varchar |\n| State       | varchar |\n+-------------+---------+\nAddressId is the primary key column for this table.\n\n```\n\nWrite a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:\n\n```\nFirstName, LastName, City, State\n```\n\n#### SQL :\n\n```\nSELECT Person.FirstName AS FirstName ,Person.LastName AS LastName ,Address.City AS City,Address.State AS State\nFROM Person\nLEFT JOIN Address ON (Person.PersonId = Address.PersonId)\n```\n\n#### Comment :\n\n其实这题看起来很简单，但是要注意一个是用 **LEFT JOIN**，这样即使没有地址的 Person 也会被选出来，另一个是在 Select 的时候要按照它的要求命名选出来的列（由于这题老是遇到 Internal Error，相同的语句运行三遍通过一遍有两遍都是 Internal Error，因此并不是特别明白这个是不是必须的）但是 **LEFT JOIN** 是一定要有的，用 where 连接两个表的话也要特别注意到不存在的情况，因此本题还是用 JOIN 做连接好过用 where 做多表连接\n\n### 177 . Nth Highest Salary\n\nWrite a SQL query to get the *n*th highest salary from the `Employee` table.\n\n```\n+----+--------+\n| Id | Salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n\n```\n\nFor example, given the above Employee table, the *n*th highest salary where *n* = 2 is `200`. If there is no *n*th highest salary, then the query should return `null`.\n\n#### SQL :\n\n```\nCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT\nBEGIN\n  DECLARE l INT;\n  DECLARE r INT;\n  DECLARE c INT;\n  \n  SET l = N-1;\n  SELECT COUNT(DISTINCT(Salary)) INTO c FROM Employee;\n  \n  IF N > c THEN \n    RETURN (null);\n  ELSE\n    SELECT Salary INTO r FROM Employee GROUP BY Salary ORDER BY Salary DESC LIMIT l, 1;\n    RETURN (r);\n  END IF;\nEND\n```\n\n#### Comment :\n\n这题简直变态。\n\n![](https://ooo.0o0.ooo/2016/08/26/57bfebf246fe0.png)\n\n有这时间不如用 Python 什么的取出想要的数据在内存里排个序就完事了，非得整个 SQL Function，简直不知道说什么好。之前也写过 Function，但是主要是在 SQL 的 Procedure 编程里面会用到，而且基本不会写到复杂的逻辑 = = 复杂逻辑写个脚本什么的不好么……言归正传，这题考察了 Function 中的多个基本语法，包括 **DECLARE**, **SET**, **SELECT 的结果赋值**，**IF...THEN...ELSE...END IF 逻辑**。（这里其实题目没交代清楚，懒得吐槽了）如果遇到相同 Salary 的数据怎么办，其实题目的意思是如果两个人的 Salary 都为 200，一个人 Salary 为 300，那就只有第一 300 第二 200 而没有第三，他最后需要你返回的也只是 Salary 的值，因此我们需要先去重一遍得到 DISTINCT 的 Salary 值的数量，如果要获取的第 N 位并不存在，则返回 null，如果存在则用 **GROUP BY 套 ORDER BY 套 LIMIT** 来获取分组排序后的第 N - 1 位，记住要获取的第 N 位的 index 是 N - 1，所以这儿才要重新 DECLARE 一个 l 。\n\n###  181 . Employees Earning More Than Their Managers\n\nThe `Employee` table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.\n\n```\n+----+-------+--------+-----------+\n| Id | Name  | Salary | ManagerId |\n+----+-------+--------+-----------+\n| 1  | Joe   | 70000  | 3         |\n| 2  | Henry | 80000  | 4         |\n| 3  | Sam   | 60000  | NULL      |\n| 4  | Max   | 90000  | NULL      |\n+----+-------+--------+-----------+\n\n```\n\nGiven the `Employee` table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.\n\n```\n+----------+\n| Employee |\n+----------+\n| Joe      |\n+----------+\n\n```\n\n#### SQL :\n\n```\nSELECT a.Name as Employee \nFROM Employee as a \nWHERE a.ManagerId is not NULL AND a.Salary > \n(SELECT b.Salary \nFROM Employee as b \nWHERE b.Id = a.ManagerId);\n```\n\n#### Comment :\n\n这题简单，不多解释。有 JOIN 的解法应该也行。\n\n###  182 . Duplicate Emails\n\nWrite a SQL query to find all duplicate emails in a table named `Person`.\n\n```\n+----+---------+\n| Id | Email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n\n```\n\nFor example, your query should return the following for the above table:\n\n```\n+---------+\n| Email   |\n+---------+\n| a@b.com |\n+---------+\n```\n\n#### SQL :\n\n```\nSELECT Person.Email \nFROM Person \nGROUP BY Person.Email \nHAVING COUNT(Person.Id) > 1;\n```\n\n#### Comment :\n\n这题简单的不能再简单了，然而还是有一个蛋疼的坑：**COUNT 的用法**。这题如果你在 **having COUNT()** 括号中写 \\* 号，是不能通过的，原因就在于 **COUNT(\\*)** 统计的是\b表中数据的总条数，而 **COUNT(Person.Id)** 统计的则是除去表中 Id 不等于 NULL 的记录的总条数。因此很可能它有某个 testcase 中有 NULL 的数据来考察对于 COUNT 的理解吧。\n\n### 183 . Customers Who Never Order\n\nSuppose that a website contains two tables, the `Customers` table and the `Orders` table. Write a SQL query to find all customers who never order anything.\n\nTable: `Customers`.\n\n```\n+----+-------+\n| Id | Name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\n\n```\n\nTable: `Orders`.\n\n```\n+----+------------+\n| Id | CustomerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\n\n```\n\nUsing the above tables as example, return the following:\n\n```\n+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+\n```\n\n#### SQL :\n\n```\nSELECT a.Name AS Customers \nFROM Customers AS a \nLEFT JOIN Orders AS b \nON (a.Id = b.CustomerId) \nWHERE a.Id IS NULL OR b.CustomerId IS NULL;\n```\n\n#### Comment :\n\n这题如果不用 Left Join 而用 Not in 的话也是可以的，只是效率方面 Not in 的话运行时间是排在百分之八十多，如果用了上面的 Left Join 则会好一些 （ runtime 每次运行会有微妙的差距，可能几十毫秒就是百分之几十的差距）。\n\n![](https://ooo.0o0.ooo/2016/08/26/57bfeb47b9186.png)\n\n###  185 . Department Top Three Salaries\n\nThe `Employee` table holds all employees. Every employee has an Id, and there is also a column for the department Id.\n\n```\n+----+-------+--------+--------------+\n| Id | Name  | Salary | DepartmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 70000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n+----+-------+--------+--------------+\n\n```\n\nThe `Department` table holds all departments of the company.\n\n```\n+----+----------+\n| Id | Name     |\n+----+----------+\n| 1  | IT       |\n| 2  | Sales    |\n+----+----------+\n```\n\nWrite a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows.\n\n```\n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Randy    | 85000  |\n| IT         | Joe      | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+\n```\n\n#### SQL :\n\n```\nselect d.Name as Department, a.Name as Employee, a.Salary as Salary \nfrom Employee as a,Department as d \nwhere (select count(b.Salary) \nfrom (select e.Salary as Salary,e.DepartmentId as DepartmentId \nfrom Employee as e \ngroup by e.Salary,e.DepartmentId) as b \nwhere b.Salary > a.Salary and b.DepartmentId = a.DepartmentId) <= 2 and d.Id = a.DepartmentId \norder by a.DepartmentId,a.Salary desc;\n```\n\n#### Comment :\n\n变态。这道题无愧是 Hard。上面这个解法虽然套了三层 Select ，但是它的运行时间都能排在前 15%\n\n![](https://ooo.0o0.ooo/2016/08/26/57bfea0296548.jpeg)\n\n可见这题本来就是计算量很大的一次查询。主要考察了 **group by  的用法**，group by 的用法其实比较特殊，比如 Salary 相同但其他列不同的情况下，如果 group by Salary，那就只能 select salary，否则 salary 相同的项目会无法合并。（当然在你自己的 MySQL 环境下你可以配一个 full group mode 参数来强制允许 MySQL 能够执行这样的语句）因此在最中间我们先是将用户分组排序过后的数据分进一个单独的表 b ，这里的数据由于 group by Salary 和 DepartmentId，因此同部门相同 Salary 的数据已经被合并到一项去了，那么接着就确认当前同部门的工资比自己高的等级是否小于 3 个，如果是的话就取出来。\n\n*PS . 这句 SQL 主要就是长长长，其实也没什么 = =*\n\n###  196 . Delete Duplicate Emails\n\nWrite a SQL query to delete all duplicate email entries in a table named `Person`, keeping only unique emails based on its *smallest* **Id**.\n\n```\n+----+------------------+\n| Id | Email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n| 3  | john@example.com |\n+----+------------------+\nId is the primary key column for this table.\n\n```\n\nFor example, after running your query, the above `Person` table should have the following rows:\n\n```\n+----+------------------+\n| Id | Email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n+----+------------------+\n```\n\n#### SQL :\n\n```\ndelete from Person where Id in (\nselect * from ( \nselect b.Id\nfrom (select * from Person) as b \nwhere exists (\nselect d.* \nfrom (select * from Person) as d \nwhere d.Id < b.Id and b.Email = d.Email)) as test);\n```\n\n#### Comment :\n\n这题考察的是 **delete + where + in** 的套路。delete where in 后面跟着的 select 里面的表不能是 delete 的 target，这个规则 delete 和 update 同理，要在 delete where in 后面加上 target 表的查询，你就需要套一层 select * … as … 就可以了。效率略低，但是实用。\n\n###  197 . Rising Temperature\n\nGiven a `Weather` table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates.\n\n```\n+---------+------------+------------------+\n| Id(INT) | Date(DATE) | Temperature(INT) |\n+---------+------------+------------------+\n|       1 | 2015-01-01 |               10 |\n|       2 | 2015-01-02 |               25 |\n|       3 | 2015-01-03 |               20 |\n|       4 | 2015-01-04 |               30 |\n+---------+------------+------------------+\n\n```\n\nFor example, return the following Ids for the above Weather table:\n\n```\n+----+\n| Id |\n+----+\n|  2 |\n|  4 |\n+----+\n```\n\n#### SQL :\n\n```\nSELECT a.Id \nFROM Weather AS a \nWHERE EXISTS (\nSELECT b.Temperature \nFROM Weather AS b \nWHERE b.Date = SUBDATE(a.Date,1) and b.Temperature < a.Temperature);\n```\n\n#### Comment :\n\n此题又是看起来简单的不能再简单了。然而坑就在 Date 类型的数据操作上，第一，几乎少有人在实际生产环境中用 Date 这种不靠谱的数据格式，我还没见过谁生产环境不用时间戳的 = =，第二，这个坑谁知道啊…… Date 提供了加减的操作，看起来你好像可以直接 update 一个 date + 1 等于第二天的日期，然而碰到月份的边界这个加减就挂了啊（黑人问号.jpg） 碰到 01-01，减 1 之后等于 01-00，因此其实 SQL 是有日期操作**函数**的， SUBDATE(DATE, INTERVAL) 就可以实现。","source":"_posts/Leetcode-Database-刷题记录.md","raw":"title: Leetcode - Database 刷题记录\ndate: 2016-08-26 15:50:59\ncategories: 闲言碎语\nauthor: Sergio Chan\n\n\ntags: [MySQL, Leetcode]\n---\n\n\n\n偶然被 Cee 酱吸引打开了 Leetcode，这个大一的时候觉得自己一辈子都不会去做的事情……居然。发现 OJ 竟然有 Database 模块了，想当年大学学数据库的时候最想有的就是一个和 OJ 一样的 SQL 在线运行平台，不然数据库上机只会教你安装 SQL Server = = 想想都想哭，时间都浪费在那了。而且做了之后发现好多自己在生产环境都不会遇到的神奇的坑……因此抽着空闲做了大部分，留下此篇笔记。\n\n浮生若梦。\n\n## List\n\n- [175 . Combine Two Tables](#175_-_Combine_Two_Tables)\n- [177 . Nth Highest Salary](#177_-_Nth_Highest_Salary)\n- [181 . Employees Earning More Than Their Managers](#181_-_Employees_Earning_More_Than_Their_Managers)\n- [182 . Duplicate Emails](#182_-_Duplicate_Emails)\n- [183 . Customers Who Never Order](#183_-_Customers_Who_Never_Order)\n- [185 . Department Top Three Salaries](#185_-_Department_Top_Three_Salaries)\n- [196 . Delete Duplicate Emails](#196_-_Delete_Duplicate_Emails)\n- [197 . Rising Temperature](#197_-_Rising_Temperature)\n\n### 175 . Combine Two Tables\n\nTable: `Person`\n\n```\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| PersonId    | int     |\n| FirstName   | varchar |\n| LastName    | varchar |\n+-------------+---------+\nPersonId is the primary key column for this table.\n```\n\nTable: `Address`\n\n```\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| AddressId   | int     |\n| PersonId    | int     |\n| City        | varchar |\n| State       | varchar |\n+-------------+---------+\nAddressId is the primary key column for this table.\n\n```\n\nWrite a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:\n\n```\nFirstName, LastName, City, State\n```\n\n#### SQL :\n\n```\nSELECT Person.FirstName AS FirstName ,Person.LastName AS LastName ,Address.City AS City,Address.State AS State\nFROM Person\nLEFT JOIN Address ON (Person.PersonId = Address.PersonId)\n```\n\n#### Comment :\n\n其实这题看起来很简单，但是要注意一个是用 **LEFT JOIN**，这样即使没有地址的 Person 也会被选出来，另一个是在 Select 的时候要按照它的要求命名选出来的列（由于这题老是遇到 Internal Error，相同的语句运行三遍通过一遍有两遍都是 Internal Error，因此并不是特别明白这个是不是必须的）但是 **LEFT JOIN** 是一定要有的，用 where 连接两个表的话也要特别注意到不存在的情况，因此本题还是用 JOIN 做连接好过用 where 做多表连接\n\n### 177 . Nth Highest Salary\n\nWrite a SQL query to get the *n*th highest salary from the `Employee` table.\n\n```\n+----+--------+\n| Id | Salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n\n```\n\nFor example, given the above Employee table, the *n*th highest salary where *n* = 2 is `200`. If there is no *n*th highest salary, then the query should return `null`.\n\n#### SQL :\n\n```\nCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT\nBEGIN\n  DECLARE l INT;\n  DECLARE r INT;\n  DECLARE c INT;\n  \n  SET l = N-1;\n  SELECT COUNT(DISTINCT(Salary)) INTO c FROM Employee;\n  \n  IF N > c THEN \n    RETURN (null);\n  ELSE\n    SELECT Salary INTO r FROM Employee GROUP BY Salary ORDER BY Salary DESC LIMIT l, 1;\n    RETURN (r);\n  END IF;\nEND\n```\n\n#### Comment :\n\n这题简直变态。\n\n![](https://ooo.0o0.ooo/2016/08/26/57bfebf246fe0.png)\n\n有这时间不如用 Python 什么的取出想要的数据在内存里排个序就完事了，非得整个 SQL Function，简直不知道说什么好。之前也写过 Function，但是主要是在 SQL 的 Procedure 编程里面会用到，而且基本不会写到复杂的逻辑 = = 复杂逻辑写个脚本什么的不好么……言归正传，这题考察了 Function 中的多个基本语法，包括 **DECLARE**, **SET**, **SELECT 的结果赋值**，**IF...THEN...ELSE...END IF 逻辑**。（这里其实题目没交代清楚，懒得吐槽了）如果遇到相同 Salary 的数据怎么办，其实题目的意思是如果两个人的 Salary 都为 200，一个人 Salary 为 300，那就只有第一 300 第二 200 而没有第三，他最后需要你返回的也只是 Salary 的值，因此我们需要先去重一遍得到 DISTINCT 的 Salary 值的数量，如果要获取的第 N 位并不存在，则返回 null，如果存在则用 **GROUP BY 套 ORDER BY 套 LIMIT** 来获取分组排序后的第 N - 1 位，记住要获取的第 N 位的 index 是 N - 1，所以这儿才要重新 DECLARE 一个 l 。\n\n###  181 . Employees Earning More Than Their Managers\n\nThe `Employee` table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.\n\n```\n+----+-------+--------+-----------+\n| Id | Name  | Salary | ManagerId |\n+----+-------+--------+-----------+\n| 1  | Joe   | 70000  | 3         |\n| 2  | Henry | 80000  | 4         |\n| 3  | Sam   | 60000  | NULL      |\n| 4  | Max   | 90000  | NULL      |\n+----+-------+--------+-----------+\n\n```\n\nGiven the `Employee` table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.\n\n```\n+----------+\n| Employee |\n+----------+\n| Joe      |\n+----------+\n\n```\n\n#### SQL :\n\n```\nSELECT a.Name as Employee \nFROM Employee as a \nWHERE a.ManagerId is not NULL AND a.Salary > \n(SELECT b.Salary \nFROM Employee as b \nWHERE b.Id = a.ManagerId);\n```\n\n#### Comment :\n\n这题简单，不多解释。有 JOIN 的解法应该也行。\n\n###  182 . Duplicate Emails\n\nWrite a SQL query to find all duplicate emails in a table named `Person`.\n\n```\n+----+---------+\n| Id | Email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n\n```\n\nFor example, your query should return the following for the above table:\n\n```\n+---------+\n| Email   |\n+---------+\n| a@b.com |\n+---------+\n```\n\n#### SQL :\n\n```\nSELECT Person.Email \nFROM Person \nGROUP BY Person.Email \nHAVING COUNT(Person.Id) > 1;\n```\n\n#### Comment :\n\n这题简单的不能再简单了，然而还是有一个蛋疼的坑：**COUNT 的用法**。这题如果你在 **having COUNT()** 括号中写 \\* 号，是不能通过的，原因就在于 **COUNT(\\*)** 统计的是\b表中数据的总条数，而 **COUNT(Person.Id)** 统计的则是除去表中 Id 不等于 NULL 的记录的总条数。因此很可能它有某个 testcase 中有 NULL 的数据来考察对于 COUNT 的理解吧。\n\n### 183 . Customers Who Never Order\n\nSuppose that a website contains two tables, the `Customers` table and the `Orders` table. Write a SQL query to find all customers who never order anything.\n\nTable: `Customers`.\n\n```\n+----+-------+\n| Id | Name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\n\n```\n\nTable: `Orders`.\n\n```\n+----+------------+\n| Id | CustomerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\n\n```\n\nUsing the above tables as example, return the following:\n\n```\n+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+\n```\n\n#### SQL :\n\n```\nSELECT a.Name AS Customers \nFROM Customers AS a \nLEFT JOIN Orders AS b \nON (a.Id = b.CustomerId) \nWHERE a.Id IS NULL OR b.CustomerId IS NULL;\n```\n\n#### Comment :\n\n这题如果不用 Left Join 而用 Not in 的话也是可以的，只是效率方面 Not in 的话运行时间是排在百分之八十多，如果用了上面的 Left Join 则会好一些 （ runtime 每次运行会有微妙的差距，可能几十毫秒就是百分之几十的差距）。\n\n![](https://ooo.0o0.ooo/2016/08/26/57bfeb47b9186.png)\n\n###  185 . Department Top Three Salaries\n\nThe `Employee` table holds all employees. Every employee has an Id, and there is also a column for the department Id.\n\n```\n+----+-------+--------+--------------+\n| Id | Name  | Salary | DepartmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 70000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n+----+-------+--------+--------------+\n\n```\n\nThe `Department` table holds all departments of the company.\n\n```\n+----+----------+\n| Id | Name     |\n+----+----------+\n| 1  | IT       |\n| 2  | Sales    |\n+----+----------+\n```\n\nWrite a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows.\n\n```\n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Randy    | 85000  |\n| IT         | Joe      | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+\n```\n\n#### SQL :\n\n```\nselect d.Name as Department, a.Name as Employee, a.Salary as Salary \nfrom Employee as a,Department as d \nwhere (select count(b.Salary) \nfrom (select e.Salary as Salary,e.DepartmentId as DepartmentId \nfrom Employee as e \ngroup by e.Salary,e.DepartmentId) as b \nwhere b.Salary > a.Salary and b.DepartmentId = a.DepartmentId) <= 2 and d.Id = a.DepartmentId \norder by a.DepartmentId,a.Salary desc;\n```\n\n#### Comment :\n\n变态。这道题无愧是 Hard。上面这个解法虽然套了三层 Select ，但是它的运行时间都能排在前 15%\n\n![](https://ooo.0o0.ooo/2016/08/26/57bfea0296548.jpeg)\n\n可见这题本来就是计算量很大的一次查询。主要考察了 **group by  的用法**，group by 的用法其实比较特殊，比如 Salary 相同但其他列不同的情况下，如果 group by Salary，那就只能 select salary，否则 salary 相同的项目会无法合并。（当然在你自己的 MySQL 环境下你可以配一个 full group mode 参数来强制允许 MySQL 能够执行这样的语句）因此在最中间我们先是将用户分组排序过后的数据分进一个单独的表 b ，这里的数据由于 group by Salary 和 DepartmentId，因此同部门相同 Salary 的数据已经被合并到一项去了，那么接着就确认当前同部门的工资比自己高的等级是否小于 3 个，如果是的话就取出来。\n\n*PS . 这句 SQL 主要就是长长长，其实也没什么 = =*\n\n###  196 . Delete Duplicate Emails\n\nWrite a SQL query to delete all duplicate email entries in a table named `Person`, keeping only unique emails based on its *smallest* **Id**.\n\n```\n+----+------------------+\n| Id | Email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n| 3  | john@example.com |\n+----+------------------+\nId is the primary key column for this table.\n\n```\n\nFor example, after running your query, the above `Person` table should have the following rows:\n\n```\n+----+------------------+\n| Id | Email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n+----+------------------+\n```\n\n#### SQL :\n\n```\ndelete from Person where Id in (\nselect * from ( \nselect b.Id\nfrom (select * from Person) as b \nwhere exists (\nselect d.* \nfrom (select * from Person) as d \nwhere d.Id < b.Id and b.Email = d.Email)) as test);\n```\n\n#### Comment :\n\n这题考察的是 **delete + where + in** 的套路。delete where in 后面跟着的 select 里面的表不能是 delete 的 target，这个规则 delete 和 update 同理，要在 delete where in 后面加上 target 表的查询，你就需要套一层 select * … as … 就可以了。效率略低，但是实用。\n\n###  197 . Rising Temperature\n\nGiven a `Weather` table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates.\n\n```\n+---------+------------+------------------+\n| Id(INT) | Date(DATE) | Temperature(INT) |\n+---------+------------+------------------+\n|       1 | 2015-01-01 |               10 |\n|       2 | 2015-01-02 |               25 |\n|       3 | 2015-01-03 |               20 |\n|       4 | 2015-01-04 |               30 |\n+---------+------------+------------------+\n\n```\n\nFor example, return the following Ids for the above Weather table:\n\n```\n+----+\n| Id |\n+----+\n|  2 |\n|  4 |\n+----+\n```\n\n#### SQL :\n\n```\nSELECT a.Id \nFROM Weather AS a \nWHERE EXISTS (\nSELECT b.Temperature \nFROM Weather AS b \nWHERE b.Date = SUBDATE(a.Date,1) and b.Temperature < a.Temperature);\n```\n\n#### Comment :\n\n此题又是看起来简单的不能再简单了。然而坑就在 Date 类型的数据操作上，第一，几乎少有人在实际生产环境中用 Date 这种不靠谱的数据格式，我还没见过谁生产环境不用时间戳的 = =，第二，这个坑谁知道啊…… Date 提供了加减的操作，看起来你好像可以直接 update 一个 date + 1 等于第二天的日期，然而碰到月份的边界这个加减就挂了啊（黑人问号.jpg） 碰到 01-01，减 1 之后等于 01-00，因此其实 SQL 是有日期操作**函数**的， SUBDATE(DATE, INTERVAL) 就可以实现。","slug":"Leetcode-Database-刷题记录","published":1,"updated":"2016-08-26T09:16:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyx3003uj4rbox90ow16"},{"title":"How to draw a Wireframe Shader for a Cube in Rajawali under OpenGL ES 2.0","date":"2016-11-09T09:41:34.000Z","_content":"\n> PS. This will be my first blog totally written in english.\n\n\n\n![](https://ooo.0o0.ooo/2016/11/09/58227c9f45765.png)\n\n## Setup\n\n> **Environment:** \n>\n> GLSL ES Version 100\n>\n> OpenGL ES Version 2.0\n>\n> Android 6.0\n>\n> Android OpenGL ES 2.0/3.0 Engine [Rajawali](https://github.com/Rajawali/Rajawali)\n\n## First Discuss\n\nThere are several ways to draw a wireframe for a cube in Rajawali engine. We can use \n\n```\ncube.setDrawingMode(GLES20.GL_LINE_STRIP);\n```\n\nto tell the cube to draw in wireframe mode. But because a Cube, or we can say, every Polygons or 3D Objects in OpenGL are formed by lots of dots, lines and triangles, setting drawing mode will only show you such images like below : \n\n![](https://ooo.0o0.ooo/2016/11/09/5822d63584db6.png)\n\nAlso, when you set DrawingMode to GL_LINE_STRIP, your custom vertex or fragment shader won't work as usual. So you will see a cube full of lines, doesn't it look messy to you?\n\nIn order to draw wireframe using fragment shader, we can simply use following fragement shader :\n\n```\nprecision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main() {\n        vec4 newColor = vec4(0.0, 0.0, 0.0, 1.0);\n        float x = min(vTextureCoord.s, 1.0 - vTextureCoord.s);\n        float y = min(vTextureCoord.t, 1.0 - vTextureCoord.t);\n\n        float line_width = 0.01;\n        \n        if (x < line_width) {\n            newColor.g = 1.0;\n            newColor.r = 1.0;\n            newColor.b = 1.0;\n        }\n\n        if (y < line_width) {\n            newColor.g = 1.0;\n            newColor.r = 1.0;\n            newColor.b = 1.0;\n        }\n        gl_FragColor = newColor;\n}\n```\n\nHowever, there is still a problem here. While using this shader, if you make your cube scale in whichever direction, this drawing 'Line' will always scale along with the cube. Obviously it's because the 0.01 we set here is a relative value. But the `vTextureCoord` we can get here which was passed by our vertex shader is only a `vec2` vector represented a 2D coordinate on this mesh, which can only range from (0.0 , 0.0) to (1.0 , 1.0). This means `vTextureCoord` can only represent a relative coordinate, which doesn't help us at all.\n\nSo, here we have to use the help from vertex shader. In vertex shader, we could get some `attribute` variables that are somehow useful. In OpenGL ES, we have three kinds of type specifiers: **uniform**, **attribute** and **varying**. Uniform variables are used for transmitting datas from CPU to GPU, the usage is as below :\n\n- Uniform variables are binded in your shader class in CPU and GPU so you have to subclass the Shader Base Class and override some methods here. First declare an int handle for binding location  and the variables that hold your data along with the variable name in your shader (glsl) file.\n\n```\nfinal private String uMyDataName = \"uMyData\";\nprivate int muMyDataHandle;\npublic float MyData;\n```\n\n- Remember to set the default value for your data when initializing.\n\n```\npublic MyShader() {\n\tMyData = 1.0f;\n}\n```\n\n- Override setLocations method to get uniform variable location from programHandle.\n\n```\n@Override\npublic void setLocations(final int programHandle)\n{\n\tsuper.setLocations(programHandle);\n\tmuMyDataHandle = getUniformLocation(programHandle, uMyDataName);\n}\n```\n\n- Override applyParams method to apply every change of your uniform variable, also you can call `glUniform1f` method directly to pass the value into shader.\n\n```\n@Override\npublic void applyParams() {\n\tsuper.applyParams();\n\tGLES20.glUniform1f(muMyDataHandle, MyData);\n}\n```\n\n- In your shader (glsl) file, add your new variable and call this variable wherever you want.\n\n```\nuniform float uMyData;\n\nvoid main () {\n\t// get uMyData here\n}\n```\n\n- When you want to change the value of `uMyData` , just change  the value of `MyShader.MyData`.\n\nAttribute variables can only be used in vertex shaders. In Rajawali, you can call `addAttribute` to directly add custom attribute and use `GLES20.glVertexAttribPointer` to set value for the attribute variable handler. Here we have several attribute variables as below :\n\n- aPosition\n- aTextureCoord\n- aNormal\n- aVertexColor\n\nAmong them, **aPosition** is the most useful variable for us, it represents the vector from (0,0,0) for current vertex in model projection. **aTextureCoord** is the source of **vTextureCoord** in fragment shader. As you can see, **vTextureCoord** has a type specifier '**varying**', it's used for transmitting variables from vertex shader to fragment shader. Here it's involved with some concept of the **pipline** procedure for OpenGL, what we need to know is that we could declare **'varying float A'** both in vertex shader and fragment shader at the same time, while write in vertex shader and read in fragment shader.\n\n### Let's begin!\n\nSo, here, in order to solve the scaling problem mentioned above, we declare three scale value for x, y and z :\n\n```\nuniform float uScaleZ;\nuniform float uScaleX;\nuniform float uScaleY;\n\n// We should get current width from CPU\nuniform float uWidth;\n\n// Pass everything above to fragment shader\nvarying float vScaleZ;\nvarying float vScaleX;\nvarying float vScaleY;\n\nvarying float vWidth;\n```\n\nAnd make the vertex scale in vertex shader by changing its position :\n\n```\nvec3 directionVec = vec3(aPosition.x,aPosition.y,aPosition.z);\nvec4 timeVec = vec4(directionVec, 1.0);\n\n// Scale each axis\ntimeVec.x = directionVec.x * uScaleX;\ntimeVec.y = directionVec.y * uScaleY;\ntimeVec.z = directionVec.z * uScaleZ;\n\nvec4 newPosition = uMVPMatrix * timeVec;\ngl_Position = newPosition;\nvTextureCoord = aTextureCoord;\n```\n\nIn fact, because we are going to draw colors on mesh in fragment shader, we should pass all the variables about scaling and position from vertex shader to fragment shader. So we have to add a `vec3` :\n\n```\nvarying vec3 vTimeVec;\n```\n\nAnd in `main()` add :\n\n```\nvec3 tmpVec = vec3(timeVec.x,timeVec.y,timeVec.z);\nvTimeVec = tmpVec;\n```\n\n### Next, what should we do in fragment shader?\n\nFirst, declare everything we need to get from vertex shader :\n\n```\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec3 vTimeVec;\n\nvarying float vScaleZ;\nvarying float vScaleX;\nvarying float vScaleY;\n\nvarying float vWidth;\n```\n\nThe most important step here is that when we set width for line, fragment shader should exactly split it into two parts which are drawn on different meshes. It's easy to understand, 1/2 for left side and the other 1/2 for the right side.\n\n```\nconst float GT = 1.0;\nconst float LT = 0.0;\n\nvoid main() {\n    vec4 newColor = vec4(0.0,0.0,0.0,1.0);\n    float lineWidth = 0.004;\n\n    float leftX = - (vWidth * vScaleX / 2.0) + lineWidth;\n    float rightX = (vWidth * vScaleX / 2.0) - lineWidth / 2.0;\n    \n    float bottomY = - (vWidth * vScaleY / 2.0) + lineWidth;\n    float topY = (vWidth * vScaleY / 2.0) - lineWidth / 2.0;\n\n    float backZ = - (vWidth * vScaleZ / 2.0) + lineWidth;\n    float frontZ = (vWidth * vScaleZ / 2.0) - lineWidth / 2.0;\n\n    float rX = smoothstep(leftX,rightX,vTimeVec.x);\n    float rZ = smoothstep(backZ,frontZ,vTimeVec.z);\n    float rY = smoothstep(bottomY,topY,vTimeVec.y);\n    \n    if (\n    (rX == GT && rY == GT) ||\n    (rX == GT && rZ == GT) ||\n    (rY == GT && rZ == GT) ||\n    (rX == LT && rY == LT) ||\n    (rX == LT && rZ == LT) ||\n    (rY == LT && rZ == LT) ||\n    (rX == GT && rY == LT) ||\n    (rX == GT && rZ == LT) ||\n    (rY == GT && rZ == LT) ||\n    (rX == LT && rY == GT) ||\n    (rX == LT && rZ == GT) ||\n    (rY == LT && rZ == GT)){\n    \t// Set your custom line color here\n         newColor.g = 0.659;\n         newColor.r = 0.976;\n         newColor.b = 0.192;\n    }\n\n    gl_FragColor = newColor;\n}\n```\n\n### Some more tricks with scaling\n\n![](https://ooo.0o0.ooo/2016/11/09/5822e8cb5bcc5.png)\n\nAs you can see from the image above, the 0 point for y and z axis of the model projection is in the middle of the cube. It's hard to modify a cube's anchor point here because there is no concept of anchor point here. But when we scale our cube, we may want it to scale based on one of its surfaces. How can we do that? I used method below to implement a demo for bottom-based and top-based scaling :\n\n- In vertex shader, change the shader script here :\n\n```\n// uScaleMode :\n// 1: top based\n// 2: bottom based\n\ntimeVec.x = directionVec.x * uScaleX;\ntimeVec.y = directionVec.y * uScaleY * 2.0;\ntimeVec.z = directionVec.z * uScaleZ;\n    \nif (uScaleMode == 1) {\n    if (timeVec.y < 0.0) {\n        timeVec.y = 0.0;\n    }\n} else {\n    if (timeVec.y > 0.0) {\n        timeVec.y = 0.0;\n    }\n}\n```\n\n- In fragment shader :\n\n```\nfloat bottomY;\nfloat topY;\n\nif (vScaleMode == 1.0) {\n    bottomY = lineWidth;\n    topY = vWidth * vScaleY - lineWidth / 2.0;\n} else {\n    bottomY =  - vWidth * vScaleY + lineWidth;\n    topY = - lineWidth / 2.0;\n}\n```\n\n### How to rorate using MVPMatrix ?\n\nHere is a discussion on [stackoverflow](http://stackoverflow.com/questions/15837177/using-matrix-rotate-in-opengl-es-2-0).\n\nIn Rajawali, we can also use MVPMatrix to rotate the object. Although Rajawali provides us method like `material.setMVPMatrix(mvpMatrix);` to set MVPMatrix, I found it not working correctly. The matrix cannot be correctly passed into vertex shader. So I add another uniform variable here, named it `uCMVPMatrix`.\n\nIn our custom Renderer which is a subclass of `RajawaliRenderer`,  add these variables :\n\n```\nprivate Matrix4 mvpMatrix;\nprivate double[] mvpMatrixValue = new double[16];\n\nprivate final double[] mModelMatrix = new double[16];\nprivate double[] mTempMatrix = new double[16];\n```\n\nWhen you finished initialization of your cube, get the MVPMatrix from it directly using :\n\n```\ncube = new Cube(...);\nmvpMatrix = cube.getModelViewProjectionMatrix();\nmvpMatrixValue = mvpMatrix.getDoubleValues();\n```\n\nThen, in `onRender`, doing Matrix calculation to rotate the cube :\n\n```\n@Override\npublic void onRender(final long elapsedTime, final double deltaTime) {\n\t...\n\tMatrix.setIdentityM(mModelMatrix, 0); // initialize to identity matrix\n    long time = SystemClock.uptimeMillis() % 4000L;\n    float mAngle = 0.090f * ((int) time);\n    Matrix.setRotateM(mModelMatrix, 0, mAngle, 0, 1.0f, 0.0);\n    \n    mTempMatrix = mvpMatrixValue.clone();\n    Matrix.multiplyMM(mvpMatrixValue, 0, mTempMatrix, 0, mModelMatrix, 0);\n    \n    mvpMatrix = mvpMatrix.setAll(mvpMatrixValue);\n    vertShader.CMVPMatrix = mvpMatrix.getFloatValues();\n}\n```\n\nIn our custom vertex shader, add a uniform handle for this `uCMVPMatrix` and send value to it :\n\n```\nprivate int muCMVPMatrixHandle;\npublic float[] CMVPMatrix;\n\n@Override\npublic void setLocations(final int programHandle)\n{\n    super.setLocations(programHandle);\n    ...\n    muCMVPMatrixHandle = getUniformLocation(programHandle, uCMVPMatrixName);\n}\n\n@Override\npublic void applyParams() {\n    super.applyParams();\n    ...\n    GLES20.glUniformMatrix4fv(muCMVPMatrixHandle, 1, false, CMVPMatrix, 0);\n}\n```\n\nThus, rotation using Matrix should be easy in Rajawali !\n","source":"_posts/How-to-draw-a-Wireframe-Shader-for-a-Cube-in-Rajawali-under-OpenGL-ES-2-0.md","raw":"title: How to draw a Wireframe Shader for a Cube in Rajawali under OpenGL ES 2.0\ndate: 2016-11-09 17:41:34\ncategories: 安卓菜鸟心得\n\n\ntags: [OpenGL ES, GLSL, Android, Shader, Wireframe]\n---\n\n> PS. This will be my first blog totally written in english.\n\n\n\n![](https://ooo.0o0.ooo/2016/11/09/58227c9f45765.png)\n\n## Setup\n\n> **Environment:** \n>\n> GLSL ES Version 100\n>\n> OpenGL ES Version 2.0\n>\n> Android 6.0\n>\n> Android OpenGL ES 2.0/3.0 Engine [Rajawali](https://github.com/Rajawali/Rajawali)\n\n## First Discuss\n\nThere are several ways to draw a wireframe for a cube in Rajawali engine. We can use \n\n```\ncube.setDrawingMode(GLES20.GL_LINE_STRIP);\n```\n\nto tell the cube to draw in wireframe mode. But because a Cube, or we can say, every Polygons or 3D Objects in OpenGL are formed by lots of dots, lines and triangles, setting drawing mode will only show you such images like below : \n\n![](https://ooo.0o0.ooo/2016/11/09/5822d63584db6.png)\n\nAlso, when you set DrawingMode to GL_LINE_STRIP, your custom vertex or fragment shader won't work as usual. So you will see a cube full of lines, doesn't it look messy to you?\n\nIn order to draw wireframe using fragment shader, we can simply use following fragement shader :\n\n```\nprecision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main() {\n        vec4 newColor = vec4(0.0, 0.0, 0.0, 1.0);\n        float x = min(vTextureCoord.s, 1.0 - vTextureCoord.s);\n        float y = min(vTextureCoord.t, 1.0 - vTextureCoord.t);\n\n        float line_width = 0.01;\n        \n        if (x < line_width) {\n            newColor.g = 1.0;\n            newColor.r = 1.0;\n            newColor.b = 1.0;\n        }\n\n        if (y < line_width) {\n            newColor.g = 1.0;\n            newColor.r = 1.0;\n            newColor.b = 1.0;\n        }\n        gl_FragColor = newColor;\n}\n```\n\nHowever, there is still a problem here. While using this shader, if you make your cube scale in whichever direction, this drawing 'Line' will always scale along with the cube. Obviously it's because the 0.01 we set here is a relative value. But the `vTextureCoord` we can get here which was passed by our vertex shader is only a `vec2` vector represented a 2D coordinate on this mesh, which can only range from (0.0 , 0.0) to (1.0 , 1.0). This means `vTextureCoord` can only represent a relative coordinate, which doesn't help us at all.\n\nSo, here we have to use the help from vertex shader. In vertex shader, we could get some `attribute` variables that are somehow useful. In OpenGL ES, we have three kinds of type specifiers: **uniform**, **attribute** and **varying**. Uniform variables are used for transmitting datas from CPU to GPU, the usage is as below :\n\n- Uniform variables are binded in your shader class in CPU and GPU so you have to subclass the Shader Base Class and override some methods here. First declare an int handle for binding location  and the variables that hold your data along with the variable name in your shader (glsl) file.\n\n```\nfinal private String uMyDataName = \"uMyData\";\nprivate int muMyDataHandle;\npublic float MyData;\n```\n\n- Remember to set the default value for your data when initializing.\n\n```\npublic MyShader() {\n\tMyData = 1.0f;\n}\n```\n\n- Override setLocations method to get uniform variable location from programHandle.\n\n```\n@Override\npublic void setLocations(final int programHandle)\n{\n\tsuper.setLocations(programHandle);\n\tmuMyDataHandle = getUniformLocation(programHandle, uMyDataName);\n}\n```\n\n- Override applyParams method to apply every change of your uniform variable, also you can call `glUniform1f` method directly to pass the value into shader.\n\n```\n@Override\npublic void applyParams() {\n\tsuper.applyParams();\n\tGLES20.glUniform1f(muMyDataHandle, MyData);\n}\n```\n\n- In your shader (glsl) file, add your new variable and call this variable wherever you want.\n\n```\nuniform float uMyData;\n\nvoid main () {\n\t// get uMyData here\n}\n```\n\n- When you want to change the value of `uMyData` , just change  the value of `MyShader.MyData`.\n\nAttribute variables can only be used in vertex shaders. In Rajawali, you can call `addAttribute` to directly add custom attribute and use `GLES20.glVertexAttribPointer` to set value for the attribute variable handler. Here we have several attribute variables as below :\n\n- aPosition\n- aTextureCoord\n- aNormal\n- aVertexColor\n\nAmong them, **aPosition** is the most useful variable for us, it represents the vector from (0,0,0) for current vertex in model projection. **aTextureCoord** is the source of **vTextureCoord** in fragment shader. As you can see, **vTextureCoord** has a type specifier '**varying**', it's used for transmitting variables from vertex shader to fragment shader. Here it's involved with some concept of the **pipline** procedure for OpenGL, what we need to know is that we could declare **'varying float A'** both in vertex shader and fragment shader at the same time, while write in vertex shader and read in fragment shader.\n\n### Let's begin!\n\nSo, here, in order to solve the scaling problem mentioned above, we declare three scale value for x, y and z :\n\n```\nuniform float uScaleZ;\nuniform float uScaleX;\nuniform float uScaleY;\n\n// We should get current width from CPU\nuniform float uWidth;\n\n// Pass everything above to fragment shader\nvarying float vScaleZ;\nvarying float vScaleX;\nvarying float vScaleY;\n\nvarying float vWidth;\n```\n\nAnd make the vertex scale in vertex shader by changing its position :\n\n```\nvec3 directionVec = vec3(aPosition.x,aPosition.y,aPosition.z);\nvec4 timeVec = vec4(directionVec, 1.0);\n\n// Scale each axis\ntimeVec.x = directionVec.x * uScaleX;\ntimeVec.y = directionVec.y * uScaleY;\ntimeVec.z = directionVec.z * uScaleZ;\n\nvec4 newPosition = uMVPMatrix * timeVec;\ngl_Position = newPosition;\nvTextureCoord = aTextureCoord;\n```\n\nIn fact, because we are going to draw colors on mesh in fragment shader, we should pass all the variables about scaling and position from vertex shader to fragment shader. So we have to add a `vec3` :\n\n```\nvarying vec3 vTimeVec;\n```\n\nAnd in `main()` add :\n\n```\nvec3 tmpVec = vec3(timeVec.x,timeVec.y,timeVec.z);\nvTimeVec = tmpVec;\n```\n\n### Next, what should we do in fragment shader?\n\nFirst, declare everything we need to get from vertex shader :\n\n```\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec3 vTimeVec;\n\nvarying float vScaleZ;\nvarying float vScaleX;\nvarying float vScaleY;\n\nvarying float vWidth;\n```\n\nThe most important step here is that when we set width for line, fragment shader should exactly split it into two parts which are drawn on different meshes. It's easy to understand, 1/2 for left side and the other 1/2 for the right side.\n\n```\nconst float GT = 1.0;\nconst float LT = 0.0;\n\nvoid main() {\n    vec4 newColor = vec4(0.0,0.0,0.0,1.0);\n    float lineWidth = 0.004;\n\n    float leftX = - (vWidth * vScaleX / 2.0) + lineWidth;\n    float rightX = (vWidth * vScaleX / 2.0) - lineWidth / 2.0;\n    \n    float bottomY = - (vWidth * vScaleY / 2.0) + lineWidth;\n    float topY = (vWidth * vScaleY / 2.0) - lineWidth / 2.0;\n\n    float backZ = - (vWidth * vScaleZ / 2.0) + lineWidth;\n    float frontZ = (vWidth * vScaleZ / 2.0) - lineWidth / 2.0;\n\n    float rX = smoothstep(leftX,rightX,vTimeVec.x);\n    float rZ = smoothstep(backZ,frontZ,vTimeVec.z);\n    float rY = smoothstep(bottomY,topY,vTimeVec.y);\n    \n    if (\n    (rX == GT && rY == GT) ||\n    (rX == GT && rZ == GT) ||\n    (rY == GT && rZ == GT) ||\n    (rX == LT && rY == LT) ||\n    (rX == LT && rZ == LT) ||\n    (rY == LT && rZ == LT) ||\n    (rX == GT && rY == LT) ||\n    (rX == GT && rZ == LT) ||\n    (rY == GT && rZ == LT) ||\n    (rX == LT && rY == GT) ||\n    (rX == LT && rZ == GT) ||\n    (rY == LT && rZ == GT)){\n    \t// Set your custom line color here\n         newColor.g = 0.659;\n         newColor.r = 0.976;\n         newColor.b = 0.192;\n    }\n\n    gl_FragColor = newColor;\n}\n```\n\n### Some more tricks with scaling\n\n![](https://ooo.0o0.ooo/2016/11/09/5822e8cb5bcc5.png)\n\nAs you can see from the image above, the 0 point for y and z axis of the model projection is in the middle of the cube. It's hard to modify a cube's anchor point here because there is no concept of anchor point here. But when we scale our cube, we may want it to scale based on one of its surfaces. How can we do that? I used method below to implement a demo for bottom-based and top-based scaling :\n\n- In vertex shader, change the shader script here :\n\n```\n// uScaleMode :\n// 1: top based\n// 2: bottom based\n\ntimeVec.x = directionVec.x * uScaleX;\ntimeVec.y = directionVec.y * uScaleY * 2.0;\ntimeVec.z = directionVec.z * uScaleZ;\n    \nif (uScaleMode == 1) {\n    if (timeVec.y < 0.0) {\n        timeVec.y = 0.0;\n    }\n} else {\n    if (timeVec.y > 0.0) {\n        timeVec.y = 0.0;\n    }\n}\n```\n\n- In fragment shader :\n\n```\nfloat bottomY;\nfloat topY;\n\nif (vScaleMode == 1.0) {\n    bottomY = lineWidth;\n    topY = vWidth * vScaleY - lineWidth / 2.0;\n} else {\n    bottomY =  - vWidth * vScaleY + lineWidth;\n    topY = - lineWidth / 2.0;\n}\n```\n\n### How to rorate using MVPMatrix ?\n\nHere is a discussion on [stackoverflow](http://stackoverflow.com/questions/15837177/using-matrix-rotate-in-opengl-es-2-0).\n\nIn Rajawali, we can also use MVPMatrix to rotate the object. Although Rajawali provides us method like `material.setMVPMatrix(mvpMatrix);` to set MVPMatrix, I found it not working correctly. The matrix cannot be correctly passed into vertex shader. So I add another uniform variable here, named it `uCMVPMatrix`.\n\nIn our custom Renderer which is a subclass of `RajawaliRenderer`,  add these variables :\n\n```\nprivate Matrix4 mvpMatrix;\nprivate double[] mvpMatrixValue = new double[16];\n\nprivate final double[] mModelMatrix = new double[16];\nprivate double[] mTempMatrix = new double[16];\n```\n\nWhen you finished initialization of your cube, get the MVPMatrix from it directly using :\n\n```\ncube = new Cube(...);\nmvpMatrix = cube.getModelViewProjectionMatrix();\nmvpMatrixValue = mvpMatrix.getDoubleValues();\n```\n\nThen, in `onRender`, doing Matrix calculation to rotate the cube :\n\n```\n@Override\npublic void onRender(final long elapsedTime, final double deltaTime) {\n\t...\n\tMatrix.setIdentityM(mModelMatrix, 0); // initialize to identity matrix\n    long time = SystemClock.uptimeMillis() % 4000L;\n    float mAngle = 0.090f * ((int) time);\n    Matrix.setRotateM(mModelMatrix, 0, mAngle, 0, 1.0f, 0.0);\n    \n    mTempMatrix = mvpMatrixValue.clone();\n    Matrix.multiplyMM(mvpMatrixValue, 0, mTempMatrix, 0, mModelMatrix, 0);\n    \n    mvpMatrix = mvpMatrix.setAll(mvpMatrixValue);\n    vertShader.CMVPMatrix = mvpMatrix.getFloatValues();\n}\n```\n\nIn our custom vertex shader, add a uniform handle for this `uCMVPMatrix` and send value to it :\n\n```\nprivate int muCMVPMatrixHandle;\npublic float[] CMVPMatrix;\n\n@Override\npublic void setLocations(final int programHandle)\n{\n    super.setLocations(programHandle);\n    ...\n    muCMVPMatrixHandle = getUniformLocation(programHandle, uCMVPMatrixName);\n}\n\n@Override\npublic void applyParams() {\n    super.applyParams();\n    ...\n    GLES20.glUniformMatrix4fv(muCMVPMatrixHandle, 1, false, CMVPMatrix, 0);\n}\n```\n\nThus, rotation using Matrix should be easy in Rajawali !\n","slug":"How-to-draw-a-Wireframe-Shader-for-a-Cube-in-Rajawali-under-OpenGL-ES-2-0","published":1,"updated":"2016-11-09T09:52:18.000Z","_id":"civaqnyx7003zj4rbn0l3an38","comments":1,"layout":"post","photos":[],"link":""},{"title":"AVAudioPlayer的几个细节","date":"2016-08-13T01:24:52.000Z","author":"Sergio Chan","_content":"\n昨天在做 iOS 上的声波传输的时候，倒是遇到了几个和  AVAudioPlayer 有关的有趣问题，这种问题一般情况下我们都注意不到，只要踩过了才知道。\n\n\n### 关于 PCM Data\n\n`AVAudioPlayer` 有一个初始化方法 `initWithData:error:`，这个方法的 API 说明是\n\n> /* all data must be in the form of an audio file understood by CoreAudio */\n\n在苹果的文档里，我们看到 AVAudioPlayer并不能支持 Stream 播放，它支持的文件格式有下面这些：\n\n| Format name           | Format filename extensions |\n| --------------------- | -------------------------- |\n| AIFF                  | `.aif`, `.aiff`            |\n| CAF                   | `.caf`                     |\n| MPEG-1, layer 3       | `.mp3`                     |\n| MPEG-2 or MPEG-4 ADTS | `.aac`                     |\n| MPEG-4                | `.m4a`, `.mp4`             |\n| WAV                   | `.wav`                     |\n\n\n\nStream 类型的音乐流只能被 AudioQueue 或者 AudioUnit 支持。因此要用 `AVAudioPlayer` 来播放 PCM 数据的话，注意要为这个 PCM 包加上 WAV 的 HEADER，然后将完整的 NSData 传给它。\n\n\n\n### 关于 Play\n\n`AVAudioPlayer` 还有个有趣的现象，我暂时没有找到官方文档的证据，那就是它的 `play` 不会对自身有一个引用来保持自己是活着的。**只要它的父类之上有一个对象被释放了，那它也就被一起释放掉了**。因此无论你是在第一层直接声明 self.audioPlayer play 还是 self.A.audioPlayer.play ，它的最上层父类必须有一个和 VC 相关或者全局相关的强引用，否则就会在 play 的时候就已经被释放掉了。\n\n","source":"_posts/AVAudioPlayer的几个细节.md","raw":"title: AVAudioPlayer的几个细节\ndate: 2016-08-13 09:24:52\ncategories: iOS菜鸟心得\nauthor: Sergio Chan\n\ntags: [AVAudioPlayer , AVFoundation]\n---\n\n昨天在做 iOS 上的声波传输的时候，倒是遇到了几个和  AVAudioPlayer 有关的有趣问题，这种问题一般情况下我们都注意不到，只要踩过了才知道。\n\n\n### 关于 PCM Data\n\n`AVAudioPlayer` 有一个初始化方法 `initWithData:error:`，这个方法的 API 说明是\n\n> /* all data must be in the form of an audio file understood by CoreAudio */\n\n在苹果的文档里，我们看到 AVAudioPlayer并不能支持 Stream 播放，它支持的文件格式有下面这些：\n\n| Format name           | Format filename extensions |\n| --------------------- | -------------------------- |\n| AIFF                  | `.aif`, `.aiff`            |\n| CAF                   | `.caf`                     |\n| MPEG-1, layer 3       | `.mp3`                     |\n| MPEG-2 or MPEG-4 ADTS | `.aac`                     |\n| MPEG-4                | `.m4a`, `.mp4`             |\n| WAV                   | `.wav`                     |\n\n\n\nStream 类型的音乐流只能被 AudioQueue 或者 AudioUnit 支持。因此要用 `AVAudioPlayer` 来播放 PCM 数据的话，注意要为这个 PCM 包加上 WAV 的 HEADER，然后将完整的 NSData 传给它。\n\n\n\n### 关于 Play\n\n`AVAudioPlayer` 还有个有趣的现象，我暂时没有找到官方文档的证据，那就是它的 `play` 不会对自身有一个引用来保持自己是活着的。**只要它的父类之上有一个对象被释放了，那它也就被一起释放掉了**。因此无论你是在第一层直接声明 self.audioPlayer play 还是 self.A.audioPlayer.play ，它的最上层父类必须有一个和 VC 相关或者全局相关的强引用，否则就会在 play 的时候就已经被释放掉了。\n\n","slug":"AVAudioPlayer的几个细节","published":1,"updated":"2016-08-13T01:25:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyxg004bj4rb6y0f98jz"},{"title":"ADB 两三事-残","date":"2016-10-24T04:24:50.000Z","_content":"\n\n\n折腾了两天 ADB， 宛若一个智障。遇到如下问题。\n\n## 从电脑 push 多个文件到设备 : wildCard\n\n参考[这篇](http://xmodulo.com/how-to-copy-or-transfer-multiple-files-to-android-devices.html)。\n\n一开始用 \\*.\\* 的方式将文件夹下的所有文件 push 到设备的目录下，但是始终失败。查无果，只看到了上面这篇说不支持的，于是看了下自己的 ADB 版本号，1.0.32。确认这个版本是不支持 wildCard 匹配文件的。遂将 \\*.\\* 这种表示方式改成了 shell 中的 for 循环。\n\n```\nfor i in `ls /Users/sergiochan/xxx/`\ndo\necho \"/Users/sergiochan/xxx/$i\"\nadb push \"/Users/sergiochan/xxx/$i\" /system/{destination}/\nadb push \"/Users/sergiochan/xxx/$i\" /system/{destination}/{subDestination}/\ndone\n```\n\n后来试了一下才发现升级到 1.0.36 是可以支持的。遂，卒。\n\n## ADB remount 显示 succeeded 却并没有成功挂载\n\n重启大法好哈哈哈哈哈哈。\n\n## 想要在 Android App 中运行 shell？\n\n可以说很麻烦么 =3=\n\n除非你是以 root 用户运行的 app，否则如果是普通用户的话，连 system 路径下的文件都没法修改，更别说 su 了。不过，如果想要修改 system 路径下的文件，可以在 manifest 中加上 **android:sharedUserId=\"android.uid.system\"** 让你的 app 以 system 用户运行，然后就可以直接通过 **FileOutputStream** 的方式修改 system 路径下的文件，例如控制 CPU 内存什么的。\n\n想要运行 shell ，可以在 ADB 命令行通过 ps 命令查看你的 package 运行的用户是谁，例如用户 test，如果你 `su test` 之后再运行 `su` 显示的是 **Permission Denied**，那就没有办法了。如果 root 过后的设备给你的运行用户配了用户权限什么的，那记得在 Android 中执行 shell 之前，执行一下 `su` :\n\n```\ntry {\n\tProcess process = Runtime.getRuntime().exec(\"su\");\n\tprocess.waitFor();\n} catch (IOException e) {\n\te.printStackTrace();\n} catch (InterruptedException e) {\n\te.printStackTrace();\n}\n```\n\n\n\n\n\n","source":"_posts/ADB-两三事-残.md","raw":"title: ADB 两三事-残\ndate: 2016-10-24 12:24:50\ncategories: 安卓菜鸟心得\n\n\ntags: [Android, ADB, Android Debug Bridge, 残念, 智障]\n---\n\n\n\n折腾了两天 ADB， 宛若一个智障。遇到如下问题。\n\n## 从电脑 push 多个文件到设备 : wildCard\n\n参考[这篇](http://xmodulo.com/how-to-copy-or-transfer-multiple-files-to-android-devices.html)。\n\n一开始用 \\*.\\* 的方式将文件夹下的所有文件 push 到设备的目录下，但是始终失败。查无果，只看到了上面这篇说不支持的，于是看了下自己的 ADB 版本号，1.0.32。确认这个版本是不支持 wildCard 匹配文件的。遂将 \\*.\\* 这种表示方式改成了 shell 中的 for 循环。\n\n```\nfor i in `ls /Users/sergiochan/xxx/`\ndo\necho \"/Users/sergiochan/xxx/$i\"\nadb push \"/Users/sergiochan/xxx/$i\" /system/{destination}/\nadb push \"/Users/sergiochan/xxx/$i\" /system/{destination}/{subDestination}/\ndone\n```\n\n后来试了一下才发现升级到 1.0.36 是可以支持的。遂，卒。\n\n## ADB remount 显示 succeeded 却并没有成功挂载\n\n重启大法好哈哈哈哈哈哈。\n\n## 想要在 Android App 中运行 shell？\n\n可以说很麻烦么 =3=\n\n除非你是以 root 用户运行的 app，否则如果是普通用户的话，连 system 路径下的文件都没法修改，更别说 su 了。不过，如果想要修改 system 路径下的文件，可以在 manifest 中加上 **android:sharedUserId=\"android.uid.system\"** 让你的 app 以 system 用户运行，然后就可以直接通过 **FileOutputStream** 的方式修改 system 路径下的文件，例如控制 CPU 内存什么的。\n\n想要运行 shell ，可以在 ADB 命令行通过 ps 命令查看你的 package 运行的用户是谁，例如用户 test，如果你 `su test` 之后再运行 `su` 显示的是 **Permission Denied**，那就没有办法了。如果 root 过后的设备给你的运行用户配了用户权限什么的，那记得在 Android 中执行 shell 之前，执行一下 `su` :\n\n```\ntry {\n\tProcess process = Runtime.getRuntime().exec(\"su\");\n\tprocess.waitFor();\n} catch (IOException e) {\n\te.printStackTrace();\n} catch (InterruptedException e) {\n\te.printStackTrace();\n}\n```\n\n\n\n\n\n","slug":"ADB-两三事-残","published":1,"updated":"2016-10-24T14:29:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyxq004gj4rb312agaaz"},{"title":"2016-09-05 基督山伯爵","date":"2016-09-05T07:11:17.000Z","_content":"\n\n\n昨天去潘家园的旧书市场淘了一圈，带回了一本老旧的《基督山伯爵》。曾经在我高三那段时光里成为我最爱的佳作之一。\n\n\n\n> \"要开发深藏在人类智慧里的神秘宝藏，就需要遭遇不幸；要想引爆炸药，就需要压力。\"   — 《基督山伯爵》","source":"_posts/2016-09-05-基督山伯爵.md","raw":"title: 2016-09-05 基督山伯爵\ndate: 2016-09-05 15:11:17\ncategories: 闲言碎语\ntags: [闲言碎语]\n---\n\n\n\n昨天去潘家园的旧书市场淘了一圈，带回了一本老旧的《基督山伯爵》。曾经在我高三那段时光里成为我最爱的佳作之一。\n\n\n\n> \"要开发深藏在人类智慧里的神秘宝藏，就需要遭遇不幸；要想引爆炸药，就需要压力。\"   — 《基督山伯爵》","slug":"2016-09-05-基督山伯爵","published":1,"updated":"2016-09-05T07:13:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyxy004rj4rbfigldw2f"},{"title":"2016-04-11 去战斗","date":"2016-04-11T08:55:11.000Z","_content":"\n> 遇到的挑战越大，获得的快感也越强\n> \n> -- 著名黑客凯文·米特尼克（Kevin Mitnick）","source":"_posts/2016-04-11-去战斗.md","raw":"title: 2016-04-11 去战斗\ndate: 2016-04-11 16:55:11\ncategories: 闲言碎语\ntags: [闲言碎语]\n---\n\n> 遇到的挑战越大，获得的快感也越强\n> \n> -- 著名黑客凯文·米特尼克（Kevin Mitnick）","slug":"2016-04-11-去战斗","published":1,"updated":"2016-08-19T06:35:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyye004vj4rb9k3j665z"},{"title":"2016.03.15","date":"2016-03-15T09:59:28.000Z","_content":"\n\n宠辱不惊。  \n努力去尝试吧，既然你能够有机会去改变世界了！\n\n一步步脚踏实地走下去。  \n种下汗水。","source":"_posts/2016-03-15.md","raw":"title: 2016.03.15\ndate: 2016-03-15 17:59:28\ncategories: 闲言碎语\n\ntags:\n---\n\n\n宠辱不惊。  \n努力去尝试吧，既然你能够有机会去改变世界了！\n\n一步步脚踏实地走下去。  \n种下汗水。","slug":"2016-03-15","published":1,"updated":"2016-03-15T10:02:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyyh004yj4rbvn6dalap"},{"title":"2015","date":"2015-12-21T12:13:17.000Z","_content":"\n# 看看去年底给自己定下的目标\n还是觉得自己的2015年过的蛮有意义的。回头看了看去年底写的对2015年的展望，发现去年对自己的展望基本在今年8月份左右就已经实现完了，反而是在九月之后经历了又一次巨大的跌宕起伏，有了很多意外的收获。一年过得实在是太充实……\n\n# 不得不说我的实习和工作经历  \n首先，我是在tata度过了从大四到毕业后的十个月，这里面的感情真的没法言说，这是我第一家稳定下来的公司，也是找到了归属感的团队。在公司里认识了一大帮子朋友，学了python，搭了一套newsfeed系统，尝试着做了一套TCP服务器间内部调用的框架。习惯了Linux服务器，习惯了shell，习惯了vim，在后端技能方面长进了太多。掌握了Redis和Mongo，学会了NoSQL的设计思想，当然部署和操作什么的都是简单的部分了。准备有空读Redis源码，大致看了一下感觉还好……同时也有了一定处理并发和较大规模系统的能力，在信息流系统并发较大的时候有了一定处理经验，这是我还在学校的时候最宝贵的经验，也是我去年底给自己定下的目标里写到的。对于一个还在大四的学生，有过处理百万级用户量的数据库和相当高的并发量的后端系统的经验真的是十分宝贵的。并且从陈健那儿学到了很多架构经验，很宝贵，这些架构思想极大的提高了我的系统设计能力。  \n遇到了老曹，很耐心的CTO，对我也十分的器重。谈不上人生导师，但对我的职业生涯，和对自己的定位都起了很大的影响，我开始明白自己应该怎么成长了，也懂得对自己做更好的职业生涯规划。同时整个全栈的知识体系和技能体系也变得丰富起来。  \n九月由于一些团队的原因，想要找个更高的平台提升自己，所以当时先是傻逼的在拉钩上投了微博小米和百度。可能在那个时候，还不是特别有信心直接就找内推，而且那个时候正好赶上秋招，机会还算蛮多的，于是打算自己先试试。第一个去的是微博。我在微博坐了半个小时没有人理我，做了一个小时的题也没有人给我倒杯水，二面的面试官也是急匆匆的就问完走了，并且在面试的过程中对我表示了极其明显的鄙视和轻蔑。虽然我在后来拉钩的评价上给了一颗星的差评，但是这段经历对我下半年最后几个月的转变是非常重要的。我开始明白我并不能要求所有人都对我满意，但是我至少还是得被一部分人认可，这样才不会说明我的所谓能力其实纯属扯淡。当我受到这样的对待的时候，虽然很大一部分是因为我是拉钩来的社招，并且他们甚至没有重视我刚毕业这个事实，而是认为我是刚跳槽的社会人员，但是我还是认为很大一部分原因出在自己的身上。回去之后，我开始更注重在工作中对自己能力的积累，我自己研究了runtime和runloop这些运行机制之后，发现天天写业务逻辑，和不懂技术瞎扯淡的产品经理配合简直就是对自己职业生涯的浪费和埋没，我被所谓需求所蒙蔽，根本难以接触到技术的真谛，我明白我需要做出一些改变了。所以才有了后来的波澜壮阔的历程。  \n第二个去的是百度。说实话这是我对百度印象最好的一次。然而最后的结局十分的无奈和可惜，百度砸在了O2O上，全面停止了社招，于是我阴差阳错的被自己误过了发出offer的时间点，错过了去百度的机会。但是百度的那次面试，前两面的面试官，以及最后三面电话里的负责人，都给了我非常好的印象，感觉真的可能是一个适合我的团队。并且二面的小哥，是我遇见的第一个会在面试的过程中打开我的博客和Github主页逐个问我并和我聊天的面试官。  \n不过还是那句话，上帝在给你关上一扇门的时候，总会给你打开另一扇窗户。所以当百度确认无法争取到offer之后，我当时满脑子只有一个想法，10月份的segmentfault Hackathon一定要好好玩，好好地和小萌配合一次，认真地，尽力的努力一次，去追求自己热爱和快乐的事情。  \n\n> 写下这些文字的时候，我正在踏上再次去寻找小萌的旅途。圣诞节将在杭州的西湖边度过。这一次，我想，既然我们已经找到了自己真正喜欢的事情，就一定要努力地奋斗下去。再不留遗憾。\n\n# Hackathoner\n2015年另一个意外就是接触到了Hackathon，并且与之陷入爱河。  \n第一次参加的是北航的Dorahacks Hackathon，忘记那次的报名信息是从哪儿看的了，好像是朋友圈谁转发的，于是就报名了，并且拉上了杨大神和邓晗。虽然在那次参赛之前我根本对Hackathon没有什么了解，但是也幸运的拿了第一，这次经历使我逐渐成为了一个狂热爱好Hackathon的Geek。后来参加了大众中国的Hackathon，和一堆MBA博士们一起比赛，被虐的体无完肤，才慢慢明白Hackathon不是自己想象中的那么单纯。第三次是十月份的SegmentFault Hackathon，将我从错过百度的阴影中拯救出来，接触到了非常纯粹的Hackathon。  \n> Hackathon 这部分可以参考我的[这篇博客](http://sergiochan.xyz/2015/12/19/%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9Hackathon%E7%9A%84%E7%90%86%E8%A7%A3/)。\n\n# iOS开发\n\n今年九月就是正式入坑iOS一周年，五月份把给公司产品写的第一个控件开源，来到了Github这个全球最大的男性社区，开始搞基。七月份开始写几个独立应用，除了密码管理的上架了，其他都夭折了，感觉写独立应用不是在开源社区里的成长方式，并且写独立应用对于自己的综合能力，包括设计,审美和创意之类的也都有一定要求，也许现在的我去写才会有一些感觉吧。后来总结出来的是，在开源社区的成长，要么写一个很好用的轮子，要么模仿一个很好看的应用，我肯定不想做后者……在公司里写业务写的就够累了，还花时间去模仿人家的客户端干嘛。所以也是纠结了好一段时间没东西写，一直到了九月份，还在写一些无关紧要的项目。第一个比较完整的项目就是开源了公司产品里头基于protobuf的模仿微信的网络请求框架。同时写了一个python的解数独的程序和基于TCP连接的服务器内部调用的框架。直到10月底才开始慢慢找到方向，从第一个试水的TableViewCell开始，逐渐写了一些或者好看的或者好用的或者有创意的轮子，一直到现在，也总共收获了一千多的star了，期间认识了无数开源社区里的基友，感慨时间匆匆，自己没有早点入坑。接下去还是会尽力把这些之前项目所积累的经验和开源的经验结合起来，创造更多更好用的交互模块。  \n一开始写一些开源的时候，DQ让我发到微博去获得一些关注，同时可以找到更多的人交流，于是我就尝试着进入了微博。没想到写的一些动效实现挺受欢迎的，于是就有了更多做下去和热爱的动力。我也在这个过程中认识了Martin老湿和XerLee大神，和一些比较有名的交互设计师有了更多的交流，实现了一些这些设计师做的设计，而且又有小萌和翻译组的一些小伙伴支持，于是就有了发起组织的想法。再加上马老湿又比较勤奋好学的开始写Swift并且尝试自己实现自己做的动效设计，所以就很快的搞在了一起，交流代码经验什么的。所以就慢慢步入了开源的正轨，成立了开源组，不过开头做了一点东西之后到年底了，小萌期末考，我们都忙着工作，所以有半个月对于开源组的贡献很少，毕竟每次从设计，到实现，最后产出一个完整的框架或者控件，然后还要整理出一篇通俗易懂，讲解合理生动的分享博文都是一件特别花时间和精力的事情，所以开源的工作实际上比想象中要复杂得多。\n\n# SwiftGG\n正式加入swiftGG翻译组，从翻译swift官方指南，到成立翻译组，开始翻译。加入SwiftGG这个逗比组是2015年最正确的选择之一。在组里接触了Swift，业余时间开始一点点的自学，虽然基本还是没有怎么使用。最主要的还是接触了一大帮翻译组的成员，以及接触了Swift中文大会，遇见和认识了来自全国各地天南海北的基友们，忽然有了好多基友可以交流技术问题，交流代码，交流开源，这种感觉真的是超级幸福。  \n明年1月10日的大会，感觉可以和天南海北的开发者们好好面基了😂\n\n# 博客\n开始稳定写博客，大概一个月一篇，速度有点慢，但是工作也忙。  \n比较注重博客质量，因为只有原创的好博客才能吸引一些读者吧，虽然最后确实有一些人关注我的博客 :-P  \n博客的历程比较曲折，一开始是在香港的虚拟主机里搭的Wordpress，用了半年多，自从七八月份开始莫名其妙被俄罗斯和乌克兰的黑客攻击，我的流量就没下来过 -。- 所以开始着手换到了Github上，迁移过程中丢弃了一些文章，所以现在的博客文章看起来并不多。后来刚迁移到Github之后，发生了惨无人道的水淹事件，我不小心把一杯水倒在了刚买的电脑上，导致尚未更新的Github的博客源文件丢失，后来过了两周才换了新电脑，这个过程中我的博客就处于了停滞的状态。直到最近才终于又稳定下来，继续维护和优化属于自己的个人站点和技术博客。  \n而且原域名已经被我弃用了，换成了现在的sergiochan.xyz。\n\n# 对自己明年的期望\n\n我明白自己的职业生涯到了最关键的冲刺期，在这个阶段里，我的经验，能力，眼界和社交圈都会飞速的膨胀，这一年从大学中脱离出来的经历已经让我明白了我之前在大学里浪费的两年多时光是多么的遗憾，但是幸运的是从2015年开始我走上了一条我到现在还觉得是正确的道路。  \n明年首先的愿望，或者是奢望，就是能够通过更多的Hackathon和开源，认识更多和我志同道合的朋友们，继续和小萌一起结对编程下去。希望能够运气好点再捞几个奖牌回来，前几天在2015年的收官之作中，又拿了一个第一，为我和小萌2015年的成长划上了一个完美的句号。  \n第二个愿望，就是好好把一起动画开源组给做起来。最近年末这段时间，由于自己刚搬家，比赛，大会什么的事情，马老师那里又有很多要忙的，小萌要考试，所以开源组一直没有产出新的好东西。但是等到新的一年开始之后，这些事情都要走到正轨上来了。我也希望这次面基大会认识的这一大帮国内走在前列的开发者，以后能够踊跃的交流，一起来把开源做好。  \n第三个期望，还是好好过日子吧。好好过着现在这样的稳定的小日子，这大概是一切以上所述事情的根基了吧。当感情开始漂泊，生活开始流浪的时候，事业就没有了稳定的基础。所以，珍惜眼前的一切，才是最重要的。\n\n当然，我明白，这些期望，最后，肯定远不及明年的收获。对于我来说，只要这样疯狂的向前冲，从中体会到乐趣和自己所热爱的事情，我想，我能走多远，只有最后才会明白吧。  \n","source":"_posts/2015.md","raw":"title: 2015\ndate: 2015-12-21 20:13:17\ncategories: 闲言碎语\ntags:\n---\n\n# 看看去年底给自己定下的目标\n还是觉得自己的2015年过的蛮有意义的。回头看了看去年底写的对2015年的展望，发现去年对自己的展望基本在今年8月份左右就已经实现完了，反而是在九月之后经历了又一次巨大的跌宕起伏，有了很多意外的收获。一年过得实在是太充实……\n\n# 不得不说我的实习和工作经历  \n首先，我是在tata度过了从大四到毕业后的十个月，这里面的感情真的没法言说，这是我第一家稳定下来的公司，也是找到了归属感的团队。在公司里认识了一大帮子朋友，学了python，搭了一套newsfeed系统，尝试着做了一套TCP服务器间内部调用的框架。习惯了Linux服务器，习惯了shell，习惯了vim，在后端技能方面长进了太多。掌握了Redis和Mongo，学会了NoSQL的设计思想，当然部署和操作什么的都是简单的部分了。准备有空读Redis源码，大致看了一下感觉还好……同时也有了一定处理并发和较大规模系统的能力，在信息流系统并发较大的时候有了一定处理经验，这是我还在学校的时候最宝贵的经验，也是我去年底给自己定下的目标里写到的。对于一个还在大四的学生，有过处理百万级用户量的数据库和相当高的并发量的后端系统的经验真的是十分宝贵的。并且从陈健那儿学到了很多架构经验，很宝贵，这些架构思想极大的提高了我的系统设计能力。  \n遇到了老曹，很耐心的CTO，对我也十分的器重。谈不上人生导师，但对我的职业生涯，和对自己的定位都起了很大的影响，我开始明白自己应该怎么成长了，也懂得对自己做更好的职业生涯规划。同时整个全栈的知识体系和技能体系也变得丰富起来。  \n九月由于一些团队的原因，想要找个更高的平台提升自己，所以当时先是傻逼的在拉钩上投了微博小米和百度。可能在那个时候，还不是特别有信心直接就找内推，而且那个时候正好赶上秋招，机会还算蛮多的，于是打算自己先试试。第一个去的是微博。我在微博坐了半个小时没有人理我，做了一个小时的题也没有人给我倒杯水，二面的面试官也是急匆匆的就问完走了，并且在面试的过程中对我表示了极其明显的鄙视和轻蔑。虽然我在后来拉钩的评价上给了一颗星的差评，但是这段经历对我下半年最后几个月的转变是非常重要的。我开始明白我并不能要求所有人都对我满意，但是我至少还是得被一部分人认可，这样才不会说明我的所谓能力其实纯属扯淡。当我受到这样的对待的时候，虽然很大一部分是因为我是拉钩来的社招，并且他们甚至没有重视我刚毕业这个事实，而是认为我是刚跳槽的社会人员，但是我还是认为很大一部分原因出在自己的身上。回去之后，我开始更注重在工作中对自己能力的积累，我自己研究了runtime和runloop这些运行机制之后，发现天天写业务逻辑，和不懂技术瞎扯淡的产品经理配合简直就是对自己职业生涯的浪费和埋没，我被所谓需求所蒙蔽，根本难以接触到技术的真谛，我明白我需要做出一些改变了。所以才有了后来的波澜壮阔的历程。  \n第二个去的是百度。说实话这是我对百度印象最好的一次。然而最后的结局十分的无奈和可惜，百度砸在了O2O上，全面停止了社招，于是我阴差阳错的被自己误过了发出offer的时间点，错过了去百度的机会。但是百度的那次面试，前两面的面试官，以及最后三面电话里的负责人，都给了我非常好的印象，感觉真的可能是一个适合我的团队。并且二面的小哥，是我遇见的第一个会在面试的过程中打开我的博客和Github主页逐个问我并和我聊天的面试官。  \n不过还是那句话，上帝在给你关上一扇门的时候，总会给你打开另一扇窗户。所以当百度确认无法争取到offer之后，我当时满脑子只有一个想法，10月份的segmentfault Hackathon一定要好好玩，好好地和小萌配合一次，认真地，尽力的努力一次，去追求自己热爱和快乐的事情。  \n\n> 写下这些文字的时候，我正在踏上再次去寻找小萌的旅途。圣诞节将在杭州的西湖边度过。这一次，我想，既然我们已经找到了自己真正喜欢的事情，就一定要努力地奋斗下去。再不留遗憾。\n\n# Hackathoner\n2015年另一个意外就是接触到了Hackathon，并且与之陷入爱河。  \n第一次参加的是北航的Dorahacks Hackathon，忘记那次的报名信息是从哪儿看的了，好像是朋友圈谁转发的，于是就报名了，并且拉上了杨大神和邓晗。虽然在那次参赛之前我根本对Hackathon没有什么了解，但是也幸运的拿了第一，这次经历使我逐渐成为了一个狂热爱好Hackathon的Geek。后来参加了大众中国的Hackathon，和一堆MBA博士们一起比赛，被虐的体无完肤，才慢慢明白Hackathon不是自己想象中的那么单纯。第三次是十月份的SegmentFault Hackathon，将我从错过百度的阴影中拯救出来，接触到了非常纯粹的Hackathon。  \n> Hackathon 这部分可以参考我的[这篇博客](http://sergiochan.xyz/2015/12/19/%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9Hackathon%E7%9A%84%E7%90%86%E8%A7%A3/)。\n\n# iOS开发\n\n今年九月就是正式入坑iOS一周年，五月份把给公司产品写的第一个控件开源，来到了Github这个全球最大的男性社区，开始搞基。七月份开始写几个独立应用，除了密码管理的上架了，其他都夭折了，感觉写独立应用不是在开源社区里的成长方式，并且写独立应用对于自己的综合能力，包括设计,审美和创意之类的也都有一定要求，也许现在的我去写才会有一些感觉吧。后来总结出来的是，在开源社区的成长，要么写一个很好用的轮子，要么模仿一个很好看的应用，我肯定不想做后者……在公司里写业务写的就够累了，还花时间去模仿人家的客户端干嘛。所以也是纠结了好一段时间没东西写，一直到了九月份，还在写一些无关紧要的项目。第一个比较完整的项目就是开源了公司产品里头基于protobuf的模仿微信的网络请求框架。同时写了一个python的解数独的程序和基于TCP连接的服务器内部调用的框架。直到10月底才开始慢慢找到方向，从第一个试水的TableViewCell开始，逐渐写了一些或者好看的或者好用的或者有创意的轮子，一直到现在，也总共收获了一千多的star了，期间认识了无数开源社区里的基友，感慨时间匆匆，自己没有早点入坑。接下去还是会尽力把这些之前项目所积累的经验和开源的经验结合起来，创造更多更好用的交互模块。  \n一开始写一些开源的时候，DQ让我发到微博去获得一些关注，同时可以找到更多的人交流，于是我就尝试着进入了微博。没想到写的一些动效实现挺受欢迎的，于是就有了更多做下去和热爱的动力。我也在这个过程中认识了Martin老湿和XerLee大神，和一些比较有名的交互设计师有了更多的交流，实现了一些这些设计师做的设计，而且又有小萌和翻译组的一些小伙伴支持，于是就有了发起组织的想法。再加上马老湿又比较勤奋好学的开始写Swift并且尝试自己实现自己做的动效设计，所以就很快的搞在了一起，交流代码经验什么的。所以就慢慢步入了开源的正轨，成立了开源组，不过开头做了一点东西之后到年底了，小萌期末考，我们都忙着工作，所以有半个月对于开源组的贡献很少，毕竟每次从设计，到实现，最后产出一个完整的框架或者控件，然后还要整理出一篇通俗易懂，讲解合理生动的分享博文都是一件特别花时间和精力的事情，所以开源的工作实际上比想象中要复杂得多。\n\n# SwiftGG\n正式加入swiftGG翻译组，从翻译swift官方指南，到成立翻译组，开始翻译。加入SwiftGG这个逗比组是2015年最正确的选择之一。在组里接触了Swift，业余时间开始一点点的自学，虽然基本还是没有怎么使用。最主要的还是接触了一大帮翻译组的成员，以及接触了Swift中文大会，遇见和认识了来自全国各地天南海北的基友们，忽然有了好多基友可以交流技术问题，交流代码，交流开源，这种感觉真的是超级幸福。  \n明年1月10日的大会，感觉可以和天南海北的开发者们好好面基了😂\n\n# 博客\n开始稳定写博客，大概一个月一篇，速度有点慢，但是工作也忙。  \n比较注重博客质量，因为只有原创的好博客才能吸引一些读者吧，虽然最后确实有一些人关注我的博客 :-P  \n博客的历程比较曲折，一开始是在香港的虚拟主机里搭的Wordpress，用了半年多，自从七八月份开始莫名其妙被俄罗斯和乌克兰的黑客攻击，我的流量就没下来过 -。- 所以开始着手换到了Github上，迁移过程中丢弃了一些文章，所以现在的博客文章看起来并不多。后来刚迁移到Github之后，发生了惨无人道的水淹事件，我不小心把一杯水倒在了刚买的电脑上，导致尚未更新的Github的博客源文件丢失，后来过了两周才换了新电脑，这个过程中我的博客就处于了停滞的状态。直到最近才终于又稳定下来，继续维护和优化属于自己的个人站点和技术博客。  \n而且原域名已经被我弃用了，换成了现在的sergiochan.xyz。\n\n# 对自己明年的期望\n\n我明白自己的职业生涯到了最关键的冲刺期，在这个阶段里，我的经验，能力，眼界和社交圈都会飞速的膨胀，这一年从大学中脱离出来的经历已经让我明白了我之前在大学里浪费的两年多时光是多么的遗憾，但是幸运的是从2015年开始我走上了一条我到现在还觉得是正确的道路。  \n明年首先的愿望，或者是奢望，就是能够通过更多的Hackathon和开源，认识更多和我志同道合的朋友们，继续和小萌一起结对编程下去。希望能够运气好点再捞几个奖牌回来，前几天在2015年的收官之作中，又拿了一个第一，为我和小萌2015年的成长划上了一个完美的句号。  \n第二个愿望，就是好好把一起动画开源组给做起来。最近年末这段时间，由于自己刚搬家，比赛，大会什么的事情，马老师那里又有很多要忙的，小萌要考试，所以开源组一直没有产出新的好东西。但是等到新的一年开始之后，这些事情都要走到正轨上来了。我也希望这次面基大会认识的这一大帮国内走在前列的开发者，以后能够踊跃的交流，一起来把开源做好。  \n第三个期望，还是好好过日子吧。好好过着现在这样的稳定的小日子，这大概是一切以上所述事情的根基了吧。当感情开始漂泊，生活开始流浪的时候，事业就没有了稳定的基础。所以，珍惜眼前的一切，才是最重要的。\n\n当然，我明白，这些期望，最后，肯定远不及明年的收获。对于我来说，只要这样疯狂的向前冲，从中体会到乐趣和自己所热爱的事情，我想，我能走多远，只有最后才会明白吧。  \n","slug":"2015","published":1,"updated":"2015-12-29T14:03:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civaqnyyn0050j4rbgniolf6f"}],"PostAsset":[],"PostCategory":[{"post_id":"civaqnytq0005j4rbwq9c6zja","category_id":"civaqnytw0006j4rbg7cdf9r0","_id":"civaqnyu00007j4rb2m2yud06"},{"post_id":"civaqnyu20008j4rbogkilg57","category_id":"civaqnyu50009j4rb38g31okf","_id":"civaqnyu9000cj4rb2ircqc51"},{"post_id":"civaqnyua000dj4rbgcrhyc6a","category_id":"civaqnytw0006j4rbg7cdf9r0","_id":"civaqnyuc000ej4rbmgs5ydyq"},{"post_id":"civaqnyud000fj4rbpfe43t34","category_id":"civaqnytw0006j4rbg7cdf9r0","_id":"civaqnyuf000gj4rbaqhjmc3q"},{"post_id":"civaqnyuh000ij4rb2az2bn99","category_id":"civaqnytw0006j4rbg7cdf9r0","_id":"civaqnyui000jj4rbh51t99ks"},{"post_id":"civaqnyuj000kj4rbsc3nni2v","category_id":"civaqnytw0006j4rbg7cdf9r0","_id":"civaqnyuk000lj4rbs0dvm8r0"},{"post_id":"civaqnyul000mj4rb7jvtgpql","category_id":"civaqnyuo000nj4rbab48yccg","_id":"civaqnyup000qj4rbipiy5ehh"},{"post_id":"civaqnyur000tj4rbhk13xk7f","category_id":"civaqnyut000uj4rbmakhk9hc","_id":"civaqnyuu0010j4rbte4mnkwk"},{"post_id":"civaqnyuw0016j4rb8zdjvjkd","category_id":"civaqnyuy0017j4rb1wft54fd","_id":"civaqnyv0001bj4rbgj52r410"},{"post_id":"civaqnyv5001fj4rb2y7vqgo6","category_id":"civaqnytw0006j4rbg7cdf9r0","_id":"civaqnyv8001gj4rbgj115zus"},{"post_id":"civaqnyva001lj4rbry74bziq","category_id":"civaqnyuy0017j4rb1wft54fd","_id":"civaqnyvd001mj4rbios0jboh"},{"post_id":"civaqnyvg001pj4rb62dyaz9o","category_id":"civaqnyuy0017j4rb1wft54fd","_id":"civaqnyvh001qj4rbsesa2xvl"},{"post_id":"civaqnyvn0021j4rbl5ui23oj","category_id":"civaqnytw0006j4rbg7cdf9r0","_id":"civaqnyvo0022j4rb13l5ityr"},{"post_id":"civaqnyvq0027j4rb0168gl3r","category_id":"civaqnyut000uj4rbmakhk9hc","_id":"civaqnyvs0028j4rbunvk3lmb"},{"post_id":"civaqnyvx002dj4rbgtof0onr","category_id":"civaqnyuy0017j4rb1wft54fd","_id":"civaqnyvy002ej4rb74ut7m09"},{"post_id":"civaqnyw2002lj4rb5ja8dmte","category_id":"civaqnyuy0017j4rb1wft54fd","_id":"civaqnyw3002mj4rb58jx25iu"},{"post_id":"civaqnyw6002tj4rbg478us3j","category_id":"civaqnyuy0017j4rb1wft54fd","_id":"civaqnyw7002uj4rbyyqjn3jk"},{"post_id":"civaqnywa002xj4rbxj9wp7pu","category_id":"civaqnywc002yj4rbcr4yk5vn","_id":"civaqnywd0031j4rbydc6vhyf"},{"post_id":"civaqnywh0035j4rbhu7ighqo","category_id":"civaqnywj0036j4rb7uolmt8i","_id":"civaqnywj0039j4rbkc74ex8r"},{"post_id":"civaqnywm003cj4rbcfqv1ual","category_id":"civaqnyuy0017j4rb1wft54fd","_id":"civaqnywn003dj4rba7rqcg1n"},{"post_id":"civaqnywp003gj4rbx8jp7edv","category_id":"civaqnywr003hj4rb2dn7b42j","_id":"civaqnywr003kj4rbvgf5bd70"},{"post_id":"civaqnywt003nj4rbcj8qmeec","category_id":"civaqnywx003oj4rbhzfj6xvz","_id":"civaqnywy003rj4rbt6nzs84s"},{"post_id":"civaqnyx3003uj4rbox90ow16","category_id":"civaqnytw0006j4rbg7cdf9r0","_id":"civaqnyx5003vj4rbp0meiryk"},{"post_id":"civaqnyxg004bj4rb6y0f98jz","category_id":"civaqnyuy0017j4rb1wft54fd","_id":"civaqnyxm004cj4rbeii96nbn"},{"post_id":"civaqnyxq004gj4rb312agaaz","category_id":"civaqnyx90040j4rbq08pw9ws","_id":"civaqnyxt004hj4rbnt3exbjw"},{"post_id":"civaqnyxy004rj4rbfigldw2f","category_id":"civaqnytw0006j4rbg7cdf9r0","_id":"civaqnyy5004sj4rbz4wccjyd"},{"post_id":"civaqnyye004vj4rb9k3j665z","category_id":"civaqnytw0006j4rbg7cdf9r0","_id":"civaqnyyg004wj4rbq4nthkwf"},{"post_id":"civaqnyyh004yj4rbvn6dalap","category_id":"civaqnytw0006j4rbg7cdf9r0","_id":"civaqnyyj004zj4rbr3lznh20"},{"post_id":"civaqnyyn0050j4rbgniolf6f","category_id":"civaqnytw0006j4rbg7cdf9r0","_id":"civaqnyyp0051j4rbjs5qn1au"},{"post_id":"civaqnyx7003zj4rbn0l3an38","category_id":"civaqnyx90040j4rbq08pw9ws","_id":"civaqyicm0000nlrbn8cqecli"}],"PostTag":[{"post_id":"civaqnyu20008j4rbogkilg57","tag_id":"civaqnyu6000aj4rbfh1nh9be","_id":"civaqnyu9000bj4rbpmcztd56"},{"post_id":"civaqnyud000fj4rbpfe43t34","tag_id":"civaqnyu6000aj4rbfh1nh9be","_id":"civaqnyug000hj4rbklslrqpg"},{"post_id":"civaqnyul000mj4rb7jvtgpql","tag_id":"civaqnyuo000oj4rb1xujyzs4","_id":"civaqnyup000rj4rbmsvt3s5r"},{"post_id":"civaqnyul000mj4rb7jvtgpql","tag_id":"civaqnyup000pj4rb032ywrw9","_id":"civaqnyuq000sj4rbcilztkft"},{"post_id":"civaqnyur000tj4rbhk13xk7f","tag_id":"civaqnyut000vj4rbnc0497he","_id":"civaqnyuu0011j4rb4lj4wfi4"},{"post_id":"civaqnyur000tj4rbhk13xk7f","tag_id":"civaqnyut000wj4rbo74fxflc","_id":"civaqnyuu0012j4rbbxqfin2j"},{"post_id":"civaqnyur000tj4rbhk13xk7f","tag_id":"civaqnyut000xj4rbkg4r678j","_id":"civaqnyuu0013j4rbvjvj94ck"},{"post_id":"civaqnyur000tj4rbhk13xk7f","tag_id":"civaqnyut000yj4rbny8ddmqa","_id":"civaqnyuu0014j4rbzp0m3sd3"},{"post_id":"civaqnyur000tj4rbhk13xk7f","tag_id":"civaqnyuu000zj4rb6oq639qm","_id":"civaqnyuu0015j4rb73snnjkm"},{"post_id":"civaqnyuw0016j4rb8zdjvjkd","tag_id":"civaqnyuy0018j4rbquvh0bni","_id":"civaqnyv0001cj4rbh3fw3a6u"},{"post_id":"civaqnyuw0016j4rb8zdjvjkd","tag_id":"civaqnyv00019j4rb8y4vd6xh","_id":"civaqnyv1001dj4rb81vnoaph"},{"post_id":"civaqnyuw0016j4rb8zdjvjkd","tag_id":"civaqnyv0001aj4rb94gfi2h7","_id":"civaqnyv1001ej4rbzob5beva"},{"post_id":"civaqnyv5001fj4rb2y7vqgo6","tag_id":"civaqnyv8001hj4rb0m5u6bps","_id":"civaqnyv8001jj4rbxtkxwd7i"},{"post_id":"civaqnyv5001fj4rb2y7vqgo6","tag_id":"civaqnyv8001ij4rbyqpu16gp","_id":"civaqnyv8001kj4rbn3c0klsj"},{"post_id":"civaqnyva001lj4rbry74bziq","tag_id":"civaqnyve001nj4rbg3u9tmjn","_id":"civaqnyve001oj4rbodxcq346"},{"post_id":"civaqnyvg001pj4rb62dyaz9o","tag_id":"civaqnyvh001rj4rb6ro0q5aw","_id":"civaqnyvk001wj4rb1g08hogf"},{"post_id":"civaqnyvg001pj4rb62dyaz9o","tag_id":"civaqnyvi001sj4rbaoff6g3y","_id":"civaqnyvk001xj4rbccxryw4y"},{"post_id":"civaqnyvg001pj4rb62dyaz9o","tag_id":"civaqnyvi001tj4rb48keaktr","_id":"civaqnyvk001yj4rbgl0cqqdd"},{"post_id":"civaqnyvg001pj4rb62dyaz9o","tag_id":"civaqnyvj001uj4rbxuyw88td","_id":"civaqnyvl001zj4rbn88t1704"},{"post_id":"civaqnyvg001pj4rb62dyaz9o","tag_id":"civaqnyvj001vj4rbh2phrmyv","_id":"civaqnyvl0020j4rba2ezs8ie"},{"post_id":"civaqnyvn0021j4rbl5ui23oj","tag_id":"civaqnyvo0023j4rbt4knw592","_id":"civaqnyvp0025j4rbatg6yusb"},{"post_id":"civaqnyvn0021j4rbl5ui23oj","tag_id":"civaqnyvp0024j4rbqf23eblv","_id":"civaqnyvp0026j4rbgrrmty73"},{"post_id":"civaqnyvq0027j4rb0168gl3r","tag_id":"civaqnyvs0029j4rbcebe4b8h","_id":"civaqnyvu002bj4rbj35bocaz"},{"post_id":"civaqnyvq0027j4rb0168gl3r","tag_id":"civaqnyvt002aj4rbha1ft066","_id":"civaqnyvu002cj4rb31mk5jd8"},{"post_id":"civaqnyvx002dj4rbgtof0onr","tag_id":"civaqnyvy002fj4rbsaz4yibc","_id":"civaqnyw0002ij4rbx00husq4"},{"post_id":"civaqnyvx002dj4rbgtof0onr","tag_id":"civaqnyvz002gj4rb9yabjffz","_id":"civaqnyw0002jj4rbmn0hl897"},{"post_id":"civaqnyvx002dj4rbgtof0onr","tag_id":"civaqnyvz002hj4rbnhvzyinv","_id":"civaqnyw0002kj4rbayug4lek"},{"post_id":"civaqnyw2002lj4rb5ja8dmte","tag_id":"civaqnyw3002nj4rbht0swf2f","_id":"civaqnyw4002qj4rbpql6s8tc"},{"post_id":"civaqnyw2002lj4rb5ja8dmte","tag_id":"civaqnyw3002oj4rbdofkwrxj","_id":"civaqnyw4002rj4rb3xvowbjo"},{"post_id":"civaqnyw2002lj4rb5ja8dmte","tag_id":"civaqnyw4002pj4rb6990tkgi","_id":"civaqnyw4002sj4rbax67tshe"},{"post_id":"civaqnyw6002tj4rbg478us3j","tag_id":"civaqnyw8002vj4rbm9k7g9t0","_id":"civaqnyw8002wj4rbnlapj2l4"},{"post_id":"civaqnywa002xj4rbxj9wp7pu","tag_id":"civaqnywc002zj4rbi5dkpku8","_id":"civaqnywe0032j4rboqr0aet5"},{"post_id":"civaqnywa002xj4rbxj9wp7pu","tag_id":"civaqnywd0030j4rbmzl1iuj7","_id":"civaqnywe0033j4rbgmrx1gvx"},{"post_id":"civaqnywa002xj4rbxj9wp7pu","tag_id":"civaqnyvy002fj4rbsaz4yibc","_id":"civaqnywe0034j4rbsc7w8s60"},{"post_id":"civaqnywh0035j4rbhu7ighqo","tag_id":"civaqnywj0037j4rb2qbo1tzt","_id":"civaqnywj003aj4rb8b8o62uh"},{"post_id":"civaqnywh0035j4rbhu7ighqo","tag_id":"civaqnywj0038j4rb2ze1w69g","_id":"civaqnywk003bj4rbhvvfjp6w"},{"post_id":"civaqnywm003cj4rbcfqv1ual","tag_id":"civaqnywn003ej4rb3smclgp1","_id":"civaqnywo003fj4rbmv6n532g"},{"post_id":"civaqnywp003gj4rbx8jp7edv","tag_id":"civaqnywr003ij4rbm3zrrzwh","_id":"civaqnywr003lj4rbxu7ms3pp"},{"post_id":"civaqnywp003gj4rbx8jp7edv","tag_id":"civaqnywr003jj4rb05ro9tfi","_id":"civaqnywr003mj4rb6w4t3evc"},{"post_id":"civaqnywt003nj4rbcj8qmeec","tag_id":"civaqnywx003pj4rbi3mredgd","_id":"civaqnywy003qj4rbtm8xjchy"},{"post_id":"civaqnywz003sj4rbi8r4tes2","tag_id":"civaqnyuo000oj4rb1xujyzs4","_id":"civaqnyx2003tj4rbujdfgz64"},{"post_id":"civaqnyx3003uj4rbox90ow16","tag_id":"civaqnywj0038j4rb2ze1w69g","_id":"civaqnyx6003xj4rb8ahnswto"},{"post_id":"civaqnyx3003uj4rbox90ow16","tag_id":"civaqnyx5003wj4rbxhbxqiuu","_id":"civaqnyx6003yj4rbyt50rpau"},{"post_id":"civaqnyx7003zj4rbn0l3an38","tag_id":"civaqnyx90041j4rbmy16u9e4","_id":"civaqnyxd0046j4rblp2qdmna"},{"post_id":"civaqnyx7003zj4rbn0l3an38","tag_id":"civaqnyxb0042j4rbrhsk26f8","_id":"civaqnyxe0047j4rb2g7m4dap"},{"post_id":"civaqnyx7003zj4rbn0l3an38","tag_id":"civaqnywd0030j4rbmzl1iuj7","_id":"civaqnyxe0048j4rbahayyybl"},{"post_id":"civaqnyx7003zj4rbn0l3an38","tag_id":"civaqnyxc0043j4rb1m8gyhn6","_id":"civaqnyxe0049j4rbpixict6o"},{"post_id":"civaqnyx7003zj4rbn0l3an38","tag_id":"civaqnyxd0044j4rbpv9gqzft","_id":"civaqnyxe004aj4rb6a78vh58"},{"post_id":"civaqnyxg004bj4rb6y0f98jz","tag_id":"civaqnyxn004dj4rbkbek7qfb","_id":"civaqnyxo004ej4rbigsnmrt0"},{"post_id":"civaqnyxg004bj4rb6y0f98jz","tag_id":"civaqnyup000pj4rb032ywrw9","_id":"civaqnyxo004fj4rb2nahokuo"},{"post_id":"civaqnyxq004gj4rb312agaaz","tag_id":"civaqnywd0030j4rbmzl1iuj7","_id":"civaqnyxv004mj4rbirf3g66u"},{"post_id":"civaqnyxq004gj4rb312agaaz","tag_id":"civaqnyxt004ij4rb5zgln5gy","_id":"civaqnyxv004nj4rbk2fnnrh3"},{"post_id":"civaqnyxq004gj4rb312agaaz","tag_id":"civaqnyxu004jj4rb2zx3hg8z","_id":"civaqnyxv004oj4rbe7vua75d"},{"post_id":"civaqnyxq004gj4rb312agaaz","tag_id":"civaqnyxu004kj4rb6jygjie5","_id":"civaqnyxv004pj4rbmx0gn2oe"},{"post_id":"civaqnyxq004gj4rb312agaaz","tag_id":"civaqnyxu004lj4rbma86i4f1","_id":"civaqnyxv004qj4rbf61ceioi"},{"post_id":"civaqnyxy004rj4rbfigldw2f","tag_id":"civaqnyy6004tj4rbrodstau9","_id":"civaqnyyb004uj4rb67alk3k9"},{"post_id":"civaqnyye004vj4rb9k3j665z","tag_id":"civaqnyy6004tj4rbrodstau9","_id":"civaqnyyg004xj4rb0edbv9my"}],"Tag":[{"name":"Hackathon","_id":"civaqnyu6000aj4rbfh1nh9be"},{"name":"Cocoa","_id":"civaqnyuo000oj4rb1xujyzs4"},{"name":"AVFoundation","_id":"civaqnyup000pj4rb032ywrw9"},{"name":"Newsfeed","_id":"civaqnyut000vj4rbnc0497he"},{"name":"celery","_id":"civaqnyut000wj4rbo74fxflc"},{"name":"djcelery","_id":"civaqnyut000xj4rbkg4r678j"},{"name":"redis","_id":"civaqnyut000yj4rbny8ddmqa"},{"name":"stream framework","_id":"civaqnyuu000zj4rb6oq639qm"},{"name":"WKWebView","_id":"civaqnyuy0018j4rbquvh0bni"},{"name":"WebKit","_id":"civaqnyv00019j4rb8y4vd6xh"},{"name":"Safari 阅读模式","_id":"civaqnyv0001aj4rb94gfi2h7"},{"name":"Unity","_id":"civaqnyv8001hj4rb0m5u6bps"},{"name":"Photon","_id":"civaqnyv8001ij4rbyqpu16gp"},{"name":"UITableView","_id":"civaqnyve001nj4rbg3u9tmjn"},{"name":"NSObject","_id":"civaqnyvh001rj4rb6ro0q5aw"},{"name":"id","_id":"civaqnyvi001sj4rbaoff6g3y"},{"name":"weak","_id":"civaqnyvi001tj4rb48keaktr"},{"name":"assign","_id":"civaqnyvj001uj4rbxuyw88td"},{"name":"NS_DESIGNATED_INITIALIZER","_id":"civaqnyvj001vj4rbh2phrmyv"},{"name":"哲学","_id":"civaqnyvo0023j4rbt4knw592"},{"name":"扯淡","_id":"civaqnyvp0024j4rbqf23eblv"},{"name":"tornado","_id":"civaqnyvs0029j4rbcebe4b8h"},{"name":"TCP","_id":"civaqnyvt002aj4rbha1ft066"},{"name":"iOS","_id":"civaqnyvy002fj4rbsaz4yibc"},{"name":"runloop","_id":"civaqnyvz002gj4rb9yabjffz"},{"name":"NSThread","_id":"civaqnyvz002hj4rbnhvzyinv"},{"name":"runtime","_id":"civaqnyw3002nj4rbht0swf2f"},{"name":"Objective-C","_id":"civaqnyw3002oj4rbdofkwrxj"},{"name":"objc_msgSend","_id":"civaqnyw4002pj4rb6990tkgi"},{"name":"iOS静态库","_id":"civaqnyw8002vj4rbm9k7g9t0"},{"name":"Airplay","_id":"civaqnywc002zj4rbi5dkpku8"},{"name":"Android","_id":"civaqnywd0030j4rbmzl1iuj7"},{"name":"Ubuntu","_id":"civaqnywj0037j4rb2qbo1tzt"},{"name":"MySQL","_id":"civaqnywj0038j4rb2ze1w69g"},{"name":"UIColor","_id":"civaqnywn003ej4rb3smclgp1"},{"name":"python","_id":"civaqnywr003ij4rbm3zrrzwh"},{"name":"python数独， 深度优先搜索","_id":"civaqnywr003jj4rb05ro9tfi"},{"name":"PHP图片处理，水印","_id":"civaqnywx003pj4rbi3mredgd"},{"name":"Leetcode","_id":"civaqnyx5003wj4rbxhbxqiuu"},{"name":"OpenGL ES","_id":"civaqnyx90041j4rbmy16u9e4"},{"name":"GLSL","_id":"civaqnyxb0042j4rbrhsk26f8"},{"name":"Shader","_id":"civaqnyxc0043j4rb1m8gyhn6"},{"name":"Wireframe","_id":"civaqnyxd0044j4rbpv9gqzft"},{"name":"AVAudioPlayer","_id":"civaqnyxn004dj4rbkbek7qfb"},{"name":"ADB","_id":"civaqnyxt004ij4rb5zgln5gy"},{"name":"Android Debug Bridge","_id":"civaqnyxu004jj4rb2zx3hg8z"},{"name":"残念","_id":"civaqnyxu004kj4rb6jygjie5"},{"name":"智障","_id":"civaqnyxu004lj4rbma86i4f1"},{"name":"闲言碎语","_id":"civaqnyy6004tj4rbrodstau9"}]}}