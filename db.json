{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0},{"_id":"source/tags/index.md","path":"tags/index.md","modified":0},{"_id":"source/categories/index.md","path":"categories/index.md","modified":0},{"_id":"source/bio/index.md","path":"bio/index.md","modified":0},{"_id":"source/about/index.md","path":"about/index.md","modified":0},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0},{"_id":"themes/next/source/js/ua-parser.min.js","path":"js/ua-parser.min.js","modified":0},{"_id":"themes/next/source/js/nav-toggle.js","path":"js/nav-toggle.js","modified":0},{"_id":"themes/next/source/js/motion_global.js","path":"js/motion_global.js","modified":0},{"_id":"themes/next/source/js/motion_fallback.js","path":"js/motion_fallback.js","modified":0},{"_id":"themes/next/source/js/lazyload.js","path":"js/lazyload.js","modified":0},{"_id":"themes/next/source/js/hook-duoshuo.js","path":"js/hook-duoshuo.js","modified":0},{"_id":"themes/next/source/js/helpers.js","path":"js/helpers.js","modified":0},{"_id":"themes/next/source/js/fancy-box.js","path":"js/fancy-box.js","modified":0},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","path":"js/bootstrap.scrollspy.js","modified":0},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0},{"_id":"themes/next/source/images/bkdefault_avatar.jpg","path":"images/bkdefault_avatar.jpg","modified":0},{"_id":"themes/next/source/fonts/icon-linecons/selection.json","path":"fonts/icon-linecons/selection.json","modified":0},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.woff","path":"fonts/icon-linecons/icomoon.woff","modified":0},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.ttf","path":"fonts/icon-linecons/icomoon.ttf","modified":0},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.svg","path":"fonts/icon-linecons/icomoon.svg","modified":0},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.eot","path":"fonts/icon-linecons/icomoon.eot","modified":0},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.woff","path":"fonts/icon-icomoon/icomoon.woff","modified":0},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.ttf","path":"fonts/icon-icomoon/icomoon.ttf","modified":0},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.svg","path":"fonts/icon-icomoon/icomoon.svg","modified":0},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.eot","path":"fonts/icon-icomoon/icomoon.eot","modified":0},{"_id":"themes/next/source/fonts/icon-fifty-shades/selection.json","path":"fonts/icon-fifty-shades/selection.json","modified":0},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.woff","path":"fonts/icon-fifty-shades/icomoon.woff","modified":0},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.ttf","path":"fonts/icon-fifty-shades/icomoon.ttf","modified":0},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.svg","path":"fonts/icon-fifty-shades/icomoon.svg","modified":0},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.eot","path":"fonts/icon-fifty-shades/icomoon.eot","modified":0},{"_id":"themes/next/source/fonts/icon-feather/selection.json","path":"fonts/icon-feather/selection.json","modified":0},{"_id":"themes/next/source/fonts/icon-feather/icomoon.woff","path":"fonts/icon-feather/icomoon.woff","modified":0},{"_id":"themes/next/source/fonts/icon-feather/icomoon.ttf","path":"fonts/icon-feather/icomoon.ttf","modified":0},{"_id":"themes/next/source/fonts/icon-feather/icomoon.svg","path":"fonts/icon-feather/icomoon.svg","modified":0},{"_id":"themes/next/source/fonts/icon-feather/icomoon.eot","path":"fonts/icon-feather/icomoon.eot","modified":0},{"_id":"themes/next/source/fonts/icon-default/selection.json","path":"fonts/icon-default/selection.json","modified":0},{"_id":"themes/next/source/fonts/icon-default/icomoon.woff","path":"fonts/icon-default/icomoon.woff","modified":0},{"_id":"themes/next/source/fonts/icon-default/icomoon.ttf","path":"fonts/icon-default/icomoon.ttf","modified":0},{"_id":"themes/next/source/fonts/icon-default/icomoon.svg","path":"fonts/icon-default/icomoon.svg","modified":0},{"_id":"themes/next/source/fonts/icon-default/icomoon.eot","path":"fonts/icon-default/icomoon.eot","modified":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0}],"Cache":[{"_id":"source/CNAME","shasum":"7f17f1abc6cc7bee5d79b462cc845cf88dd9f264","modified":1450444394000},{"_id":"source/_posts/PHP图片处理-透明水印的处理和添加.md","shasum":"da01449bbd70f07447cc2852485b617e81b49501","modified":1450444394000},{"_id":"source/_posts/Python利用深度优先搜索解数独程序的实现.md","shasum":"645937ab037e1b57ce1a7fad8b8f9987f9cfa29f","modified":1450444394000},{"_id":"source/_posts/UIColor-colorWithRed-green-blue-alpha-的正确用法.md","shasum":"f8116157bcac938f0c0d8abed2774320d4212384","modified":1450444394000},{"_id":"source/_posts/Ubuntu下重置MySQL的root密码.md","shasum":"a7d6cd7c7c27bae0d02ef1dd7541919bb20400e8","modified":1450444394000},{"_id":"source/_posts/iOS-静态库封装和使用方法.md","shasum":"a9bdadfe6a5700b2c6ca2f2ba21056a50d895a00","modified":1450444394000},{"_id":"source/_posts/objective-c-runtime是什么.md","shasum":"6b216153d688984072105fa7cca3b3aa26f85440","modified":1450444394000},{"_id":"source/_posts/runloop初窥.md","shasum":"673349bd36401bc9599514a79843bfe33973fe70","modified":1450444394000},{"_id":"source/about/index.md","shasum":"2634d4f434877d9da6309cbe632681600b065c78","modified":1450444394000},{"_id":"source/bio/index.md","shasum":"0c26430b945daadeb6f4a3292c5c201eedb38f14","modified":1450444394000},{"_id":"source/categories/index.md","shasum":"dd21c2757a9a209e61420a56d43b098f8be939f9","modified":1450444394000},{"_id":"source/tags/index.md","shasum":"10b20c72c2ff5380a35fdd1dbdd24c0f0e5f7c71","modified":1450444394000},{"_id":"themes/next/source/css/_common/_page/home.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450444394000},{"_id":"themes/next/source/css/_mixins/Mist.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450444394000},{"_id":"themes/next/source/css/_mixins/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450444394000},{"_id":"themes/next/source/css/_mixins/default.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450444394000},{"_id":"themes/next/source/css/_variables/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450444394000},{"_id":"themes/next/source/css/_variables/default.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450444394000},{"_id":"themes/next/README.en.md","shasum":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1450444394000},{"_id":"themes/next/README.md","shasum":"3319de8565699fc9642f76c41ee96b50f2234b6a","modified":1450444394000},{"_id":"themes/next/_config.yml","shasum":"5288cb35155425a009b54cd09e9d38ffec6083dc","modified":1450444394000},{"_id":"themes/next/bower.json","shasum":"c27f03e42e91a205f1b2acbcf562f8b66e5a23c6","modified":1450444394000},{"_id":"themes/next/languages/de.yml","shasum":"7a8de0e5665c52a1bf168c1e7dd222c8a74fb0ab","modified":1450444394000},{"_id":"themes/next/languages/default.yml","shasum":"7e65ef918f16d0189055deb5f1616b9dedcb1920","modified":1450444394000},{"_id":"themes/next/languages/en.yml","shasum":"7e65ef918f16d0189055deb5f1616b9dedcb1920","modified":1450444394000},{"_id":"themes/next/languages/fr-FR.yml","shasum":"6d097445342a9fb5235afea35d65bf5271b772f0","modified":1450444394000},{"_id":"themes/next/languages/pt.yml","shasum":"737225eee4b91f64db61742ce3f4ab4e8c039286","modified":1450444394000},{"_id":"themes/next/languages/ru.yml","shasum":"b4a827b9ddac9d5f6dca096fe513aeafb46a3e93","modified":1450444394000},{"_id":"themes/next/languages/zh-Hans.yml","shasum":"fa5d279468e05c0fecc4783155d8af8b9349223c","modified":1450444394000},{"_id":"themes/next/languages/zh-hk.yml","shasum":"3fc38103c9efa6f6c37149adbddb014ff85ec849","modified":1450444394000},{"_id":"themes/next/languages/zh-tw.yml","shasum":"8897a06e521b36c7a1226c72057c8357611eded8","modified":1450444394000},{"_id":"themes/next/layout/_layout.swig","shasum":"2d3929b51a1c8397dc9b3d83e1ffc47f472abdb7","modified":1450444394000},{"_id":"themes/next/layout/_macro/post-collapse.swig","shasum":"9032ae9056cb19b4c2d069d66ead7abf828f9922","modified":1450444394000},{"_id":"themes/next/layout/_macro/post.swig","shasum":"b3cd721e5100991a0fa85d966afbf22f7b0d62ef","modified":1450444394000},{"_id":"themes/next/layout/_macro/sidebar.swig","shasum":"5ca90268bc26a351536b93d8c2f73c297cd5f4f8","modified":1450444394000},{"_id":"themes/next/layout/_partials/footer.swig","shasum":"548adcd523baec2e158203fc143a646e42a8d7d1","modified":1450444394000},{"_id":"themes/next/layout/_partials/head.swig","shasum":"c6f0d2c77f41a10e661177972195905116b175c1","modified":1450444394000},{"_id":"themes/next/layout/_partials/header.swig","shasum":"7450eb2513622ea4d59a3a7881816ce1c13ffa84","modified":1450444394000},{"_id":"themes/next/layout/_partials/old-browsers.swig","shasum":"dbbfea810bf3a2ed9c83b9a6683037175aacfc67","modified":1450444394000},{"_id":"themes/next/layout/_partials/pagination.swig","shasum":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1450444394000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","shasum":"00c2b49f6289198b0b2b4e157e4ee783277f32a7","modified":1450444394000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","shasum":"eefe2388ff3d424694045eda21346989b123977c","modified":1450444394000},{"_id":"themes/next/layout/_partials/search.swig","shasum":"64f14da26792a17bc27836c4e9d83190175f36e6","modified":1450444394000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","shasum":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1450444394000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","shasum":"63315fcf210799f894208c9f512737096df84962","modified":1450444394000},{"_id":"themes/next/layout/_scripts/analytics/baidu-analytics.swig","shasum":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1450444394000},{"_id":"themes/next/layout/_scripts/analytics/facebook-sdk.swig","shasum":"334176d838ee528e58468d8bc74ff3a6d3f25b2b","modified":1450444394000},{"_id":"themes/next/layout/_scripts/analytics/google-analytics.swig","shasum":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1450444394000},{"_id":"themes/next/layout/_scripts/analytics.swig","shasum":"33ca06b9bd9a15a19432d5396b85bd319f017319","modified":1450444394000},{"_id":"themes/next/layout/_scripts/baidushare.swig","shasum":"d726361945437cf6e48067b3dd041b7e36e98d85","modified":1450444394000},{"_id":"themes/next/layout/_scripts/bootstrap.scrollspy.swig","shasum":"85295f126836b95f0837d03e58228bb3cf8c4490","modified":1450444394000},{"_id":"themes/next/layout/_scripts/comments/disqus.swig","shasum":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1450444394000},{"_id":"themes/next/layout/_scripts/comments/duoshuo.swig","shasum":"06b6cfaa9f2e05a9b0e8eb7c6d37cca92bcb9c77","modified":1450444394000},{"_id":"themes/next/layout/_scripts/fancy-box.swig","shasum":"41b4ff1446060c88c33bf666a32277dcf12129f0","modified":1450444394000},{"_id":"themes/next/layout/_scripts/helpers.swig","shasum":"4d2cbfca0aaf546a2b5813288073e824c1498fdf","modified":1450444394000},{"_id":"themes/next/layout/_scripts/mathjax.swig","shasum":"df03220eb8526e17dc9c9f17780c2d6699367181","modified":1450444394000},{"_id":"themes/next/layout/_scripts/motion.swig","shasum":"817705bfd1a1282cb6bf59094afe507e11455aa0","modified":1450444394000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","shasum":"a6cbba49a78648a2345d1fc94c1abd14b2c3c6ba","modified":1450444394000},{"_id":"themes/next/layout/_scripts/tinysou.swig","shasum":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1450444394000},{"_id":"themes/next/layout/archive.swig","shasum":"0c3ce594759f347ea90a4ce592a7a18e2ae4cc5c","modified":1450444394000},{"_id":"themes/next/layout/category.swig","shasum":"d6b3e1dc5e0b8deade9a084c463126e70188ee9b","modified":1450444394000},{"_id":"themes/next/layout/index.swig","shasum":"fdc801f0da71a2eb205ce9c0b12f156b219fdc9c","modified":1450444394000},{"_id":"themes/next/layout/page.swig","shasum":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1450444394000},{"_id":"themes/next/layout/post.swig","shasum":"a84457e8ced46e63bc7a8a9e0541a6ba53122a92","modified":1450444394000},{"_id":"themes/next/layout/tag.swig","shasum":"aab44af54fcbc66fea4ad12b2767ffca3eadd451","modified":1450444394000},{"_id":"themes/next/scripts/merge-configs.js","shasum":"dfd147d1317e56d283f5e779f00608e913603b51","modified":1450444394000},{"_id":"themes/next/scripts/tags/center-quote.js","shasum":"535fc542781021c4326dec24d8495cbb1387634a","modified":1450444394000},{"_id":"themes/next/scripts/tags/full-image.js","shasum":"6329dc1815721050fd4c24a8accd8f4cbdb52330","modified":1450444394000},{"_id":"themes/next/scripts/tags/group-pictures.js","shasum":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1450444394000},{"_id":"themes/next/source/css/_common/_component/back-to-top.styl","shasum":"88cd66910260006aa8e9e795df4948d4b67bfa11","modified":1450444394000},{"_id":"themes/next/source/css/_common/_component/blockquote-center.styl","shasum":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1450444394000},{"_id":"themes/next/source/css/_common/_component/buttons.styl","shasum":"81063e0979f04a0f9af37f321d7321dda9abf593","modified":1450444394000},{"_id":"themes/next/source/css/_common/_component/comments.styl","shasum":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1450444394000},{"_id":"themes/next/source/css/_common/_component/duoshuo.styl","shasum":"6ad988254fe34a03e8ddfa8d4941e196bd07d238","modified":1450444394000},{"_id":"themes/next/source/css/_common/_component/group-pictures.styl","shasum":"1ee40743000173495728855f734081eb2b6167cc","modified":1450444394000},{"_id":"themes/next/source/css/_common/_component/gallery.styl","shasum":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1450444394000},{"_id":"themes/next/source/css/_common/_component/jiathis.styl","shasum":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1450444394000},{"_id":"themes/next/source/css/_common/_component/pagination.styl","shasum":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1450444394000},{"_id":"themes/next/source/css/_common/_component/posts-collapse.styl","shasum":"6750b61236eb359028da8f2c4765f7c89b03dc9a","modified":1450444394000},{"_id":"themes/next/source/css/_common/_component/posts-expand.styl","shasum":"494bed4c864b3a98f443cba6793523384f6f8d12","modified":1450444394000},{"_id":"themes/next/source/css/_common/_component/posts-type.styl","shasum":"40b593134bf96d1d6095b3439d47820659d7f10b","modified":1450444394000},{"_id":"themes/next/source/css/_common/_component/posts.styl","shasum":"c3cbb56b3fc836af28db094da30ba74ff58245cd","modified":1450444394000},{"_id":"themes/next/source/css/_common/_component/tag-cloud.styl","shasum":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1450444394000},{"_id":"themes/next/source/css/_common/_core/base.styl","shasum":"920c4de5e19faa8fcaff3c5f585af41f4f553cbf","modified":1450444394000},{"_id":"themes/next/source/css/_common/_core/helpers.styl","shasum":"d339d114e52a9abbc797ec236a8a770c29e288a6","modified":1450444394000},{"_id":"themes/next/source/css/_common/_core/normalize.styl","shasum":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1450444394000},{"_id":"themes/next/source/css/_common/_core/scaffolding.styl","shasum":"1f8acb3331300eec696a09e7859e11f191e16d7f","modified":1450444394000},{"_id":"themes/next/source/css/_common/_core/tables.styl","shasum":"5f766cf26f966dbf9dcfe681f40ab9032e3e8a08","modified":1450444394000},{"_id":"themes/next/source/css/_common/_fonts/icon-default.styl","shasum":"8b809aef383bebaeb3f282b47675f3a364ce3569","modified":1450444394000},{"_id":"themes/next/source/css/_common/_fonts/icon-feather.styl","shasum":"80413afacfa656322100ce1900fed1ebcd8f8f44","modified":1450444394000},{"_id":"themes/next/source/css/_common/_fonts/icon-fifty-shades.styl","shasum":"249f75bafa26b99d272352c0646e7497ea680b39","modified":1450444394000},{"_id":"themes/next/source/css/_common/_fonts/icon-font.styl","shasum":"ec3f86739bede393cafcd3e31052c01115ae20d6","modified":1450444394000},{"_id":"themes/next/source/css/_common/_fonts/icon-linecons.styl","shasum":"9cdbedb3627ac941cfb063b152abe5a75c3c699a","modified":1450444394000},{"_id":"themes/next/source/css/_common/_page/archive.styl","shasum":"dff879f55ca65fa79c07e9098719e53eeea7ac88","modified":1450444394000},{"_id":"themes/next/source/css/_common/_page/categories.styl","shasum":"4f696a2eaeee2f214adcf273eab25c62a398077a","modified":1450444394000},{"_id":"themes/next/source/css/_common/_page/post-detail.styl","shasum":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1450444394000},{"_id":"themes/next/source/css/_common/_section/body.styl","shasum":"ca1a4766cbe25baac757c6b47a4858d221afdc40","modified":1450444394000},{"_id":"themes/next/source/css/_common/_section/footer.styl","shasum":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1450444394000},{"_id":"themes/next/source/css/_common/_section/header.styl","shasum":"e351f1ebc0d3c63e3443bcba3a34677b06c37455","modified":1450444394000},{"_id":"themes/next/source/css/_common/_section/layout.styl","shasum":"03ae7b808dde9065412968aa69916162e790455d","modified":1450444394000},{"_id":"themes/next/source/css/_common/_section/media.styl","shasum":"fa9809d2ecc753cf32f70803c1d0821c405211f4","modified":1450444394000},{"_id":"themes/next/source/css/_common/_section/sidebar.styl","shasum":"edaae01f7232c3fef9bf32ff1bdcf8a04d1aa6cd","modified":1450444394000},{"_id":"themes/next/source/css/_common/_vendor/highlight/highlight.styl","shasum":"6242be4307a3b3dafc14e556f51c8875c41a1ddd","modified":1450444394000},{"_id":"themes/next/source/css/_common/_vendor/highlight/theme.styl","shasum":"ae19721ceee5ba460e131cb2427dae3c1ff39d6f","modified":1450444394000},{"_id":"themes/next/source/css/_custom/custom.styl","shasum":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1450444394000},{"_id":"themes/next/source/css/_mixins/base.styl","shasum":"4e49707c99c8bbcfa0a607dfdaff0fbb7dffd2a3","modified":1450444394000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","shasum":"d50c2a9ae363d26ed2e9bc226a9dc7abeb9ace1b","modified":1450444394000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","shasum":"1631a430655eadb485574d1a9bedd49460988b11","modified":1450444394000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","shasum":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1450444394000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","shasum":"5a8036fc61207ca0fe38c9782ed2f686fbf764be","modified":1450444394000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","shasum":"b7366f28bd7902bfc1dce24f2bd5ae5439fb6e2f","modified":1450444394000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","shasum":"fc7d96b897290dbd93bc8c515a2058fc4c374ea7","modified":1450444394000},{"_id":"themes/next/source/css/_schemes/default/_logo.styl","shasum":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1450444394000},{"_id":"themes/next/source/css/_schemes/default/_menu.styl","shasum":"4bba29cece65ffc5122f4e052063dea4439fe4ae","modified":1450444394000},{"_id":"themes/next/source/css/_schemes/default/_search.styl","shasum":"c524bccdc554349106d1c8be9c3f275d4c0d4281","modified":1450444394000},{"_id":"themes/next/source/css/_schemes/default/index.styl","shasum":"159464cb8a7e01e32db9ec70dec391ec70a72f9c","modified":1450444394000},{"_id":"themes/next/source/css/_variables/Mist.styl","shasum":"9f8791860cc1ca724d2dfe609e8cd6abc44d6926","modified":1450444394000},{"_id":"themes/next/source/css/_variables/base.styl","shasum":"403ec86631ab907f976284bc1a6c53a9b3e23a21","modified":1450444394000},{"_id":"themes/next/source/css/main.styl","shasum":"56dacee56c5eaa4b2676d196452314fb50f758aa","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-default/icomoon.eot","shasum":"90763e97be18be78e65749075225cceeddc6fa8a","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-default/icomoon.svg","shasum":"f92ad8cddc250f0bb5ca466fca95d321987e127e","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-default/icomoon.ttf","shasum":"c093408e6030221cafc1f79d897f1fb5283c1178","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-default/icomoon.woff","shasum":"dbe0368f2a65d87b13234cfea29d9783892fc7a8","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-default/selection.json","shasum":"dc07c29f687315f9458f6b251c214768af865fb2","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.eot","shasum":"11554b9e9d5b9f535ba96cbb27d45d8c8f1689fd","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.svg","shasum":"d5eb756eefda9b454dcb23c2b1cefd4051d18d41","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.ttf","shasum":"b2bbae4b613403cf61ad25037913378da1c07b8f","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.woff","shasum":"2ea1c59c17422798e64ee6f4e9ce1f7aff1a06a5","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-feather/selection.json","shasum":"06ea91e3f98ebe1080087acad4356802bc5b6ebf","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.eot","shasum":"da86ba5df72d1288de9e9633e5f528062dd427d5","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.svg","shasum":"1a4afd739e1f8eb8d430dbdd29e36a9999802e8d","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.eot","shasum":"301fcf00c24750dddf1c529f944ca62c7f1a217d","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.ttf","shasum":"72fe82e1f3db52414eed706952d385af241cb196","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.woff","shasum":"4de6a74f523dee33d95dde61caae5809f9a5d448","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-fifty-shades/selection.json","shasum":"fdd09098d1c3688e2c88cf33fd51e76b383b6d7f","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.svg","shasum":"e316347805eb93425faa678611c5e42a7152da8f","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.ttf","shasum":"f399713d1c9400d4d3373e38991a7e362a754a94","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.woff","shasum":"05f1ec0bd307da5e731a86eb4961589a6042aebb","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.eot","shasum":"e2d7f040428a632f3c50bfa94083b759936effc2","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.svg","shasum":"808eaf7d61f7e67c76976265c885e79c36920f0b","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.ttf","shasum":"078068206684e4f185b0187ad3cee16f54a287d7","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.woff","shasum":"0b07ee6ceda3b1bceb40c1e7379b3aa48dcc15a8","modified":1450444394000},{"_id":"themes/next/source/fonts/icon-linecons/selection.json","shasum":"db4ce25d31449ecc6685b32e145252103967bb5c","modified":1450444394000},{"_id":"themes/next/source/images/bkdefault_avatar.jpg","shasum":"b687bb4bfbe35a32b592c24d652ba80cfdc770fc","modified":1450444394000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1450444394000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1450444394000},{"_id":"themes/next/source/images/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1450444394000},{"_id":"themes/next/source/images/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1450444394000},{"_id":"themes/next/source/images/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1450444394000},{"_id":"themes/next/source/images/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1450444394000},{"_id":"themes/next/source/images/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1450444394000},{"_id":"themes/next/source/images/loading.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1450444394000},{"_id":"themes/next/source/images/placeholder.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1450444394000},{"_id":"themes/next/source/images/quote-l.svg","shasum":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1450444394000},{"_id":"themes/next/source/images/quote-r.svg","shasum":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1450444394000},{"_id":"themes/next/source/images/searchicon.png","shasum":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1450444394000},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","shasum":"ae7bdce88b515aade4eea8bf7407eec458bcd625","modified":1450444394000},{"_id":"themes/next/source/js/fancy-box.js","shasum":"62d38913d8e8a5736ecc48a0b343f67e86a0ae32","modified":1450444394000},{"_id":"themes/next/source/js/helpers.js","shasum":"c15216ef897334362789ba37464298948b2eef95","modified":1450444394000},{"_id":"themes/next/source/js/hook-duoshuo.js","shasum":"de3c14f49ac5f20b2065377dd1872749d067ebf9","modified":1450444394000},{"_id":"themes/next/source/js/lazyload.js","shasum":"b92e9acdc7afc15468314c03f4a643b0c93944cf","modified":1450444394000},{"_id":"themes/next/source/js/motion_fallback.js","shasum":"a767d522c65a8b2fbad49135c9332135c6785c3e","modified":1450444394000},{"_id":"themes/next/source/js/motion_global.js","shasum":"2322d677b3dbed5506f3b79ec3d1ebe7e019f115","modified":1450444394000},{"_id":"themes/next/source/js/nav-toggle.js","shasum":"78b59f1beb12adea0d7f9bcf4377cb699963f220","modified":1450444394000},{"_id":"themes/next/source/js/ua-parser.min.js","shasum":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1450444394000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1450444394000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1450444394000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1450444394000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1450444394000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1450444394000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1450444394000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1450444394000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1450444394000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","shasum":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1450444394000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","shasum":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1450444394000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1450444394000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","shasum":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1450444394000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","shasum":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1450444394000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","shasum":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1450444394000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","shasum":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1450444394000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","shasum":"53360764b429c212f424399384417ccc233bb3be","modified":1450444394000},{"_id":"themes/next/source/vendors/fastclick/README.md","shasum":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1450444394000},{"_id":"themes/next/source/vendors/fastclick/bower.json","shasum":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1450444394000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","shasum":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1450444394000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","shasum":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1450444394000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","shasum":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1450444394000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","shasum":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1450444394000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","shasum":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1450444394000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","shasum":"0189d278706509412bac4745f96c83984e1d59f4","modified":1450444394000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","shasum":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1450444394000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","shasum":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1450444394000},{"_id":"themes/next/source/vendors/velocity/bower.json","shasum":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1450444394000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","shasum":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1450444394000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","shasum":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1450444394000},{"_id":"themes/next/test/helpers.js","shasum":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1450444394000},{"_id":"themes/next/test/intern.js","shasum":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1450444394000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","shasum":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1450444394000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","shasum":"0112e96f327d413938d37c1693806f468ffdbace","modified":1450444394000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","shasum":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1450444394000},{"_id":"themes/next/source/vendors/jquery/index.js","shasum":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1450444394000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","shasum":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1450444394000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","shasum":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1450444394000},{"_id":"themes/next/source/vendors/velocity/velocity.js","shasum":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1450444394000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","shasum":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1450444394000},{"_id":"public/tags/index.html","modified":1450449371754,"shasum":"630d6b3694f815401266063f3ef143a1245ed644"},{"_id":"public/categories/index.html","modified":1450449371812,"shasum":"d5e1c9cc2191490048c8813a525f2f77c6742e98"},{"_id":"public/bio/index.html","modified":1450449371861,"shasum":"859fde33d54c10fef7f7b113d3479048cc1eb7bf"},{"_id":"public/about/index.html","modified":1450449371911,"shasum":"d7325c501d7fa607e8a93fa14379c8d0e0d79507"},{"_id":"public/vendors/fastclick/README.html","modified":1450449371941,"shasum":"627cdd7a56fc7d9c169b9f6afedd74f77e6d3d06"},{"_id":"public/css/main.css","modified":1450449372371,"shasum":"bbf024202cb08934898aa12acb436bf62e20f665"},{"_id":"public/2015/10/22/runloop初窥/index.html","modified":1450449372547,"shasum":"f2d0b15121571da9c382d3271c1f77092e250b35"},{"_id":"public/2015/10/22/objective-c-runtime是什么/index.html","modified":1450449372600,"shasum":"9f53ab33ab1a1d529d6aa771158e33014bfbf800"},{"_id":"public/2015/05/19/Python利用深度优先搜索解数独程序的实现/index.html","modified":1450449372671,"shasum":"ef63b309d01ba22a1cf1cb0711c5ce44a90947af"},{"_id":"public/2015/02/02/UIColor-colorWithRed-green-blue-alpha-的正确用法/index.html","modified":1450449372727,"shasum":"7f5e05fa80108c39f2042ad356952dbd8ec70706"},{"_id":"public/2014/12/26/PHP图片处理-透明水印的处理和添加/index.html","modified":1450449372785,"shasum":"34d84d614c5d49444d0150e7218bfd12d55062fa"},{"_id":"public/2014/12/12/Ubuntu下重置MySQL的root密码/index.html","modified":1450449372843,"shasum":"943f29f439f8c3aabd2f5169e6b517a4255a886e"},{"_id":"public/2014/12/10/iOS-静态库封装和使用方法/index.html","modified":1450449372901,"shasum":"69c82c7a19d4c56909dfd25e103ef4e80d628959"},{"_id":"public/index.html","modified":1450449372976,"shasum":"780cbe9dad56eeaca95ce6c9edeb067c56d73cfd"},{"_id":"public/categories/iOS菜鸟心得/index.html","modified":1450449373008,"shasum":"bf103716ca9e6f2eb4a52b204a93a4647bf01fad"},{"_id":"public/categories/Linux服务器笔记/index.html","modified":1450449373043,"shasum":"b12886ed94bf0867343ce3eb8c417ba5e1923cec"},{"_id":"public/categories/Python学习/index.html","modified":1450449373092,"shasum":"da7cda013efa9e9a27574cb431a2e416570f5e05"},{"_id":"public/categories/PHP大神养成/index.html","modified":1450449373127,"shasum":"276f8ea89a1046da79b0c1f0764e03087b1f2f89"},{"_id":"public/archives/index.html","modified":1450449373189,"shasum":"895fce2933564b5a14b2e98e830cac6028b8a478"},{"_id":"public/archives/2014/index.html","modified":1450449373234,"shasum":"19191c7f43c5caf78f2a5f684da8f8c740415929"},{"_id":"public/archives/2014/12/index.html","modified":1450449373296,"shasum":"cf16fe8bd8204ea2a742dcfabf37ed7b752a6705"},{"_id":"public/archives/2015/index.html","modified":1450449373360,"shasum":"60e1ec164d5dcc39a1bf48932b47ae61784269ad"},{"_id":"public/archives/2015/02/index.html","modified":1450449373415,"shasum":"67ce76e5977d1b8ed2e1af371011520f1c641d94"},{"_id":"public/archives/2015/05/index.html","modified":1450449373479,"shasum":"5521415adf48143967a054698198ccbefbe17169"},{"_id":"public/archives/2015/10/index.html","modified":1450449373527,"shasum":"1451e6b8e663e6fa555507a29b4937f02e0a8890"},{"_id":"public/tags/iOS/index.html","modified":1450449373576,"shasum":"8a273bce99053fdc1c7fe71d834d30501031f6c6"},{"_id":"public/tags/runloop/index.html","modified":1450449373640,"shasum":"92fd52b905c09919fa6a7f2f54a6226802e12873"},{"_id":"public/tags/NSThread/index.html","modified":1450449373684,"shasum":"275a65e80dfe7fa3b037c4e23f759b584226bc6a"},{"_id":"public/tags/runtime/index.html","modified":1450449373725,"shasum":"d7ad2116f17eef831fe951283dc281cc62a570f3"},{"_id":"public/tags/Objective-C/index.html","modified":1450449373781,"shasum":"43374c9dd240f6a12576c23c09b3e85977db8929"},{"_id":"public/tags/objc-msgSend/index.html","modified":1450449373843,"shasum":"fcaf1b8d958259d8bcf2e66c235b20c9f8675395"},{"_id":"public/tags/iOS静态库/index.html","modified":1450449373879,"shasum":"ee6a6635601f991ad50ca128a93a20ee53a84ce5"},{"_id":"public/tags/Ubuntu/index.html","modified":1450449373920,"shasum":"c5c16fa55f8de85c0aafe540e83950d7ffb0f9c7"},{"_id":"public/tags/MySQL/index.html","modified":1450449373976,"shasum":"5038d55ea56f96dd4a8c1db70c0cbd62d8ec932b"},{"_id":"public/tags/UIColor/index.html","modified":1450449374013,"shasum":"a3dba81f76af377ee898730cbcd74ab7c91a4b10"},{"_id":"public/tags/python/index.html","modified":1450449374056,"shasum":"536dfaa9eb6f02e2d64b0532a7df3f050055a7ea"},{"_id":"public/tags/python数独，-深度优先搜索/index.html","modified":1450449374101,"shasum":"5c19240b6ba1e9908f250c0486b00a326494509d"},{"_id":"public/tags/PHP图片处理，水印/index.html","modified":1450449374134,"shasum":"8219090559e492644bf13c1aebf88dac7e2c39b5"}],"Category":[{"name":"iOS菜鸟心得","_id":"ciibs3s9l0005evs67k092hmo"},{"name":"Linux服务器笔记","_id":"ciibs3sa0000qevs698w63ux2"},{"name":"Python学习","_id":"ciibs3sa60011evs6f192nr1f"},{"name":"PHP大神养成","_id":"ciibs3saa0018evs6uq7zw1jm"}],"Data":[],"Page":[{"title":"TagCloud","date":"2015-10-22T08:51:37.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"title: TagCloud\ndate: 2015-10-22 16:51:37\ntype: \"tags\"\ncomments: false\n---\n","updated":"2015-12-18T13:13:14.000Z","path":"tags/index.html","layout":"page","_id":"ciibs3s7t0000evs684czkyye"},{"title":"categories","date":"2015-10-22T08:48:30.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"title: categories\ndate: 2015-10-22 16:48:30\ntype: \"categories\"\ncomments: false\n---\n","updated":"2015-12-18T13:13:14.000Z","path":"categories/index.html","layout":"page","_id":"ciibs3s8h0001evs6w0ffjk0p"},{"title":"自传","date":"2015-10-22T09:04:18.000Z","type":"bio","comments":1,"_content":"\n\n\n大三上学期的我 2013-11-24\n我明白也许这个时候就对大学生活做个总结之类的有点不自量力，但鉴于我也是个心怀梦想希望走的更远的小屌丝，有时候坐在图书馆周日午后的阳光里看着满阅览室的汉子和零星的女汉子，也不免心生悲凉和感慨希望写下点什么。所以，我还是先从大学之前说起吧。如果，正在看的你是一个高富帅，也许我们的经历无法产生共鸣，若是觉得无聊，看官们随意。\n\n大学之前\n所有人在刚进入大学的时候，就知识来说，也许大多数人是站在同一起跑线上的，特别是来到我们软院的，我想也有那么一部分人都是一起苦逼的被调剂来的。但是，其实每个人在人生的道路上，不是说上了大学就重新开始人生了，而是继续前行，所以我们每个人又是在不同的位置和方向进入了大学。新认识的小伙伴们大部分时候侃的话题难免是自己的高中生活，有的心有余悸，有的心有不甘，有的好生怀念，这就是不同所在。我隔壁宿舍的小伙伴，来自一个黑暗不见五指的学习环境，高中不允许男女生同行，食堂男女生分区进食还有老师监视，每天六点开始早自习晚上十一点结束晚自习，没有娱乐活动，对于他来说离开那种环境我都能替他感到深深的解脱感；还有一个来自一所大名鼎鼎的某某监狱的小伙伴，高中三年被压抑和束缚，也许他们当中有些还会怀念，有些心生恐惧，但相比于周遭的所有同学，我想我算是比较幸运的，来自南方的一所比较开放的高中。\n可以某种程度上来说，除了高考前每周一次的练习和自己做的卷子，高一到高三我的老师没有强迫我们交任何作业，这就导致了我们集体涣散，一群曾经的名列前茅开始在各种活动中崭露头角，然后在各种考试中被虐的满地找牙。但好在那时候的老师是宽容的，总是给我们很多鼓励和支持，即使我挂科也会毅然决然的给我写上一个大大的90，我想，那段日子对我日后真的影响特别深远。后来，在各种早恋和课外活动中，我们混到了高二下学期，那时候我们班里发生了一件大事，以至于影响了我一生。某一天晚上晚自习的时候当我还和小伙伴们聊得正嗨的时候忽然有老师来教室里，告诉我们班主任出事了。我们根本没想到事情会那么难以接受和不可想象，给了我最多鼓励的班主任和她丈夫在散步的时候，一个据称是神经病的人本着情侣都去死的心态拿着水果刀就刺向了班主任的丈夫。他很优秀，她也很优秀，但就这么离谱的事情，我的班主任无法接受这一事实，最后悲痛的离开了我们去了外地慢慢调养。而我也忽然意识到，再不努力就没办法让她看到她所肯定的那个我了。那时候，是高二的寒假前。那时候我还是倒数。但我总是把相信自己放在第一位，于是就有了后来的高考，来到了北航。但这些都不是重点，这些都只是铺垫。\n\n大一入学\n我想很多软院的男生在刚入学的时候，心中总会牵挂着那样一个妹子，或许是女朋友，或许只是心上人，但我相信在高考结束之后那段迷茫、无聊、空虚的日子里，我们总会那样疯狂地失去理智过。\n高考结束后我谈了一次轰轰烈烈的恋爱，说是轰轰烈烈是因为在我父母都不知情的情况下我所有的好朋友都已经极力反对了，所以我冒着失去几乎所有朋友的风险失去理智了一回。过程相当庸俗，我想恋爱过的人大都明白这些过程，但我想说的是，当我们说着不分离的誓言各自去了不同的城市上了大学之后，我忽然发现周围有那么多相同处境的小伙伴。然后，当我开了个好头，在军训刚结束她就忽然人间蒸发了之后一个月的时间里，我看到大家接连赶在了当年光棍节前回到了一条光棍的状态，有那么一两个幸存的情比金坚的，那也是极少数幸运的，都是后话了。\n于是我们都迷茫了。在刚进入大学还不知道该干什么刚打算心里装着远方的妹子天天上自习却忽然就被甩了的时候，我们都迷茫了。我看到说说和微博过几天就有一个失意的小伙伴更新一条“今晚又睡不着了，想你”“把你的照片装在钥匙扣上，自习的累了拿出来看一眼就很满足”“好累”云云，当然不嫌羞耻的说我也是其中一员；我还记得那时候失意的人经常相约去沙河对面的串串摊喝酒吃串串侃点别的诉点苦；也记得我们每天就做梦梦到某个人然后不愿意醒来，开始了我们翘课的生活。这些都没什么，走得远了回头一看，这些都不算什么，你会发现很多人和你一样迷茫着，这是正常的，也是圆满的。\n之后半期考过后，就开始了一系列的校园活动，那时候才算是大学生活真正开始的时候，从非诚勿扰，到女生节许愿墙，人缘好的性格外向的开始交友，性格内向的就开始找小伙伴，大家虽然还在迷茫，但也都努力在适应。那段时间的我，却在经历一段挣扎，这个挣扎来源于两件事，创新杯，还有大学计算机基础。\n也许是我习惯了高中进去就各种活动的节奏，到了大学虽然我不愿意再去涉及那么多的人事关系，但我却更愿意做点专业的事情也好让我明白咱们这个专业是做什么的。我还记得第一次听到创新杯可以报名的时候，我还赖在床上和舍友开黑打游戏，然后我忽然激发出一股斗志，那种想要学习报国的斗志，所以头脑一热就跟舍友说咱们也去参加吧。虽然后来就一审混过了连二审都不敢去，但我想，如果此刻正在读这些文字的你，也有着一腔斗志想要挑战一下这个创新杯的话，我还是想和你说加油，走到哪是哪，重要的是不要放弃，这一次失败了下一次还能继续。开始的时候就我一个人装模做样的学了点东西抄了点代码其实那时候自己什么也看不懂，舍友们那时候还小，更是什么也不知道，以至于到了二审的时候我们犹豫了半天还是觉得不要去丢这个脸好了，不如用这个时间开一把小黑快乐一下。这件事就在一局游戏里了结了，但我觉得这个失败的经历对于我日后坚持不懈的努力也是必不可少的。\n再有就是大学计算机基础了。我想应该有些经历过的的人会明白，这个是文科的课程。没错，因为帮一个妹子做计算机作业，我按很多人设想的模式认识了一个文科的妹子。并且成功的从辅导计算机，到食堂吃饭，到出去吃饭，逛街，到一起度过跨年夜，最后在寒假的时候，在接近成功的时候，她因为我高考结束那段时间的经历而打了退堂鼓。那段时间我也着实没那那些想法。但是回想起来我想也许很多人走出迷茫的方式就是遇见那么一个可以带你走出来的人，但是又愁于无法遇见，我幸运到可以遇见，虽然最后走散了，因为那么现实的原因，但我终究是清醒过来，此刻我正站在大学的校园里，脚下是真实的土地。\n后来我和大多数颓废的大学生一样堕落了，下学期的时候，我偶然接触了一个坑爹的网游，具体是什么我就不说了。那一个学期我花费了整个学期在这个游戏上，但最终想来，其实对于不同的人来说做相同的事收获也是不同的，就像这一个学期的经历，我虽然也是这么浪费了时间，但我却有机会认识了来自天南地北的各路网友。从初中生，高中生，到大学生，为人父，为人母，我和他们在现实中都建立了相当稳固和良好的联系，他们也在我接下来的历程中给了不少建议。如此想来，我想，此刻正在读这些文字的你，若有心想要趁着青春把过去未完成的疯狂补偿一遍，一定不要只是失去什么，至少努力去收获这么多你能够触手可得的为人处世的经验。\n那次期末考，我和所有大学的迷茫者一样，终于挂科了。我们总说，没有挂科，没有翘课，没有女朋友的大学是不圆满的，也许我们在这样一个地方相会，最后那个条件我们还是暂时束之高阁吧，这么想着自己就感到安慰了，大学三分之二圆满了嘛。我记得，那个暑假，在回家的飞机起飞的那一刻，我忽然觉得自己经历的这一年大学是如此的虚幻，毫无建树，没有自己期望中的精彩，虽然将自己的青春一股脑儿发泄完了，但此刻却觉得沉甸甸的疲惫。那一刻，我想，是该改变的时候了。\n青春就这么过去了。后来想起的时候，有遗憾，也有庆幸。遗憾的是自己最终还是把自己第一年的成绩搞得一团糟，庆幸的是自己疯过，累过，青春过，没有后悔过。\n回到家，我先是忍着心疼删了游戏里的角色，删了游戏，甚至把电脑和手机里所有能玩的游戏和娱乐的软件都一并删除了。从那时候开始也算是一个分水岭，在那次之后我就慢慢变得很少玩游戏了。我想每个还算靠谱的大学生，都会有这样一个分水岭。我们当中有些人在大一刚入学时就能下定决心，而有些人直到毕业还是一样像无头苍蝇一样不知道未来往哪走，前者很快就成了学霸学神，而后者到最后还是学渣。\n大一的暑假，也许我和很多人度过的都不一样。我回到了高三的状态，在图书馆朝至夕归的过了两个月，不仅仅是复习我阵亡的大学物理，还把大一学过的课程几乎全都自学了一遍。那时候我父母甚至是我的很多朋友都不理解为什么我放假还要这样读书，但我强忍内心无法多陪伴父母一点时间的痛苦，用一个夏天的时间学会了坚持。那个暑假据说是北航史上最长的暑假，一个夏天让我学会了坚持，虽然最后的结局并不好，但转机也很快来到了。\n\n分水岭之后\n故事仍然从上一部分继续，但我的生命却在悄悄进入下一个时代。那个暑假的结束十分的戏剧，我临时被通知开学前补考，于是匆忙的改签了机票，幸运的是在第二天早上八点的航班有最后几个位子。我甚至连行李都来不及整，家人们朋友们也没有告知就被迫狼狈的离开了家。一个夏天的终结。\n第二天早上赶到机场的时候，却在机场里遇见了一个很久很久都没有机会见到的外地朋友，顿时郁闷的心情一扫而光。后来和朋友说起的时候，都觉得那真的是个上帝的馈赠，也许很多时候在你看来特别不如意特别不顺心的时刻，其实都是上帝在为你准备着馈赠而让你经历的。从那开始，我经历了一段特别黑暗的日子，当然，我已经对黑暗的日子习惯了。记得那时候，我曾经把自己的签名改成“如果生命是个悲剧，就让观众哭个够，如果生命是个喜剧，就让世界开心个够”。\n物理补考之后，我和很多人一样，进入了痛苦的转型期。时间久远，有些细节我已记不起来了，但我知道，那段时间我是咬着牙度过下来的。以至于当我看到圣经里上帝的教诲时，我忽然发现一切都是馈赠，生活总是看起来很不如意，当你换了一种心态去面对，生活顿时就变得不一样了。\n我们总是抱怨着生活的不如意，生活的累，但再怎么样我们都不能放弃，因为我们会明白，表面上看起来的不如意，其实只是对我们的考验，和给予我们的提升的机会。如果不曾努力，不如意又怎么会变成机会，如果不曾勇敢，不如意又怎么会变成挑战。如果，身处大二这个时期的你也在这么痛苦的放弃了你曾经堕落的生活，准备从学渣晋升到一个充满了激情和热爱的IT男，我想，坚持和信念是你要学会的。基督山伯爵说，人生的意义就在于四个字，等待和希望，这是我一直以来的座右铭。即使有太多的倒霉的事或者不好的事发生，我也不会放弃希望，但这也恰恰就是我最傻的地方。总是抱着必定落空的希望而坚持，最后碰得一鼻子灰，不过我并不觉得这种傻有什么可羞耻的地方，相反我仍然在坚持，我也希望有着同样信念的人也一定要坚持。\n于是我没有在意第一年的失败，又参加了第二年的创新杯。也许只是时机不对，所以直到第二年我才慢慢明白第一年犯下的错误和幼稚。创新杯进行了很久，直到下学期冯如杯的闯入让我希望去接受更大的挑战。虽然最后的结果都是失败，但某种意义上来说也并不能算是失败，对我们这样的学渣来说，能接受挑战也是一种成功，重要的是接受失败给予我们的经验并继续去尝试。创新杯的失败是因为接受了错误的概念引导，也和那时候没有做好接受任何挑战的准备有关，直到最后失败了之后我才忽然发现其实自己一直没有去面对的很多挑战才正是自己最需要的。如果，在遇到了新的挑战的时候我们只是一味的逃避想要让事情简单，有些挑战我们永远也无法应付的了，有些道理和知识我们永远也学不会。就像我们学软件的，有些东西我们从未学到过，如果不勇敢的去挑战，我们到最后只能拿着书上教我们的那些空洞的知识蓦然发现自己离成功的实践越来越远。\n两次失败后，我已经积累了足够的经验，加上和团队的磨合的也越来越好，我们准备向更大的目标进发，做一个更庞大的系统开发。也许直到现在都还是有那么多的质疑，觉得我太过冒险，然而没有失败，没有想要做得更好，又何来的突破和成功。我想，如果你们愿意去寻找自己热爱的事物，就应该大胆的去尝试，去改变，去经历，才能不断地更新自己的认识。携两三靠谱好基友，凭一腔热血，青春年少，有什么做不到的。年轻就该气盛，才不负年华。\n也许每个人的大学生活从一开始就像我现在这样，也不会有那么多迷茫，那么多弯路了，然而人生就是这样，在你该走弯路的时候，一定不要因为太多的顾虑而错过了弯路上的风景。所有人的生命，在一开始都是以相同的一条直线从起点奔向终点，然而正是由于生命的多彩，不同的人走向了不同的方向，经历了不同的曲折，或是与其他人的生命相交，或是重合，或是平行着远远看着，到最后所有人再回到同一个终点。如果我们选择一路都是直线的人生，我们只是选择了最短，最简单的人生，在相同的时间里，我们所经历的距离却远比充满了曲折的人生来的短。那么，既然我们有着相同的起点和终点，上帝所给与我们的生命长度是如此的有限，我们又为什么不多经历一点曲折和弯路，多看点风景呢？\n老者和长辈总会淳淳教诲我们，少走弯路年轻人。然而那只是因为他们不知道别处的风景，不知道弯路上的风景，弯路上的经历，不知道我们所多走的距离和别人的生命相比起来是多么的宝贵。我想，此刻正在读这些文字的你们，应该有很多人也在这么迷茫着吧。我的经历也许并不是那么的石破天惊，我的价值观也许不是那么的正常，也许我在很多人眼里是没吃药才会写下这些文字，但我觉得，是不同的经历造就了不同的人格，可你若不去经历，你将永远不知道对岸的风景。我相信，不管是变成什么样的技术宅，只要学会了坚持，就可以拥有全世界。\n\n","source":"bio/index.md","raw":"title: 自传\ndate: 2015-10-22 17:04:18\ntype: \"bio\"\ncomments: true\n---\n\n\n\n大三上学期的我 2013-11-24\n我明白也许这个时候就对大学生活做个总结之类的有点不自量力，但鉴于我也是个心怀梦想希望走的更远的小屌丝，有时候坐在图书馆周日午后的阳光里看着满阅览室的汉子和零星的女汉子，也不免心生悲凉和感慨希望写下点什么。所以，我还是先从大学之前说起吧。如果，正在看的你是一个高富帅，也许我们的经历无法产生共鸣，若是觉得无聊，看官们随意。\n\n大学之前\n所有人在刚进入大学的时候，就知识来说，也许大多数人是站在同一起跑线上的，特别是来到我们软院的，我想也有那么一部分人都是一起苦逼的被调剂来的。但是，其实每个人在人生的道路上，不是说上了大学就重新开始人生了，而是继续前行，所以我们每个人又是在不同的位置和方向进入了大学。新认识的小伙伴们大部分时候侃的话题难免是自己的高中生活，有的心有余悸，有的心有不甘，有的好生怀念，这就是不同所在。我隔壁宿舍的小伙伴，来自一个黑暗不见五指的学习环境，高中不允许男女生同行，食堂男女生分区进食还有老师监视，每天六点开始早自习晚上十一点结束晚自习，没有娱乐活动，对于他来说离开那种环境我都能替他感到深深的解脱感；还有一个来自一所大名鼎鼎的某某监狱的小伙伴，高中三年被压抑和束缚，也许他们当中有些还会怀念，有些心生恐惧，但相比于周遭的所有同学，我想我算是比较幸运的，来自南方的一所比较开放的高中。\n可以某种程度上来说，除了高考前每周一次的练习和自己做的卷子，高一到高三我的老师没有强迫我们交任何作业，这就导致了我们集体涣散，一群曾经的名列前茅开始在各种活动中崭露头角，然后在各种考试中被虐的满地找牙。但好在那时候的老师是宽容的，总是给我们很多鼓励和支持，即使我挂科也会毅然决然的给我写上一个大大的90，我想，那段日子对我日后真的影响特别深远。后来，在各种早恋和课外活动中，我们混到了高二下学期，那时候我们班里发生了一件大事，以至于影响了我一生。某一天晚上晚自习的时候当我还和小伙伴们聊得正嗨的时候忽然有老师来教室里，告诉我们班主任出事了。我们根本没想到事情会那么难以接受和不可想象，给了我最多鼓励的班主任和她丈夫在散步的时候，一个据称是神经病的人本着情侣都去死的心态拿着水果刀就刺向了班主任的丈夫。他很优秀，她也很优秀，但就这么离谱的事情，我的班主任无法接受这一事实，最后悲痛的离开了我们去了外地慢慢调养。而我也忽然意识到，再不努力就没办法让她看到她所肯定的那个我了。那时候，是高二的寒假前。那时候我还是倒数。但我总是把相信自己放在第一位，于是就有了后来的高考，来到了北航。但这些都不是重点，这些都只是铺垫。\n\n大一入学\n我想很多软院的男生在刚入学的时候，心中总会牵挂着那样一个妹子，或许是女朋友，或许只是心上人，但我相信在高考结束之后那段迷茫、无聊、空虚的日子里，我们总会那样疯狂地失去理智过。\n高考结束后我谈了一次轰轰烈烈的恋爱，说是轰轰烈烈是因为在我父母都不知情的情况下我所有的好朋友都已经极力反对了，所以我冒着失去几乎所有朋友的风险失去理智了一回。过程相当庸俗，我想恋爱过的人大都明白这些过程，但我想说的是，当我们说着不分离的誓言各自去了不同的城市上了大学之后，我忽然发现周围有那么多相同处境的小伙伴。然后，当我开了个好头，在军训刚结束她就忽然人间蒸发了之后一个月的时间里，我看到大家接连赶在了当年光棍节前回到了一条光棍的状态，有那么一两个幸存的情比金坚的，那也是极少数幸运的，都是后话了。\n于是我们都迷茫了。在刚进入大学还不知道该干什么刚打算心里装着远方的妹子天天上自习却忽然就被甩了的时候，我们都迷茫了。我看到说说和微博过几天就有一个失意的小伙伴更新一条“今晚又睡不着了，想你”“把你的照片装在钥匙扣上，自习的累了拿出来看一眼就很满足”“好累”云云，当然不嫌羞耻的说我也是其中一员；我还记得那时候失意的人经常相约去沙河对面的串串摊喝酒吃串串侃点别的诉点苦；也记得我们每天就做梦梦到某个人然后不愿意醒来，开始了我们翘课的生活。这些都没什么，走得远了回头一看，这些都不算什么，你会发现很多人和你一样迷茫着，这是正常的，也是圆满的。\n之后半期考过后，就开始了一系列的校园活动，那时候才算是大学生活真正开始的时候，从非诚勿扰，到女生节许愿墙，人缘好的性格外向的开始交友，性格内向的就开始找小伙伴，大家虽然还在迷茫，但也都努力在适应。那段时间的我，却在经历一段挣扎，这个挣扎来源于两件事，创新杯，还有大学计算机基础。\n也许是我习惯了高中进去就各种活动的节奏，到了大学虽然我不愿意再去涉及那么多的人事关系，但我却更愿意做点专业的事情也好让我明白咱们这个专业是做什么的。我还记得第一次听到创新杯可以报名的时候，我还赖在床上和舍友开黑打游戏，然后我忽然激发出一股斗志，那种想要学习报国的斗志，所以头脑一热就跟舍友说咱们也去参加吧。虽然后来就一审混过了连二审都不敢去，但我想，如果此刻正在读这些文字的你，也有着一腔斗志想要挑战一下这个创新杯的话，我还是想和你说加油，走到哪是哪，重要的是不要放弃，这一次失败了下一次还能继续。开始的时候就我一个人装模做样的学了点东西抄了点代码其实那时候自己什么也看不懂，舍友们那时候还小，更是什么也不知道，以至于到了二审的时候我们犹豫了半天还是觉得不要去丢这个脸好了，不如用这个时间开一把小黑快乐一下。这件事就在一局游戏里了结了，但我觉得这个失败的经历对于我日后坚持不懈的努力也是必不可少的。\n再有就是大学计算机基础了。我想应该有些经历过的的人会明白，这个是文科的课程。没错，因为帮一个妹子做计算机作业，我按很多人设想的模式认识了一个文科的妹子。并且成功的从辅导计算机，到食堂吃饭，到出去吃饭，逛街，到一起度过跨年夜，最后在寒假的时候，在接近成功的时候，她因为我高考结束那段时间的经历而打了退堂鼓。那段时间我也着实没那那些想法。但是回想起来我想也许很多人走出迷茫的方式就是遇见那么一个可以带你走出来的人，但是又愁于无法遇见，我幸运到可以遇见，虽然最后走散了，因为那么现实的原因，但我终究是清醒过来，此刻我正站在大学的校园里，脚下是真实的土地。\n后来我和大多数颓废的大学生一样堕落了，下学期的时候，我偶然接触了一个坑爹的网游，具体是什么我就不说了。那一个学期我花费了整个学期在这个游戏上，但最终想来，其实对于不同的人来说做相同的事收获也是不同的，就像这一个学期的经历，我虽然也是这么浪费了时间，但我却有机会认识了来自天南地北的各路网友。从初中生，高中生，到大学生，为人父，为人母，我和他们在现实中都建立了相当稳固和良好的联系，他们也在我接下来的历程中给了不少建议。如此想来，我想，此刻正在读这些文字的你，若有心想要趁着青春把过去未完成的疯狂补偿一遍，一定不要只是失去什么，至少努力去收获这么多你能够触手可得的为人处世的经验。\n那次期末考，我和所有大学的迷茫者一样，终于挂科了。我们总说，没有挂科，没有翘课，没有女朋友的大学是不圆满的，也许我们在这样一个地方相会，最后那个条件我们还是暂时束之高阁吧，这么想着自己就感到安慰了，大学三分之二圆满了嘛。我记得，那个暑假，在回家的飞机起飞的那一刻，我忽然觉得自己经历的这一年大学是如此的虚幻，毫无建树，没有自己期望中的精彩，虽然将自己的青春一股脑儿发泄完了，但此刻却觉得沉甸甸的疲惫。那一刻，我想，是该改变的时候了。\n青春就这么过去了。后来想起的时候，有遗憾，也有庆幸。遗憾的是自己最终还是把自己第一年的成绩搞得一团糟，庆幸的是自己疯过，累过，青春过，没有后悔过。\n回到家，我先是忍着心疼删了游戏里的角色，删了游戏，甚至把电脑和手机里所有能玩的游戏和娱乐的软件都一并删除了。从那时候开始也算是一个分水岭，在那次之后我就慢慢变得很少玩游戏了。我想每个还算靠谱的大学生，都会有这样一个分水岭。我们当中有些人在大一刚入学时就能下定决心，而有些人直到毕业还是一样像无头苍蝇一样不知道未来往哪走，前者很快就成了学霸学神，而后者到最后还是学渣。\n大一的暑假，也许我和很多人度过的都不一样。我回到了高三的状态，在图书馆朝至夕归的过了两个月，不仅仅是复习我阵亡的大学物理，还把大一学过的课程几乎全都自学了一遍。那时候我父母甚至是我的很多朋友都不理解为什么我放假还要这样读书，但我强忍内心无法多陪伴父母一点时间的痛苦，用一个夏天的时间学会了坚持。那个暑假据说是北航史上最长的暑假，一个夏天让我学会了坚持，虽然最后的结局并不好，但转机也很快来到了。\n\n分水岭之后\n故事仍然从上一部分继续，但我的生命却在悄悄进入下一个时代。那个暑假的结束十分的戏剧，我临时被通知开学前补考，于是匆忙的改签了机票，幸运的是在第二天早上八点的航班有最后几个位子。我甚至连行李都来不及整，家人们朋友们也没有告知就被迫狼狈的离开了家。一个夏天的终结。\n第二天早上赶到机场的时候，却在机场里遇见了一个很久很久都没有机会见到的外地朋友，顿时郁闷的心情一扫而光。后来和朋友说起的时候，都觉得那真的是个上帝的馈赠，也许很多时候在你看来特别不如意特别不顺心的时刻，其实都是上帝在为你准备着馈赠而让你经历的。从那开始，我经历了一段特别黑暗的日子，当然，我已经对黑暗的日子习惯了。记得那时候，我曾经把自己的签名改成“如果生命是个悲剧，就让观众哭个够，如果生命是个喜剧，就让世界开心个够”。\n物理补考之后，我和很多人一样，进入了痛苦的转型期。时间久远，有些细节我已记不起来了，但我知道，那段时间我是咬着牙度过下来的。以至于当我看到圣经里上帝的教诲时，我忽然发现一切都是馈赠，生活总是看起来很不如意，当你换了一种心态去面对，生活顿时就变得不一样了。\n我们总是抱怨着生活的不如意，生活的累，但再怎么样我们都不能放弃，因为我们会明白，表面上看起来的不如意，其实只是对我们的考验，和给予我们的提升的机会。如果不曾努力，不如意又怎么会变成机会，如果不曾勇敢，不如意又怎么会变成挑战。如果，身处大二这个时期的你也在这么痛苦的放弃了你曾经堕落的生活，准备从学渣晋升到一个充满了激情和热爱的IT男，我想，坚持和信念是你要学会的。基督山伯爵说，人生的意义就在于四个字，等待和希望，这是我一直以来的座右铭。即使有太多的倒霉的事或者不好的事发生，我也不会放弃希望，但这也恰恰就是我最傻的地方。总是抱着必定落空的希望而坚持，最后碰得一鼻子灰，不过我并不觉得这种傻有什么可羞耻的地方，相反我仍然在坚持，我也希望有着同样信念的人也一定要坚持。\n于是我没有在意第一年的失败，又参加了第二年的创新杯。也许只是时机不对，所以直到第二年我才慢慢明白第一年犯下的错误和幼稚。创新杯进行了很久，直到下学期冯如杯的闯入让我希望去接受更大的挑战。虽然最后的结果都是失败，但某种意义上来说也并不能算是失败，对我们这样的学渣来说，能接受挑战也是一种成功，重要的是接受失败给予我们的经验并继续去尝试。创新杯的失败是因为接受了错误的概念引导，也和那时候没有做好接受任何挑战的准备有关，直到最后失败了之后我才忽然发现其实自己一直没有去面对的很多挑战才正是自己最需要的。如果，在遇到了新的挑战的时候我们只是一味的逃避想要让事情简单，有些挑战我们永远也无法应付的了，有些道理和知识我们永远也学不会。就像我们学软件的，有些东西我们从未学到过，如果不勇敢的去挑战，我们到最后只能拿着书上教我们的那些空洞的知识蓦然发现自己离成功的实践越来越远。\n两次失败后，我已经积累了足够的经验，加上和团队的磨合的也越来越好，我们准备向更大的目标进发，做一个更庞大的系统开发。也许直到现在都还是有那么多的质疑，觉得我太过冒险，然而没有失败，没有想要做得更好，又何来的突破和成功。我想，如果你们愿意去寻找自己热爱的事物，就应该大胆的去尝试，去改变，去经历，才能不断地更新自己的认识。携两三靠谱好基友，凭一腔热血，青春年少，有什么做不到的。年轻就该气盛，才不负年华。\n也许每个人的大学生活从一开始就像我现在这样，也不会有那么多迷茫，那么多弯路了，然而人生就是这样，在你该走弯路的时候，一定不要因为太多的顾虑而错过了弯路上的风景。所有人的生命，在一开始都是以相同的一条直线从起点奔向终点，然而正是由于生命的多彩，不同的人走向了不同的方向，经历了不同的曲折，或是与其他人的生命相交，或是重合，或是平行着远远看着，到最后所有人再回到同一个终点。如果我们选择一路都是直线的人生，我们只是选择了最短，最简单的人生，在相同的时间里，我们所经历的距离却远比充满了曲折的人生来的短。那么，既然我们有着相同的起点和终点，上帝所给与我们的生命长度是如此的有限，我们又为什么不多经历一点曲折和弯路，多看点风景呢？\n老者和长辈总会淳淳教诲我们，少走弯路年轻人。然而那只是因为他们不知道别处的风景，不知道弯路上的风景，弯路上的经历，不知道我们所多走的距离和别人的生命相比起来是多么的宝贵。我想，此刻正在读这些文字的你们，应该有很多人也在这么迷茫着吧。我的经历也许并不是那么的石破天惊，我的价值观也许不是那么的正常，也许我在很多人眼里是没吃药才会写下这些文字，但我觉得，是不同的经历造就了不同的人格，可你若不去经历，你将永远不知道对岸的风景。我相信，不管是变成什么样的技术宅，只要学会了坚持，就可以拥有全世界。\n\n","updated":"2015-12-18T13:13:14.000Z","path":"bio/index.html","layout":"page","_id":"ciibs3s8j0002evs6dfh36n9c"},{"title":"关于","date":"2015-10-22T08:55:52.000Z","type":"about","comments":0,"_content":"\n## About me\n就职于[校园社交创业团队tataUFO](http://www.tataufo.com)/同时也是[SwiftGG中文翻译组](http://swift.gg/)成员。\n\n* 软件工程。喜欢梳理，喜欢好的设计和架构。\n* 团队狗。喜欢和一群好基友一起做好玩的事情。特别是Hackathon！狂热！\n* 自由主义。我不需要束缚，自由反而可以被更多的人认可，而束缚只会让自己虚度光阴。\n* 高效主义。可以两个小时写完的code就不要打断最后变成四个小时写完。\n* 写作。技术博客，文档，随笔。曾经也是文学青年。\n* 漫威粉。神盾局粉。\n* 证明自己。所有对我施来恶意的事物，我都会尽全力去证明自己，让他们收回恶意。\n* 最后一句，如小萌所说，**自命不凡**。\n\n## Skills\n我是个有自知之明的人，也不会妄自菲薄，所以我也不会随便吹牛自己会什么会什么。我明白有很多东西我很多时候只是停留在了实现上，也就是最终实现了所有需求，但是对更深层的原理并无深究。这不是说我不懂，我学过的基础知识足够我去理解大部分的原理，但可能我并没有兴趣去记忆这些原理。你可以说我是个表面的人，我并不会反驳，关于这样的歧视和误解我已经遇见过足够多了，理解的人自然明白，不理解的人也自然有他们的道理。\n\n我们不是每个人都能成为巧哥那样的大神，也不是每个人都能成为教授，所以花更多时间去做自己喜欢的东西，去实现自己认为能够改变自己生活方式，甚至改变他人生活方式的事物开始做起，不是更有意义吗？\n\n* **PHP** - 因为用的太熟练，沦为我写测试脚本，偶尔爬爬网页之类的工具语言\n* **Python** - 仅次于Swift的最好的语言！感觉不由自主的就开始思考架构，写算法也变得有趣了！以前用C++写上机题的时候真心想吐\n* **Objective-C** - Xcode是最好的IDE！……总之比Java整齐干净舒服多了\n* **Swift** - 只是初学者，参与了中文手册的翻译，现在定期翻译Swift的博客，偶尔也拿来写写算法玩\n* **C#，Java** 之流 - 都是基本技能了，C#写过一个编译器，也写过一个Lucence的搜索引擎，哦，还用Java撸过HMM算法，时间久远了，哈哈\n\n数据库也是我兴趣的一个重要方面，因为涉及到了存储和实际生产环境的应用：\n\n* **MySQL** - 这个不用说了，用的太多了\n* **Redis** - 从撸Feedly开始用，基本命令和数据结构就那些，属于高效易上手的NoSQL了吧\n* **Mongo** - 也用了很多了，数据库设计的思路会很不一样\n\n项目和经历什么的我不多说了，我的[Github仓库](https://github.com/SergioChan)和[Linkedin主页](https://cn.linkedin.com/pub/sergio-chan/42/14b/a6)都有足够的信息让你了解更多的我了。\n","source":"about/index.md","raw":"title: 关于\ndate: 2015-10-22 16:55:52\ntype: \"about\"\ncomments: false\n---\n\n## About me\n就职于[校园社交创业团队tataUFO](http://www.tataufo.com)/同时也是[SwiftGG中文翻译组](http://swift.gg/)成员。\n\n* 软件工程。喜欢梳理，喜欢好的设计和架构。\n* 团队狗。喜欢和一群好基友一起做好玩的事情。特别是Hackathon！狂热！\n* 自由主义。我不需要束缚，自由反而可以被更多的人认可，而束缚只会让自己虚度光阴。\n* 高效主义。可以两个小时写完的code就不要打断最后变成四个小时写完。\n* 写作。技术博客，文档，随笔。曾经也是文学青年。\n* 漫威粉。神盾局粉。\n* 证明自己。所有对我施来恶意的事物，我都会尽全力去证明自己，让他们收回恶意。\n* 最后一句，如小萌所说，**自命不凡**。\n\n## Skills\n我是个有自知之明的人，也不会妄自菲薄，所以我也不会随便吹牛自己会什么会什么。我明白有很多东西我很多时候只是停留在了实现上，也就是最终实现了所有需求，但是对更深层的原理并无深究。这不是说我不懂，我学过的基础知识足够我去理解大部分的原理，但可能我并没有兴趣去记忆这些原理。你可以说我是个表面的人，我并不会反驳，关于这样的歧视和误解我已经遇见过足够多了，理解的人自然明白，不理解的人也自然有他们的道理。\n\n我们不是每个人都能成为巧哥那样的大神，也不是每个人都能成为教授，所以花更多时间去做自己喜欢的东西，去实现自己认为能够改变自己生活方式，甚至改变他人生活方式的事物开始做起，不是更有意义吗？\n\n* **PHP** - 因为用的太熟练，沦为我写测试脚本，偶尔爬爬网页之类的工具语言\n* **Python** - 仅次于Swift的最好的语言！感觉不由自主的就开始思考架构，写算法也变得有趣了！以前用C++写上机题的时候真心想吐\n* **Objective-C** - Xcode是最好的IDE！……总之比Java整齐干净舒服多了\n* **Swift** - 只是初学者，参与了中文手册的翻译，现在定期翻译Swift的博客，偶尔也拿来写写算法玩\n* **C#，Java** 之流 - 都是基本技能了，C#写过一个编译器，也写过一个Lucence的搜索引擎，哦，还用Java撸过HMM算法，时间久远了，哈哈\n\n数据库也是我兴趣的一个重要方面，因为涉及到了存储和实际生产环境的应用：\n\n* **MySQL** - 这个不用说了，用的太多了\n* **Redis** - 从撸Feedly开始用，基本命令和数据结构就那些，属于高效易上手的NoSQL了吧\n* **Mongo** - 也用了很多了，数据库设计的思路会很不一样\n\n项目和经历什么的我不多说了，我的[Github仓库](https://github.com/SergioChan)和[Linkedin主页](https://cn.linkedin.com/pub/sergio-chan/42/14b/a6)都有足够的信息让你了解更多的我了。\n","updated":"2015-12-18T13:13:14.000Z","path":"about/index.html","layout":"page","_id":"ciibs3s9e0003evs6gegmgogl"}],"Post":[{"title":"runloop初窥","date":"2015-10-22T11:36:23.000Z","author":"Sergio Chan","_content":"\n## 先来说一个很简单的实例\n\n在scrollView中添加一个timer来刷新视图的时候，如果只是简单的声明\n\n\n```\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(timeUpdate:) userInfo:nil repeats:YES];\n```\n\n\n那么当你滑动或者保持你的手指在scrollView上的时候，timer是不会被响应的，这不是因为刷新视图的操作被占用，而是因为当你没有显式声明的时候，你所定义的timer默认都是加在主线程上，并且，当你在对scrollView进行操作的时候，你的timer的事件根本不会被响应到，这就得说到runloop了。而runloop也是底层原理中相当重要的一部分。我们先从它说起。\n\n## 什么是runloop\n\n\nRunloop，顾名思义就是运行的循环。简单理解就是多线程机制中的基础，它能够接收外部事件的输入，并且在有事件的时候保持运行，在没有事件的时候进入休眠。并且它对于线程的消息处理机制进行了很好的封装。\n\n对于线程来说，每一个线程都有一个runloop对象，是否能向某个线程的runloop发送事件取决于你是否启动了这个runloop，系统会默认在你的程序启动的时候运行主线程上的runloop，但是你自定义创建出来的线程可以不需要运行runloop，一些第三方框架，例如AFNetworking，就有在自己的线程上维护一个runloop对象。\n\n在 Core Foundation 里面关于 RunLoop 有5个类:\n\n*     CFRunLoopRef\n*     CFRunLoopModeRef\n*     CFRunLoopSourceRef \n*     CFRunLoopTimerRef \n*     CFRunLoopObserverRef\n\n他们的关系可以从NSRunloop对象的结构定义中得出。首先，runloop对象在Cocoa和Core Foundation中都有实现，但是他们做了很好的桥接，你可以直接调用\n\n```\nCFRunLoopRef runLoopRef = currentThreadRunLoop.getCFRunLoop;\n```\n\n来获取一个CoreFoundation中的runloop对象。然后，当你在查看NSRunloop的结构的时候，你应该能看到：\n\n```\n<CFRunLoop 0x7fd360f5af30 [0x1090a1180]>{wakeup port = 0x4507, stopped = false, ignoreWakeUps = true, \ncurrent mode = (none),\ncommon modes = <CFBasicHash 0x7fd360f5a470 [0x1090a1180]>{type = mutable set, count = 1,\nentries =>\n\t2 : <CFString 0x10907d080 [0x1090a1180]>{contents = \"kCFRunLoopDefaultMode\"}},\ncommon mode items = (null),\nmodes = <CFBasicHash 0x7fd360f5b2b0 [0x1090a1180]>{type = mutable set, count = 1,\nentries =>\n\t2 : <CFRunLoopMode 0x7fd360f5aff0 [0x1090a1180]>{name = kCFRunLoopDefaultMode, port set = 0x4703, timer port = 0x4803, \n\tsources0 = (null),\n\tsources1 = (null),\n\tobservers = <CFArray 0x7fd360f5b1a0 [0x1090a1180]>{type = mutable-small, count = 1, values = (\n\t0 : <CFRunLoopObserver 0x7fd360f5c7f0 [0x1090a1180]>{valid = Yes, activities = 0xfffffff, repeats = Yes, order = 0, callout = currentRunLoopObserver (0x10855b340), context = <CFRunLoopObserver context 0x7fd361213d70>}\n)},\n\ttimers = <CFArray 0x7fd360e020d0 [0x1090a1180]>{type = mutable-small, count = 1, values = (\n\t0 : <CFRunLoopTimer 0x7fd360e01f90 [0x1090a1180]>{valid = Yes, firing = No, interval = 1, tolerance = 0, next fire date = 463742311 (-2.53606331 @ 23607719248079), callout = (NSTimer) [SCCustomThread handleTimerTask] (0x1086416f1 / 0x10855b560) (/Users/useruser/Library/Developer/CoreSimulator/Devices/424D3C6E-8DC0-418B-A2EC-8EDF89507348/data/Containers/Bundle/Application/4D07AF38-9BFC-4617-BAE0-4CB0D7966CC8/runloopTest.app/runloopTest), context = <CFRunLoopTimer context 0x7fd360e01f70>}\n)},\n\tcurrently 463742313 (23610255156065) / soft deadline in: 1.84467441e+10 sec (@ 23607719248079) / hard deadline in: 1.84467441e+10 sec (@ 23607719248079)\n},}}\n```\n\n可以看到一个runloop对象包含各种Mode——currentMode，common mode，modes等等，这里的示例我只指定了一个defaultMode。每个mode对应了source，observers和timers。\n\n> 也许你会注意到 source 包括了source0和source1两个版本。\n> \n> * Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。\n> * Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。\n\nCFRunLoopObserver类型的对象也可以称之为观察者。每个观察者都包含了一个回调，当runloop的状态发生变化时，你可以通过回调来知道当前的状态。\n\n## Mode\n\n![image](https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg)\n\n在你的程序中，runloop的过程实际上是一个无限循环的循环体，这个循环体是由你的程序来运行的。主线程的runloop由于系统已经实现并且没有它程序就不能运行，因此不需要我们手动去运行这个runloop。然而如果我们需要在自定义的线程中使用到runloop，我们则需要用一个do...while循环来驱动它。而runloop对象负责不断地在循环体中运行传进来的事件，然后将事件发给相应的响应。\n\n> 如果你打开你的程序的main.m，你就会发现其实主线程的runloop就是在main函数中进行的，并且系统已经为你生成好了autoreleasepool，因此你也无需操心主线程上的内存释放到底是在什么时候执行了：\n\n```\nint main(int argc, char * argv[]) {\n     @autoreleasepool {\n         return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n     }\n}\n```\n\n根据响应源的不同，runloop也被分成了许多种不同的模式，这就是被Cocoa和Core Foundation都封装了的runloopMode。主要是这么几种：\n\n* NSDefaultRunLoopMode: 大多数工作中默认的运行方式。\n* NSConnectionReplyMode: 使用这个Mode去监听NSConnection对象的状态。\n* NSModalPanelRunLoopMode: 使用这个Mode在Model Panel情况下去区分事件(OS X开发中会遇到)。\n* NSEventTrackingRunLoopMode: 使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动）。\n* NSRunLoopCommonModes: 这是一个伪模式，其为一组run loop mode的集合。如果将Input source加入此模式，意味着关联Input source到Common Modes中包含的所有模式下。在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、NSTaskDeathCheckMode、NSEventTrackingRunLoopMode.可使用CFRunLoopAddCommonMode方法向Common Modes中添加自定义mode。\n\n在文首的情况中，我们可以根据苹果官方文档的定义知道，当你在滑动页面的时候，主线程的runloop自动进入了NSEventTrackingRunLoopMode，而你的timer只是运行在DefaultMode下，所以不能响应。那么最简单的办法就是将你的timer添加在其他的mode下，像这样即可：\n\n```\n[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];\n```\n\n需要注意的是CommonModes其实并不是一种Mode，而是一个集合。因此runloop并不能在CommonModes下运行，相反，你可以将需要输入的事件源添加为这个mode，这样无论runloop运行在哪个mode下都可以响应这个输入事件，否则这个事件将不会得到响应。\n\n## Input Source\n    \n输入源包括三种，端口，自定义输入源和performSelector的消息。根据上面的图我们可以看出，在runloop接收到消息并执行了指定方法的时候，它会执行runUntilDate:这个方法来退出当前循环。\n\n端口源是基于Mach port的，其他进程或线程可以通过端口来发送消息。这里的知识点需要深入到Mach，就已经比较晦涩难懂了……这里你只需要知道你可以用Cocoa封装的NSPort对象来进行线程之间的通信，而这种通信方式所产生的事件就是通过端口源来传入runloop的。关于Mach port的更深层介绍可以看[这篇](http://segmentfault.com/a/1190000002400329)。\n\n自定义输入源。Core Foundation提供了CFRunLoopSourceRef类型的相关函数，可以用来创建自定义输入源。\n\nperformSelector输入源:\n\n```\n//在主线程的Run Loop下执行指定的 @selector 方法\nperformSelectorOnMainThread:withObject:waitUntilDone:\nperformSelectorOnMainThread:withObject:waitUntilDone:modes:\n\n//在当前线程的Run Loop下执行指定的 @selector 方法\nperformSelector:onThread:withObject:waitUntilDone:\nperformSelector:onThread:withObject:waitUntilDone:modes:\n\n//在当前线程的Run Loop下延迟加载指定的 @selector 方法\nperformSelector:withObject:afterDelay:\nperformSelector:withObject:afterDelay:inModes:\n\n//取消当前线程的调用\ncancelPreviousPerformRequestsWithTarget:\ncancelPreviousPerformRequestsWithTarget:selector:object:\n```\n\n## runloop生命周期\n\n每一次runloop其实都是一次循环，runloop会在循环中执行runUntilDate: 或者runMode: beforeDate: 来开始每一个循环。而每一个循环又分为下面几个阶段，也就是runloop的生命周期：\n\n* kCFRunLoopEntry 进入循环\n* kCFRunLoopBeforeTimers 先接收timer的事件\n* kCFRunLoopBeforeSources 接收来自input source的事件\n* kCFRunLoopBeforeWaiting 如果没有事件，则准备进入休眠模式，在这里，如果没有事件传入，runloop会运行直到循环中给定的日期，如果你给的是distantFuture，那么这个runloop会无限等待下去\n* kCFRunLoopAfterWaiting 从休眠中醒来，直接回到kCFRunLoopBeforeTimers状态\n* kCFRunLoopExit 退出循环\n\n这些状态也是一个枚举类型，系统是这么定义的，你可以使用observer来观测到这些状态：\n\n```\n/* Run Loop Observer Activities */\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),\n    kCFRunLoopBeforeTimers = (1UL << 1),\n    kCFRunLoopBeforeSources = (1UL << 2),\n    kCFRunLoopBeforeWaiting = (1UL << 5),\n    kCFRunLoopAfterWaiting = (1UL << 6),\n    kCFRunLoopExit = (1UL << 7),\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n```\n\n我们下面做一个测试，在demo中我们定义了一个新的线程类，这样我们可以自己启动和维护它的runloop对象。\n\n```\n- (void)main\n{\n    @autoreleasepool {\n        NSLog(@\"Thread Enter\");\n        [[NSThread currentThread] setName:@\"This is a test thread\"];\n        NSRunLoop *currentThreadRunLoop = [NSRunLoop currentRunLoop];\n        // 或者\n        // CFRunLoopRef currentThreadRunLoop = CFRunLoopGetCurrent();\n        \n        CFRunLoopObserverContext context = {0, (__bridge void *)(self), NULL, NULL, NULL};\n        CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &currentRunLoopObserver, &context);\n        \n        if (observer) {\n            CFRunLoopRef runLoopRef = currentThreadRunLoop.getCFRunLoop;\n            CFRunLoopAddObserver(runLoopRef, observer, kCFRunLoopDefaultMode);\n        }\n        \n        // 创建一个Timer，重复调用来驱动Run Loop\n        //[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(handleTimerTask) userInfo:nil repeats:YES];\n        do {\n            [currentThreadRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:3]];\n        } while (1);\n    }\n}\n```\n\n输入源或者timer对于runloop来说是必要条件，如果没有添加任何输入源，则runloop根本不会启动，所以上面的代码中添加timer的操作，实际上是添加了一个默认的事件输入源，能让runloop保持运行。但是实际上，当你创建好一个runloop对象后，任何输入的事件都可以触发runloop的启动。\n\n例如下面的：\n\n```\n[self performSelector:@selector(selectorTest) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n```\n\n记住，如果你需要自己来启动和维护runloop的话，核心就在于一个do...while循环，你可以为runloop的跳出设置一个条件，也可以让runloop无限进行下去。在runloop没有接收到事件进入休眠状态之后，如果调用performSelector，runloop的状态变化如下：\n\n```\nCurrent thread Run Loop activity: kCFRunLoopAfterWaiting\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck\nfuck_1\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nCurrent thread Run Loop activity: kCFRunLoopBeforeWaiting\n```\n\n在这里我连续调用了两次performSelector，可以看到runloop也经历了两个循环，而如果只调用一次的话，不会有多出来的那次runloop（你可以自己尝试一下），这是否说明每一次performSelector执行完毕之后都会立即结束当前runloop开始新的，苹果的官方文档里有一句话：\n\n> The run loop processes all queued perform selector calls each time through the loop, rather than processing one during each loop iteration\n\n应该意思是并不是像上面看到的结果那样每一次循环执行一次，而是有一个待执行的操作队列。如果我同时执行四次performSelector，像这样：\n\n\n```\n\t[self performSelector:@selector(selectorTest) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n    [self performSelector:@selector(selectorTest_1) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n    [self performSelector:@selector(selectorTest_2) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n    [self performSelector:@selector(selectorTest_2) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n```\n实际上得到的结果和上面是一样的，然而当我将他们的waitUntilDone参数都设置为YES之后，我们可以看到不一样的地方：\n\n```\nThread Enter\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck_1\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck_2\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck_2\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nCurrent thread Run Loop activity: kCFRunLoopBeforeWaiting\n```\n\n你可以看到每一个performSelector操作都单独执行了一个runloop，从苹果的文档中我们可以找到这个方法的定义：\n\n> * performSelector:onThread:withObject:waitUntilDone:\n> * performSelector:onThread:withObject:waitUntilDone:modes:\n> \n> Performs the specified selector on any thread for which you have an NSThread object. These methods give you the option of blocking the current thread until the selector is performed.\n\n也就是说，waitUntilDone意味着这个操作是否会在当前线程阻塞其他的输入源，如果等于True，则每一次runloop循环只会处理这一个selector的调用，如果为False，则队列中后面等待着的selector调用都会在同一次runloop循环中执行。至于上文的执行了两个runloop循环的现象，我猜测应该是当runloop从休眠模式被唤醒的时候，当前循环执行完唤醒的操作后就会立即结束，释放掉之前可能累积下来的内存，然后开始新的循环，将队列中的其他输入逐个放进runloop循环中执行。\n\n\n","source":"_posts/runloop初窥.md","raw":"title: runloop初窥\ndate: 2015-10-22 19:36:23\ncategories: iOS菜鸟心得\nauthor: Sergio Chan\ntags: [iOS, runloop, NSThread]\n---\n\n## 先来说一个很简单的实例\n\n在scrollView中添加一个timer来刷新视图的时候，如果只是简单的声明\n\n\n```\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(timeUpdate:) userInfo:nil repeats:YES];\n```\n\n\n那么当你滑动或者保持你的手指在scrollView上的时候，timer是不会被响应的，这不是因为刷新视图的操作被占用，而是因为当你没有显式声明的时候，你所定义的timer默认都是加在主线程上，并且，当你在对scrollView进行操作的时候，你的timer的事件根本不会被响应到，这就得说到runloop了。而runloop也是底层原理中相当重要的一部分。我们先从它说起。\n\n## 什么是runloop\n\n\nRunloop，顾名思义就是运行的循环。简单理解就是多线程机制中的基础，它能够接收外部事件的输入，并且在有事件的时候保持运行，在没有事件的时候进入休眠。并且它对于线程的消息处理机制进行了很好的封装。\n\n对于线程来说，每一个线程都有一个runloop对象，是否能向某个线程的runloop发送事件取决于你是否启动了这个runloop，系统会默认在你的程序启动的时候运行主线程上的runloop，但是你自定义创建出来的线程可以不需要运行runloop，一些第三方框架，例如AFNetworking，就有在自己的线程上维护一个runloop对象。\n\n在 Core Foundation 里面关于 RunLoop 有5个类:\n\n*     CFRunLoopRef\n*     CFRunLoopModeRef\n*     CFRunLoopSourceRef \n*     CFRunLoopTimerRef \n*     CFRunLoopObserverRef\n\n他们的关系可以从NSRunloop对象的结构定义中得出。首先，runloop对象在Cocoa和Core Foundation中都有实现，但是他们做了很好的桥接，你可以直接调用\n\n```\nCFRunLoopRef runLoopRef = currentThreadRunLoop.getCFRunLoop;\n```\n\n来获取一个CoreFoundation中的runloop对象。然后，当你在查看NSRunloop的结构的时候，你应该能看到：\n\n```\n<CFRunLoop 0x7fd360f5af30 [0x1090a1180]>{wakeup port = 0x4507, stopped = false, ignoreWakeUps = true, \ncurrent mode = (none),\ncommon modes = <CFBasicHash 0x7fd360f5a470 [0x1090a1180]>{type = mutable set, count = 1,\nentries =>\n\t2 : <CFString 0x10907d080 [0x1090a1180]>{contents = \"kCFRunLoopDefaultMode\"}},\ncommon mode items = (null),\nmodes = <CFBasicHash 0x7fd360f5b2b0 [0x1090a1180]>{type = mutable set, count = 1,\nentries =>\n\t2 : <CFRunLoopMode 0x7fd360f5aff0 [0x1090a1180]>{name = kCFRunLoopDefaultMode, port set = 0x4703, timer port = 0x4803, \n\tsources0 = (null),\n\tsources1 = (null),\n\tobservers = <CFArray 0x7fd360f5b1a0 [0x1090a1180]>{type = mutable-small, count = 1, values = (\n\t0 : <CFRunLoopObserver 0x7fd360f5c7f0 [0x1090a1180]>{valid = Yes, activities = 0xfffffff, repeats = Yes, order = 0, callout = currentRunLoopObserver (0x10855b340), context = <CFRunLoopObserver context 0x7fd361213d70>}\n)},\n\ttimers = <CFArray 0x7fd360e020d0 [0x1090a1180]>{type = mutable-small, count = 1, values = (\n\t0 : <CFRunLoopTimer 0x7fd360e01f90 [0x1090a1180]>{valid = Yes, firing = No, interval = 1, tolerance = 0, next fire date = 463742311 (-2.53606331 @ 23607719248079), callout = (NSTimer) [SCCustomThread handleTimerTask] (0x1086416f1 / 0x10855b560) (/Users/useruser/Library/Developer/CoreSimulator/Devices/424D3C6E-8DC0-418B-A2EC-8EDF89507348/data/Containers/Bundle/Application/4D07AF38-9BFC-4617-BAE0-4CB0D7966CC8/runloopTest.app/runloopTest), context = <CFRunLoopTimer context 0x7fd360e01f70>}\n)},\n\tcurrently 463742313 (23610255156065) / soft deadline in: 1.84467441e+10 sec (@ 23607719248079) / hard deadline in: 1.84467441e+10 sec (@ 23607719248079)\n},}}\n```\n\n可以看到一个runloop对象包含各种Mode——currentMode，common mode，modes等等，这里的示例我只指定了一个defaultMode。每个mode对应了source，observers和timers。\n\n> 也许你会注意到 source 包括了source0和source1两个版本。\n> \n> * Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。\n> * Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。\n\nCFRunLoopObserver类型的对象也可以称之为观察者。每个观察者都包含了一个回调，当runloop的状态发生变化时，你可以通过回调来知道当前的状态。\n\n## Mode\n\n![image](https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg)\n\n在你的程序中，runloop的过程实际上是一个无限循环的循环体，这个循环体是由你的程序来运行的。主线程的runloop由于系统已经实现并且没有它程序就不能运行，因此不需要我们手动去运行这个runloop。然而如果我们需要在自定义的线程中使用到runloop，我们则需要用一个do...while循环来驱动它。而runloop对象负责不断地在循环体中运行传进来的事件，然后将事件发给相应的响应。\n\n> 如果你打开你的程序的main.m，你就会发现其实主线程的runloop就是在main函数中进行的，并且系统已经为你生成好了autoreleasepool，因此你也无需操心主线程上的内存释放到底是在什么时候执行了：\n\n```\nint main(int argc, char * argv[]) {\n     @autoreleasepool {\n         return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n     }\n}\n```\n\n根据响应源的不同，runloop也被分成了许多种不同的模式，这就是被Cocoa和Core Foundation都封装了的runloopMode。主要是这么几种：\n\n* NSDefaultRunLoopMode: 大多数工作中默认的运行方式。\n* NSConnectionReplyMode: 使用这个Mode去监听NSConnection对象的状态。\n* NSModalPanelRunLoopMode: 使用这个Mode在Model Panel情况下去区分事件(OS X开发中会遇到)。\n* NSEventTrackingRunLoopMode: 使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动）。\n* NSRunLoopCommonModes: 这是一个伪模式，其为一组run loop mode的集合。如果将Input source加入此模式，意味着关联Input source到Common Modes中包含的所有模式下。在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、NSTaskDeathCheckMode、NSEventTrackingRunLoopMode.可使用CFRunLoopAddCommonMode方法向Common Modes中添加自定义mode。\n\n在文首的情况中，我们可以根据苹果官方文档的定义知道，当你在滑动页面的时候，主线程的runloop自动进入了NSEventTrackingRunLoopMode，而你的timer只是运行在DefaultMode下，所以不能响应。那么最简单的办法就是将你的timer添加在其他的mode下，像这样即可：\n\n```\n[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];\n```\n\n需要注意的是CommonModes其实并不是一种Mode，而是一个集合。因此runloop并不能在CommonModes下运行，相反，你可以将需要输入的事件源添加为这个mode，这样无论runloop运行在哪个mode下都可以响应这个输入事件，否则这个事件将不会得到响应。\n\n## Input Source\n    \n输入源包括三种，端口，自定义输入源和performSelector的消息。根据上面的图我们可以看出，在runloop接收到消息并执行了指定方法的时候，它会执行runUntilDate:这个方法来退出当前循环。\n\n端口源是基于Mach port的，其他进程或线程可以通过端口来发送消息。这里的知识点需要深入到Mach，就已经比较晦涩难懂了……这里你只需要知道你可以用Cocoa封装的NSPort对象来进行线程之间的通信，而这种通信方式所产生的事件就是通过端口源来传入runloop的。关于Mach port的更深层介绍可以看[这篇](http://segmentfault.com/a/1190000002400329)。\n\n自定义输入源。Core Foundation提供了CFRunLoopSourceRef类型的相关函数，可以用来创建自定义输入源。\n\nperformSelector输入源:\n\n```\n//在主线程的Run Loop下执行指定的 @selector 方法\nperformSelectorOnMainThread:withObject:waitUntilDone:\nperformSelectorOnMainThread:withObject:waitUntilDone:modes:\n\n//在当前线程的Run Loop下执行指定的 @selector 方法\nperformSelector:onThread:withObject:waitUntilDone:\nperformSelector:onThread:withObject:waitUntilDone:modes:\n\n//在当前线程的Run Loop下延迟加载指定的 @selector 方法\nperformSelector:withObject:afterDelay:\nperformSelector:withObject:afterDelay:inModes:\n\n//取消当前线程的调用\ncancelPreviousPerformRequestsWithTarget:\ncancelPreviousPerformRequestsWithTarget:selector:object:\n```\n\n## runloop生命周期\n\n每一次runloop其实都是一次循环，runloop会在循环中执行runUntilDate: 或者runMode: beforeDate: 来开始每一个循环。而每一个循环又分为下面几个阶段，也就是runloop的生命周期：\n\n* kCFRunLoopEntry 进入循环\n* kCFRunLoopBeforeTimers 先接收timer的事件\n* kCFRunLoopBeforeSources 接收来自input source的事件\n* kCFRunLoopBeforeWaiting 如果没有事件，则准备进入休眠模式，在这里，如果没有事件传入，runloop会运行直到循环中给定的日期，如果你给的是distantFuture，那么这个runloop会无限等待下去\n* kCFRunLoopAfterWaiting 从休眠中醒来，直接回到kCFRunLoopBeforeTimers状态\n* kCFRunLoopExit 退出循环\n\n这些状态也是一个枚举类型，系统是这么定义的，你可以使用observer来观测到这些状态：\n\n```\n/* Run Loop Observer Activities */\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),\n    kCFRunLoopBeforeTimers = (1UL << 1),\n    kCFRunLoopBeforeSources = (1UL << 2),\n    kCFRunLoopBeforeWaiting = (1UL << 5),\n    kCFRunLoopAfterWaiting = (1UL << 6),\n    kCFRunLoopExit = (1UL << 7),\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n```\n\n我们下面做一个测试，在demo中我们定义了一个新的线程类，这样我们可以自己启动和维护它的runloop对象。\n\n```\n- (void)main\n{\n    @autoreleasepool {\n        NSLog(@\"Thread Enter\");\n        [[NSThread currentThread] setName:@\"This is a test thread\"];\n        NSRunLoop *currentThreadRunLoop = [NSRunLoop currentRunLoop];\n        // 或者\n        // CFRunLoopRef currentThreadRunLoop = CFRunLoopGetCurrent();\n        \n        CFRunLoopObserverContext context = {0, (__bridge void *)(self), NULL, NULL, NULL};\n        CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &currentRunLoopObserver, &context);\n        \n        if (observer) {\n            CFRunLoopRef runLoopRef = currentThreadRunLoop.getCFRunLoop;\n            CFRunLoopAddObserver(runLoopRef, observer, kCFRunLoopDefaultMode);\n        }\n        \n        // 创建一个Timer，重复调用来驱动Run Loop\n        //[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(handleTimerTask) userInfo:nil repeats:YES];\n        do {\n            [currentThreadRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:3]];\n        } while (1);\n    }\n}\n```\n\n输入源或者timer对于runloop来说是必要条件，如果没有添加任何输入源，则runloop根本不会启动，所以上面的代码中添加timer的操作，实际上是添加了一个默认的事件输入源，能让runloop保持运行。但是实际上，当你创建好一个runloop对象后，任何输入的事件都可以触发runloop的启动。\n\n例如下面的：\n\n```\n[self performSelector:@selector(selectorTest) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n```\n\n记住，如果你需要自己来启动和维护runloop的话，核心就在于一个do...while循环，你可以为runloop的跳出设置一个条件，也可以让runloop无限进行下去。在runloop没有接收到事件进入休眠状态之后，如果调用performSelector，runloop的状态变化如下：\n\n```\nCurrent thread Run Loop activity: kCFRunLoopAfterWaiting\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck\nfuck_1\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nCurrent thread Run Loop activity: kCFRunLoopBeforeWaiting\n```\n\n在这里我连续调用了两次performSelector，可以看到runloop也经历了两个循环，而如果只调用一次的话，不会有多出来的那次runloop（你可以自己尝试一下），这是否说明每一次performSelector执行完毕之后都会立即结束当前runloop开始新的，苹果的官方文档里有一句话：\n\n> The run loop processes all queued perform selector calls each time through the loop, rather than processing one during each loop iteration\n\n应该意思是并不是像上面看到的结果那样每一次循环执行一次，而是有一个待执行的操作队列。如果我同时执行四次performSelector，像这样：\n\n\n```\n\t[self performSelector:@selector(selectorTest) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n    [self performSelector:@selector(selectorTest_1) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n    [self performSelector:@selector(selectorTest_2) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n    [self performSelector:@selector(selectorTest_2) onThread:self.runLoopThread withObject:nil waitUntilDone:NO];\n```\n实际上得到的结果和上面是一样的，然而当我将他们的waitUntilDone参数都设置为YES之后，我们可以看到不一样的地方：\n\n```\nThread Enter\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck_1\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck_2\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nfuck_2\nCurrent thread Run Loop activity: kCFRunLoopExit\nCurrent thread Run Loop activity: kCFRunLoopEntry\nCurrent thread Run Loop activity: kCFRunLoopBeforeTimers\nCurrent thread Run Loop activity: kCFRunLoopBeforeSources\nCurrent thread Run Loop activity: kCFRunLoopBeforeWaiting\n```\n\n你可以看到每一个performSelector操作都单独执行了一个runloop，从苹果的文档中我们可以找到这个方法的定义：\n\n> * performSelector:onThread:withObject:waitUntilDone:\n> * performSelector:onThread:withObject:waitUntilDone:modes:\n> \n> Performs the specified selector on any thread for which you have an NSThread object. These methods give you the option of blocking the current thread until the selector is performed.\n\n也就是说，waitUntilDone意味着这个操作是否会在当前线程阻塞其他的输入源，如果等于True，则每一次runloop循环只会处理这一个selector的调用，如果为False，则队列中后面等待着的selector调用都会在同一次runloop循环中执行。至于上文的执行了两个runloop循环的现象，我猜测应该是当runloop从休眠模式被唤醒的时候，当前循环执行完唤醒的操作后就会立即结束，释放掉之前可能累积下来的内存，然后开始新的循环，将队列中的其他输入逐个放进runloop循环中执行。\n\n\n","slug":"runloop初窥","published":1,"updated":"2015-12-18T13:13:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciibs3s9h0004evs6qvjhg8tq"},{"title":"objective-c_runtime是什么","date":"2015-10-22T11:03:54.000Z","author":"Sergio Chan","_content":"## 当你调用一个方法的时候，发生了什么\n\n在Objective-C里，当你调用一个方法的时候，例如\n\n```\n[foo method];\n```\n\n的时候，实际上编译器会将它转化为这样\n\n```\nobjc_msgSend(foo,selector)\n```\n\n`selector`就是你能够经常用到的那个addTarget中使用到的，它在runtime机制中相当于一个函数的名牌，而IMP则是函数的实现。\n消息机制的关键是编译器是如何处理每一个类和对象的。一般来说，一个类会被编译成这样的结构，一个指向父类的指针，一个类的分派表。这个列表里存的是所有的`selector`和他们对应的方法的地址。没错，每个方法都有一个地址，通过地址来调用方法。而这个地址，就是由函数指针IMP来得到的。\n> 如果你学过编译原理，并且用其他语言自己写过一个编译器的话，你应该了解写一个基础语言调用方法的时候都会有一个全局的方法表，然后调用的过程实际上是去这个方法表中查找对应方法地址的过程。而Objective-C也是类似的，但是由于它是面向对象的，而且又有着这个runtime的特性，也就意味着在Objective-C中的函数调用实际上是在运行时动态的查询当前类和其父类的分派表。\n> 在分派表中，每一个selector都是由SEL对应IMP的形式存储着。我们可以找到SEL的定义\n> \n> \n```\ntypedef struct objc_selector   *SEL;  \n```\n> 所以SEL实际上表示的是方法的签名。在不同的类中如果有相同名称相同参数的方法，则他们的SEL是一样的。但是对应的IMP，也就是函数指针，是在runtime的时候才会动态的去查询然后调用的。\n> IMP的定义则是：\n> \n> \n```\ntypedef id (*IMP)(id, SEL, ...);\n```\n> \n> 我们可以看出，这个被指向的函数包含一个接收消息的对象id, 调用方法的签名 SEL，以及不定个数的方法参数，并返回一个id。也就是说 IMP 是消息最终调用的执行代码，是方法真正的实现代码。对于对象来说，当一个对象被分配空间并初始化之后，对象有一个指向它的类结构，也就是上面提到的这些东西的指针。这就是你所熟悉的`isa`，这样可以通过自身访问到自身的类以及无穷的父类里的方法列表。\n比方说，有一个继承于`NSObject`的foo类，然后又有一个foo1类继承于foo，这时候我们初始化一个foo1的实例对象A，然后调用A的某个方法B，这时候其实也就是向A发了一个消息，要调用B的`selector`。首先会做的是判断接收对象是不是nil，要记住空对象可以接收消息，因为当你向一个空对象发消息的时候，实际上处理的是一个`nil-handler`，而这个handler是啥也不会做的，因此什么也不会发生。\n接下来系统在运行时会先从foo1的分派表中寻找B的`selector`，如果没有，则向foo类找，如果有，则直接调用了，然后直到找到`NSObject`，如果这时候还找不到，那么就会报经典的**‘UnRecognized selector sent to instance’**，如果找到了，那就按照对应的地址找到函数，然后把需要的参数一起传过去。\n\n> 这里有个黑科技，其实也很简单，这个报错和崩溃来源于动态查询函数实现最终失败的调用`doesNotRecognizeSelector`，如果你重写了这个方法，那么对于这个类的对象的错误函数调用就可以避免crash了。但是实际上并没有什么卵用，这反而还掩盖了在消息发送和转发的过程中出现的一些异常。\n当然，系统为了加快这个速度，在上面这一步之前加上了分派表的缓存，秉承着你调用过的函数就有可能再次被调用的原则，你所调用过的函数会被加入到这个缓存表里来。因此，你可以认为当你的应用运行了一会儿之后，这个缓存会变大，然后这时候消息机制也会越变越快。\n最关键的点是在当这个查询最后在分派表中没有找到相应实现的时候，会进行一系列调用。而在这个过程中，我们可以做到动态绑定函数地址，动态重定向实现对象和动态重定向实现的函数地址。函数的地址也就是你常见的`IMP`。\n如果找到函数实现，则不会进入下面的流程。如果没有找到函数的实现，则会先调用`resolveInstanceMethod`这个函数。这个函数是在没有找到函数实现的情况下的第一道补救，这时候你可以通过`class_addMethod`动态添加函数。\n一个Objective-C的函数实际上就是一个简单地带有至少两个参数self和_cmd的C方法体。如官方文档给出的这样结构：\n\n```\nvoid dynamicMethodIMP(id self, SEL _cmd) {\n    // implementation ....\n}\n```\n\n在`resolveInstanceMethod`的时候，你可以这样动态添加一个函数，并且如果当你添加了函数的时候，你需要return YES。\n\n```\n@implementation MyClass\n+ (BOOL)resolveInstanceMethod:(SEL)aSEL\n{   \n    if (aSEL == @selector(resolveThisMethodDynamically)) {\n          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, \"v@:\");\n          return YES;\n    }\n    return [super resolveInstanceMethod:aSEL];}\n@end\n```\n\n这是第一个解决办法，当然，如果你返回了YES，则消息就将被发送到你刚添加的这个IMP去了，也就不会继续下面的消息转发机制了。因此苹果的官方文档就说，动态添加函数是在消息转发机制之前进行的。如果你动态添加了某些函数的实现，但还是希望他们能进入下面的消息转发机制里，你也可以让指定的`selector`返回NO就好了。\n接下去就是消息转发的流程了。\n一进入消息转发机制之后，runtime首先会调用`forwardingTargetForSelector`。这是让你能够指定对象来响应这个方法的地方，返回值是一个id对象，如果返回的是非空且不是自身的时候，runtime会将消息发送给这个对象，试图获得返回。当这一步仍然为空，则会进入下一步的流程。\n在下一步调用`forwardInvocation`之前，会走一个函数调用叫做`- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector`，在这里你可以为没有找到对应IMP的selector添加修改他们的方法签名，这里如果你抛出了一个函数的签名，则会继续传递到下一步中，如果抛出了nil，则你再也不会进到下一步了，在这里就直接报错了。你可以在这里做一些有趣的事情，例如修改一些没有实现的selector签名为一些已知的或者固定格式的，然后再由下面的`forwardInvocation`来提供分发之类的实现。\n当通过了上一步仍然没有函数实现能够响应这条消息的时候，runtime会向对象发送一个 `forwardInvocation：`的消息，并且会把**对函数的调用和附带的参数**封装成一个`NSInvocation`对象传过来。下面设想的是这么一个场景，你希望对A类对象的B方法调用由C类对象的B方法来响应。是的，你可以让A类来继承B类，但是很多情况下这会让情况变得更糟糕，特别是OC并不支持多继承的情况下。这时候就可以用消息转发机制来实现动态绑定啦！当消息不能被正确响应的时候，你需要确定消息将要发送的对象，然后将最开始的调用和参数列表一起发送过去。消息可以用`invokeWithTarget`来发送：\n\n```\n- (void)forwardInvocation:(NSInvocation *)anInvocation\n{\n    if ([someOtherObject respondsToSelector:\n            [anInvocation selector]])\n        [anInvocation invokeWithTarget:someOtherObject];\n    else\n        [super forwardInvocation:anInvocation];\n}\n```\n\n还有，记住每个`NSObject`的子类都继承了这个方法，但是如果你没有手动去重写的话，NSObject里的实现只会马上调用`doesNotRecognizeSelector`，也就是前面经典的报错。因此你需要手动重写它。\n这个方法所获得的返回都会返回给最初调用的发送者，不管他是谁。\n`forwardInvocation`可以作为未知消息的分发器，让他们各自发送到合理的对象那里去，也可以在这里就过滤掉一些可能会出错的返回和错误信息。\n利用消息转发机制我们也可以实现类似多继承的功能。如果A类中不存在B方法，而C类中有B方法，通过消息转发，我们就可以从A类调用B方法，并且通过`forwardInvocation`来分发，我们可以实现类似多继承的功能。但是这两者毕竟还是有区别的，因为多继承是一个可以在一个类中拥有许多父类的方法和属性。但是通过消息转发，我们也只是在消息层面上实现了拥有许多父类方法的能力。\n另外要提的就是，即使你做了消息转发来实现类似多继承的能力，当你调用`respondToSelector`或`isKindOfClass`的时候，他们只会去你自身的继承树里面去寻找`selector`，而并不会去识别你的消息转发机制。\n因此，当你需要为你的超级对象生成一个小的代理对象（surrodate object）的时候，或者你确实需要动态扩展你的类的时候，你需要重写很多方法。\n\n```\n- (BOOL)respondsToSelector:(SEL)aSelector\n{\n    if ( [super respondsToSelector:aSelector] )\n        return YES;\n    else {\n        /* Here, test whether the aSelector message can     *\n         * be forwarded to another object and whether that  *\n         * object can respond to it. Return YES if it can.  */\n    }\n    return NO;\n}\n```\n\n按照官方文档，你总共需要重写下面几个方法，并且都加上你的消息转发机制。\n* `respondsToSelector`\n* `isKindOfClass`\n* `instancesRespondToSelector`\n* `conformsToProtocol`（如果有用到协议）\n* `methodSignatureForSelector`\n\n哎，可是谁又会用得到呢。官方文档最后的小贴士说，这项技术不在走投无路的时候不要用，它不是用来替代继承的。对于我们最多只能是了解并且用到最表层的例如消息转发还有错误的拦截之类，在实际运用中也只对程序运行时的机制有了更好的了解，但是仍然并没有什么卵用。\n","source":"_posts/objective-c-runtime是什么.md","raw":"title: objective-c_runtime是什么\ndate: 2015-10-22 19:03:54\ncategories: iOS菜鸟心得\nauthor: Sergio Chan\ntags: [runtime,Objective-C,objc_msgSend]\n---\n## 当你调用一个方法的时候，发生了什么\n\n在Objective-C里，当你调用一个方法的时候，例如\n\n```\n[foo method];\n```\n\n的时候，实际上编译器会将它转化为这样\n\n```\nobjc_msgSend(foo,selector)\n```\n\n`selector`就是你能够经常用到的那个addTarget中使用到的，它在runtime机制中相当于一个函数的名牌，而IMP则是函数的实现。\n消息机制的关键是编译器是如何处理每一个类和对象的。一般来说，一个类会被编译成这样的结构，一个指向父类的指针，一个类的分派表。这个列表里存的是所有的`selector`和他们对应的方法的地址。没错，每个方法都有一个地址，通过地址来调用方法。而这个地址，就是由函数指针IMP来得到的。\n> 如果你学过编译原理，并且用其他语言自己写过一个编译器的话，你应该了解写一个基础语言调用方法的时候都会有一个全局的方法表，然后调用的过程实际上是去这个方法表中查找对应方法地址的过程。而Objective-C也是类似的，但是由于它是面向对象的，而且又有着这个runtime的特性，也就意味着在Objective-C中的函数调用实际上是在运行时动态的查询当前类和其父类的分派表。\n> 在分派表中，每一个selector都是由SEL对应IMP的形式存储着。我们可以找到SEL的定义\n> \n> \n```\ntypedef struct objc_selector   *SEL;  \n```\n> 所以SEL实际上表示的是方法的签名。在不同的类中如果有相同名称相同参数的方法，则他们的SEL是一样的。但是对应的IMP，也就是函数指针，是在runtime的时候才会动态的去查询然后调用的。\n> IMP的定义则是：\n> \n> \n```\ntypedef id (*IMP)(id, SEL, ...);\n```\n> \n> 我们可以看出，这个被指向的函数包含一个接收消息的对象id, 调用方法的签名 SEL，以及不定个数的方法参数，并返回一个id。也就是说 IMP 是消息最终调用的执行代码，是方法真正的实现代码。对于对象来说，当一个对象被分配空间并初始化之后，对象有一个指向它的类结构，也就是上面提到的这些东西的指针。这就是你所熟悉的`isa`，这样可以通过自身访问到自身的类以及无穷的父类里的方法列表。\n比方说，有一个继承于`NSObject`的foo类，然后又有一个foo1类继承于foo，这时候我们初始化一个foo1的实例对象A，然后调用A的某个方法B，这时候其实也就是向A发了一个消息，要调用B的`selector`。首先会做的是判断接收对象是不是nil，要记住空对象可以接收消息，因为当你向一个空对象发消息的时候，实际上处理的是一个`nil-handler`，而这个handler是啥也不会做的，因此什么也不会发生。\n接下来系统在运行时会先从foo1的分派表中寻找B的`selector`，如果没有，则向foo类找，如果有，则直接调用了，然后直到找到`NSObject`，如果这时候还找不到，那么就会报经典的**‘UnRecognized selector sent to instance’**，如果找到了，那就按照对应的地址找到函数，然后把需要的参数一起传过去。\n\n> 这里有个黑科技，其实也很简单，这个报错和崩溃来源于动态查询函数实现最终失败的调用`doesNotRecognizeSelector`，如果你重写了这个方法，那么对于这个类的对象的错误函数调用就可以避免crash了。但是实际上并没有什么卵用，这反而还掩盖了在消息发送和转发的过程中出现的一些异常。\n当然，系统为了加快这个速度，在上面这一步之前加上了分派表的缓存，秉承着你调用过的函数就有可能再次被调用的原则，你所调用过的函数会被加入到这个缓存表里来。因此，你可以认为当你的应用运行了一会儿之后，这个缓存会变大，然后这时候消息机制也会越变越快。\n最关键的点是在当这个查询最后在分派表中没有找到相应实现的时候，会进行一系列调用。而在这个过程中，我们可以做到动态绑定函数地址，动态重定向实现对象和动态重定向实现的函数地址。函数的地址也就是你常见的`IMP`。\n如果找到函数实现，则不会进入下面的流程。如果没有找到函数的实现，则会先调用`resolveInstanceMethod`这个函数。这个函数是在没有找到函数实现的情况下的第一道补救，这时候你可以通过`class_addMethod`动态添加函数。\n一个Objective-C的函数实际上就是一个简单地带有至少两个参数self和_cmd的C方法体。如官方文档给出的这样结构：\n\n```\nvoid dynamicMethodIMP(id self, SEL _cmd) {\n    // implementation ....\n}\n```\n\n在`resolveInstanceMethod`的时候，你可以这样动态添加一个函数，并且如果当你添加了函数的时候，你需要return YES。\n\n```\n@implementation MyClass\n+ (BOOL)resolveInstanceMethod:(SEL)aSEL\n{   \n    if (aSEL == @selector(resolveThisMethodDynamically)) {\n          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, \"v@:\");\n          return YES;\n    }\n    return [super resolveInstanceMethod:aSEL];}\n@end\n```\n\n这是第一个解决办法，当然，如果你返回了YES，则消息就将被发送到你刚添加的这个IMP去了，也就不会继续下面的消息转发机制了。因此苹果的官方文档就说，动态添加函数是在消息转发机制之前进行的。如果你动态添加了某些函数的实现，但还是希望他们能进入下面的消息转发机制里，你也可以让指定的`selector`返回NO就好了。\n接下去就是消息转发的流程了。\n一进入消息转发机制之后，runtime首先会调用`forwardingTargetForSelector`。这是让你能够指定对象来响应这个方法的地方，返回值是一个id对象，如果返回的是非空且不是自身的时候，runtime会将消息发送给这个对象，试图获得返回。当这一步仍然为空，则会进入下一步的流程。\n在下一步调用`forwardInvocation`之前，会走一个函数调用叫做`- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector`，在这里你可以为没有找到对应IMP的selector添加修改他们的方法签名，这里如果你抛出了一个函数的签名，则会继续传递到下一步中，如果抛出了nil，则你再也不会进到下一步了，在这里就直接报错了。你可以在这里做一些有趣的事情，例如修改一些没有实现的selector签名为一些已知的或者固定格式的，然后再由下面的`forwardInvocation`来提供分发之类的实现。\n当通过了上一步仍然没有函数实现能够响应这条消息的时候，runtime会向对象发送一个 `forwardInvocation：`的消息，并且会把**对函数的调用和附带的参数**封装成一个`NSInvocation`对象传过来。下面设想的是这么一个场景，你希望对A类对象的B方法调用由C类对象的B方法来响应。是的，你可以让A类来继承B类，但是很多情况下这会让情况变得更糟糕，特别是OC并不支持多继承的情况下。这时候就可以用消息转发机制来实现动态绑定啦！当消息不能被正确响应的时候，你需要确定消息将要发送的对象，然后将最开始的调用和参数列表一起发送过去。消息可以用`invokeWithTarget`来发送：\n\n```\n- (void)forwardInvocation:(NSInvocation *)anInvocation\n{\n    if ([someOtherObject respondsToSelector:\n            [anInvocation selector]])\n        [anInvocation invokeWithTarget:someOtherObject];\n    else\n        [super forwardInvocation:anInvocation];\n}\n```\n\n还有，记住每个`NSObject`的子类都继承了这个方法，但是如果你没有手动去重写的话，NSObject里的实现只会马上调用`doesNotRecognizeSelector`，也就是前面经典的报错。因此你需要手动重写它。\n这个方法所获得的返回都会返回给最初调用的发送者，不管他是谁。\n`forwardInvocation`可以作为未知消息的分发器，让他们各自发送到合理的对象那里去，也可以在这里就过滤掉一些可能会出错的返回和错误信息。\n利用消息转发机制我们也可以实现类似多继承的功能。如果A类中不存在B方法，而C类中有B方法，通过消息转发，我们就可以从A类调用B方法，并且通过`forwardInvocation`来分发，我们可以实现类似多继承的功能。但是这两者毕竟还是有区别的，因为多继承是一个可以在一个类中拥有许多父类的方法和属性。但是通过消息转发，我们也只是在消息层面上实现了拥有许多父类方法的能力。\n另外要提的就是，即使你做了消息转发来实现类似多继承的能力，当你调用`respondToSelector`或`isKindOfClass`的时候，他们只会去你自身的继承树里面去寻找`selector`，而并不会去识别你的消息转发机制。\n因此，当你需要为你的超级对象生成一个小的代理对象（surrodate object）的时候，或者你确实需要动态扩展你的类的时候，你需要重写很多方法。\n\n```\n- (BOOL)respondsToSelector:(SEL)aSelector\n{\n    if ( [super respondsToSelector:aSelector] )\n        return YES;\n    else {\n        /* Here, test whether the aSelector message can     *\n         * be forwarded to another object and whether that  *\n         * object can respond to it. Return YES if it can.  */\n    }\n    return NO;\n}\n```\n\n按照官方文档，你总共需要重写下面几个方法，并且都加上你的消息转发机制。\n* `respondsToSelector`\n* `isKindOfClass`\n* `instancesRespondToSelector`\n* `conformsToProtocol`（如果有用到协议）\n* `methodSignatureForSelector`\n\n哎，可是谁又会用得到呢。官方文档最后的小贴士说，这项技术不在走投无路的时候不要用，它不是用来替代继承的。对于我们最多只能是了解并且用到最表层的例如消息转发还有错误的拦截之类，在实际运用中也只对程序运行时的机制有了更好的了解，但是仍然并没有什么卵用。\n","slug":"objective-c-runtime是什么","published":1,"updated":"2015-12-18T13:13:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciibs3s9t000devs6hv6u0l9e"},{"title":"iOS 静态库封装和使用方法","date":"2014-12-10T12:47:54.000Z","author":"Sergio Chan","_content":"\n由于现在的任务是将之前已经进行了第一步demo的验证，我需要将demo里的需要的部分整理出来，封装成静态库，从而给其他开发者使用。iOS封装静态库在百度上已经有很多教程了，但是实际中我却遇到了这样的问题：\n\n* 静态库里的代码需要引用到其他静态库，不是简单的控件封装。\n* 之前的项目大部分引用的文件都只是加在了Library和Header search path中，并没有真正添加在项目中。\n\n第一步，新建一个Framework&Library ->Cocoa Touch Static Library 的工程。\n将我需要的代码文件添加进项目目录下。修改build setting，和之前完整的工程的配置基本一样即可。\n对于引用到的其他静态库，确认它处于Link Binary With Libraries下。\n再确认Library和Header search path指向了正确的头文件或库文件的路径。删除多余的库文件以保证最后的静态库体积最小。\n\n第二步，选择真机环境编译，这里编译的target选的不一样，编译出来的静态库可运行环境就不一样。由于我需要编译的这个功能也只能运行在真机上，所以就直接在真机环境下编译即可。\n\n第三步，编译之前注意选择Build Phase->Copy Files，将之后需要展示出来的头文件添加进去。注意Copy only when installing不要选中。\n\n第四步可以编译了，跑出来的静态库如果没有报错就是可以使用的了。在使用这个静态库的时候也一定要注意所有的头文件和库文件，包括静态库需要指向的头文件，都要在新工程的build setting里设置清楚。实验证明= =如果一个静态库里会用到其他静态库的话，是可以把静态库压的更小的。。。并且引用还是比较好解决的，只要保证各种路径都指向正确。\n","source":"_posts/iOS-静态库封装和使用方法.md","raw":"title: iOS 静态库封装和使用方法\ndate: 2014-12-10 20:47:54\ncategories: iOS菜鸟心得\nauthor: Sergio Chan\ntags: [iOS静态库]\n---\n\n由于现在的任务是将之前已经进行了第一步demo的验证，我需要将demo里的需要的部分整理出来，封装成静态库，从而给其他开发者使用。iOS封装静态库在百度上已经有很多教程了，但是实际中我却遇到了这样的问题：\n\n* 静态库里的代码需要引用到其他静态库，不是简单的控件封装。\n* 之前的项目大部分引用的文件都只是加在了Library和Header search path中，并没有真正添加在项目中。\n\n第一步，新建一个Framework&Library ->Cocoa Touch Static Library 的工程。\n将我需要的代码文件添加进项目目录下。修改build setting，和之前完整的工程的配置基本一样即可。\n对于引用到的其他静态库，确认它处于Link Binary With Libraries下。\n再确认Library和Header search path指向了正确的头文件或库文件的路径。删除多余的库文件以保证最后的静态库体积最小。\n\n第二步，选择真机环境编译，这里编译的target选的不一样，编译出来的静态库可运行环境就不一样。由于我需要编译的这个功能也只能运行在真机上，所以就直接在真机环境下编译即可。\n\n第三步，编译之前注意选择Build Phase->Copy Files，将之后需要展示出来的头文件添加进去。注意Copy only when installing不要选中。\n\n第四步可以编译了，跑出来的静态库如果没有报错就是可以使用的了。在使用这个静态库的时候也一定要注意所有的头文件和库文件，包括静态库需要指向的头文件，都要在新工程的build setting里设置清楚。实验证明= =如果一个静态库里会用到其他静态库的话，是可以把静态库压的更小的。。。并且引用还是比较好解决的，只要保证各种路径都指向正确。\n","slug":"iOS-静态库封装和使用方法","published":1,"updated":"2015-12-18T13:13:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciibs3s9y000levs62z2mlrhl"},{"title":"Ubuntu下重置MySQL的root密码","date":"2014-12-12T02:10:45.000Z","author":"Sergio Chan","_content":"\nsudo vi /etc/mysql/my.cnf，在[mysqld]段中加入一行“skip-grant-tables”\n具体环境中可能my.cnf已经存在且在其他目录，记得要找到有效的my.cnf配置文件路径\n\nsudo service mysql restart，重启mySQL服务\n具体参考实际的重启MySQL的命令\n\nsudo mysql -u root -p mysql，用空密码进入mysql管理命令行\n\n(进入mysql,或者用use mysql指令)\n\nupdate user set password=PASSWORD(\"123\") where user='root';，把密码重置为123\n\n(注意，如果是表中没有的用户名，使用insert)\n\nquit，退出数据库管理\n\nsudo vim /etc/mysql/my.cnf，把刚才加入的那一行“skip-grant-tables”注释或删除\n\nsudo service mysql restart，OK，搞定！","source":"_posts/Ubuntu下重置MySQL的root密码.md","raw":"title: Ubuntu下重置MySQL的root密码\ndate: 2014-12-12 10:10:45\ncategories: Linux服务器笔记\nauthor: Sergio Chan\ntags: [Ubuntu, MySQL]\n---\n\nsudo vi /etc/mysql/my.cnf，在[mysqld]段中加入一行“skip-grant-tables”\n具体环境中可能my.cnf已经存在且在其他目录，记得要找到有效的my.cnf配置文件路径\n\nsudo service mysql restart，重启mySQL服务\n具体参考实际的重启MySQL的命令\n\nsudo mysql -u root -p mysql，用空密码进入mysql管理命令行\n\n(进入mysql,或者用use mysql指令)\n\nupdate user set password=PASSWORD(\"123\") where user='root';，把密码重置为123\n\n(注意，如果是表中没有的用户名，使用insert)\n\nquit，退出数据库管理\n\nsudo vim /etc/mysql/my.cnf，把刚才加入的那一行“skip-grant-tables”注释或删除\n\nsudo service mysql restart，OK，搞定！","slug":"Ubuntu下重置MySQL的root密码","published":1,"updated":"2015-12-18T13:13:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciibs3s9z000pevs6sn05ahdw"},{"title":"[UIColor colorWithRed: green: blue: alpha:] 的正确用法","date":"2015-02-02T13:37:10.000Z","author":"Sergio Chan","_content":"\n[UIColor colorWithRed: green: blue: alpha:] 颜色值范围都是在0.0~1.0之间的，并不是我们误认为的0~255。\n\n正确用法：\n\n```\n[UIColor colorWithRed:240.0/255 green:240.0/255 blue:240.0/255 alpha:1.0];\n```\n\n> colorWithRed:green:blue:alpha:\n> Creates and returns a color object using the specified opacity and RGB component values.\n> \n> Declaration\n> OBJECTIVE-C\n> + (UIColor *)colorWithRed:(CGFloat)red\n> green:(CGFloat)green\n> blue:(CGFloat)blue\n> alpha:(CGFloat)alpha\n> \n> Parameters\n> \n> red\n> \n> The red component of the color object, specified as a value from 0.0 to 1.0.\n> \n> green\n> \n> The green component of the color object, specified as a value from 0.0 to 1.0.\n> \n> blue\n> \n> The blue component of the color object, specified as a value from 0.0 to 1.0.\n> \n> alpha\n> \n> The opacity value of the color object, specified as a value from 0.0 to 1.0.\n> \n> Return Value\n> \n> The color object. The color information represented by this object is in the device RGB colorspace.\n> \n> Discussion\n> Values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0.\n> \n> Import Statement\n> Availability\n> Available in iOS 2.0 and later.\n\n","source":"_posts/UIColor-colorWithRed-green-blue-alpha-的正确用法.md","raw":"title: '[UIColor colorWithRed: green: blue: alpha:] 的正确用法'\ndate: 2015-2-2 21:37:10\ncategories: iOS菜鸟心得\nauthor: Sergio Chan\ntags: [UIColor]\n---\n\n[UIColor colorWithRed: green: blue: alpha:] 颜色值范围都是在0.0~1.0之间的，并不是我们误认为的0~255。\n\n正确用法：\n\n```\n[UIColor colorWithRed:240.0/255 green:240.0/255 blue:240.0/255 alpha:1.0];\n```\n\n> colorWithRed:green:blue:alpha:\n> Creates and returns a color object using the specified opacity and RGB component values.\n> \n> Declaration\n> OBJECTIVE-C\n> + (UIColor *)colorWithRed:(CGFloat)red\n> green:(CGFloat)green\n> blue:(CGFloat)blue\n> alpha:(CGFloat)alpha\n> \n> Parameters\n> \n> red\n> \n> The red component of the color object, specified as a value from 0.0 to 1.0.\n> \n> green\n> \n> The green component of the color object, specified as a value from 0.0 to 1.0.\n> \n> blue\n> \n> The blue component of the color object, specified as a value from 0.0 to 1.0.\n> \n> alpha\n> \n> The opacity value of the color object, specified as a value from 0.0 to 1.0.\n> \n> Return Value\n> \n> The color object. The color information represented by this object is in the device RGB colorspace.\n> \n> Discussion\n> Values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0.\n> \n> Import Statement\n> Availability\n> Available in iOS 2.0 and later.\n\n","slug":"UIColor-colorWithRed-green-blue-alpha-的正确用法","published":1,"updated":"2015-12-18T13:13:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciibs3sa2000wevs643i6a305"},{"title":"Python利用深度优先搜索解数独程序的实现","date":"2015-05-19T13:30:29.000Z","author":"Sergio Chan","_content":"\n\n> 本文附带项目Github仓库地址，随手star是个好习惯：\n> [https://github.com/SergioChan/Python-Sudoku](https://github.com/SergioChan/Python-Sudoku)\n\n前两天吃饭的时候听到旁边一桌估计是搜狐或者网易的程序猿在说要是新员工给我面试我就让他写个解数独的Python程序，他二十分钟就能连伪代码加实现一起搞定……我上网一看，解数独这个问题确实挺有趣的，主要是纯凭自己好像很偶尔才能解出一个数独来的样子，于是根据以前学的数据结构的基础和最近新学的Python功底，小试牛刀一下，就使用最简单的回溯方法来实现，我知道百度上其实挺多的，但是说实话那些乱七八糟的代码我也看不太懂，自己想自己写可能思路属于自己，会比较清晰吧。回溯搜索是深度优先搜索（DFS）的一种\n对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。\n“芬兰数学家因卡拉，花费3个月时间设计出的世界上迄今难度最大的数独游戏，而且它只有一个答案。因卡拉说只有思考能力最快、头脑最聪明的人才能破解这个游戏。”这是英国《每日邮报》2012年6月30日的一篇报道。我接下来就会用这个数独来做示范，说明利用回溯解决这个问题的思路。\n\n![image](http://chenyh-blog.com/wp-content/uploads/2015/05/soduku.png)\n\n解决数独的关键思想在于找到一个入口点，将解决树一层层撸下去，遇到无法继续生长下去的结点，就往上回溯，回溯之后从上一个结点的其他分支继续往下走，如果没有其他分支则继续往上回溯。\n先将整个数独矩阵用二维数组存储：\n\n```\nproblem = \\\n    [\n        [8,0,0,0,0,0,0,0,0],\n        [0,0,3,6,0,0,0,0,0],\n        [0,7,0,0,9,0,2,0,0],\n        [0,5,0,0,0,7,0,0,0],\n        [0,0,0,0,4,5,7,0,0],\n        [0,0,0,1,0,0,0,3,0],\n        [0,0,1,0,0,0,0,6,8],\n        [0,0,8,5,0,0,0,1,0],\n        [0,9,0,0,0,0,4,0,0]\n]\n```\n\n之后，在解的过程中，由于需要回溯，所以需要把经历过的节点记录下来，我并不知道有没有更好的处理方式，这里用的是栈的存储方式，将经历过的节点存储在solutionStack中，当需要回溯的时候，直接pop掉栈顶的solution，如果解完了，则栈顶就是最后的结果。当经历了一个新的分支，在矩阵中添加了一个新的值，则随之产生一个新的节点，压入栈中。\n然后，每个节点的数据并不只限于当前的矩阵状态（我其实觉得这里换成一个节点的数据结构会比较好），还包括矩阵中每个点可能的分支，这个栈的压入和弹出是和solutionStack同步的。每当进入新的分支，都需要将这个节点的可能解中修改过的值去掉，这样在往下走并且回溯的时候，就可以回到这个节点的修改后的可能解情况，即刚刚走过的那个分支不会再重复走一遍。\n主方法：\n\n```\nimport time\nimport copy\ndef resolve(problem):\n    solutionStack = [problem]\n    tmp = get_solution_array(problem)\n    solutionArrayStack = [tmp]\n    # problem = [[0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0]]\n    while 1:\n        # fetch the last solution in solution stack\n        next_item_cord = {}\n        solutionArray = []\n        # print 'still ',len(solutionStack),'in stack'\n        solutionNow = copy.deepcopy(solutionStack[len(solutionStack)-1])\n        solutionArray = solutionArrayStack[len(solutionArrayStack)-1]\n\n        flag = check_if_need_to_back(solutionNow,solutionArray)\n        if flag is True:\n            # print 'pop!'\n            solutionArrayStack.pop()\n            solutionStack.pop()\n        else:\n\n            next_item_cord = get_first_possible_item(solutionArray)\n            if next_item_cord == False:\n                break\n            # print 'next_item_cord:',next_item_cord\n            next_item_array = solutionArray[next_item_cord['x']][next_item_cord['y']]\n            solutionNow[next_item_cord['x']][next_item_cord['y']]=next_item_array[0]\n\n            solutionArray_tmp = get_solution_array(solutionNow)\n            if solutionArray[next_item_cord['x']][next_item_cord['y']].count(solutionNow[next_item_cord['x']][next_item_cord['y']])>0:\n                solutionArray[next_item_cord['x']][next_item_cord['y']].remove(solutionNow[next_item_cord['x']][next_item_cord['y']])\n            solutionStack.append(solutionNow)\n            solutionArrayStack.append(solutionArray_tmp)\n    for i in range(0,9,1):\n            print solutionStack[len(solutionStack)-1][i]\n```\n\n在开始循环之前，需要先获得初始状态的分支情况，因此独立的获取分支状况的方法如下：\n\n```\ndef get_solution_array(problem):\n    startTime=time.time()\n    tmp = []\n    for i in range(0,9,1):\n        tmp_line_array = []\n        for j in range(0,9,1):\n            # print '['+bytes(i)+','+bytes(j)+']: '+ bytes(problem[i][j])\n            if problem[i][j]==0:\n                # no value, get possible value array\n                tmp_value = [1,2,3,4,5,6,7,8,9]\n\n                # remove the existed value in line\n                for tmp_j in range(0,9,1):\n                    if problem[i][tmp_j]!=0:\n                        if problem[i][tmp_j] in tmp_value:\n                            tmp_value.remove(problem[i][tmp_j])\n\n                # remove the existed value in column\n                for tmp_i in range(0,9,1):\n                    if problem[tmp_i][j]!=0:\n                        if problem[tmp_i][j] in tmp_value:\n                            tmp_value.remove(problem[tmp_i][j])\n\n                # remove the existed value in the rectangle\n                for x in range(i/3*3,i/3*3+3):\n                    for y in range(j/3*3,j/3*3+3):\n                        if problem[x][y]!=0:\n                            if problem[x][y] in tmp_value:\n                                tmp_value.remove(problem[x][y])\n\n                tmp_line_array.append(tmp_value)\n            else:\n                tmp_line_array.append([])\n        tmp.append(tmp_line_array)\n        #print tmp_line_array\n    # print tmp\n    endTime=time.time()\n    print \"get_solution_array! Time consuming: \" + \"%.4f\" % (endTime-startTime) + \" Seconds\"\n    return tmp\n```\n\n这里需要说一点，其实每次压栈的时候节点状态做局部更新就好了，这样会减少很大的计算量，这个优化会在之后进行。每次到了新节点都要寻找下一个修改的坐标，这里就寻找的是下一个可能解最少的元素作为下一个节点。\n\n```\ndef get_first_possible_item(solution_array):\n    startTime=time.time()\n    is_finished = True\n    shortest_item_length = 9\n    shortest_item_x = 0\n    shortest_item_y = 0\n    for i in range(0,9,1):\n        for j in range(0,9,1):\n            tmp_length = len(solution_array[i][j])\n            if tmp_length!=0:\n                is_finished = False\n                if tmp_length<shortest_item_length:\n                    shortest_item_length = tmp_length\n                    shortest_item_x = i\n                    shortest_item_y = j\n\n    # print 'shortest item is:',shortest_item_length,shortest_item_x,shortest_item_y\n    endTime=time.time()\n    print \"get_first_possible_item! Time consuming: \" + \"%.4f\" % (endTime-startTime) + \" Seconds\"\n    if is_finished:\n        return False\n    else:\n        return {'x':shortest_item_x,'y':shortest_item_y}\n```\n\n补充一个判断是否需要回溯的方法：\n\n```\ndef check_if_need_to_back(solutionNow,solutionArray):\n    for i in range(0,9,1):\n        for j in range(0,9,1):\n            if len(solutionArray[i][j]) == 0 and solutionNow[i][j] == 0:\n                return True\n    return False\n```\n\n最后的输出：\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\nFinished! Time consuming: 5.2055 Seconds\n```\n\n这里的一处细节是最后的运行时间是5.2055秒，这相对于其他人的实现方式慢了一些，我在get_solution_array中用来判断所获取的值是否在可能解的候选数组中的时候，之前用的是list.count(object)这个方法来判断，后来改成了in，事实证明如果使用.count的话总消耗大概在5.6秒左右，会比in多出0.4S。\n\n恩。我改成局部更新数据了。新的获取可能解的方法：\n\n```\ndef get_resolution_array_new(solutionArray,x,y,value):\n    for tmp_j in range(0,9,1):\n        if value in solutionArray[x][tmp_j]:\n            solutionArray[x][tmp_j].remove(value)\n    for tmp_i in range(0,9,1):\n        if value in solutionArray[tmp_i][y]:\n            solutionArray[tmp_i][y].remove(value)\n    for tmp_i in range(x/3*3,x/3*3+3):\n        for tmp_j in range(y/3*3,y/3*3+3):\n            if value in solutionArray[tmp_i][tmp_j]:\n                solutionArray[tmp_i][tmp_j].remove(value)\n    return solutionArray\n```\n\n将主方法中38行代码改为：\n\n```\nsolutionArray_tmp = copy.deepcopy(solutionArray)\nsolutionArray_tmp = get_resolution_array_new(solutionArray_tmp,next_item_cord['x'],next_item_cord['y'],next_item_array[0])\n```\n\n最后的结果如下……也不咋地嘛，只是快了0.4S……看来还有优化空间吧\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\nFinished! Time consuming: 4.8577 Seconds\n```\n\n-->继续补充\n早上起来想了想又监控了一下，发现最主要耗时的还是在走的分支数量上，如果按照每次往下都默认走最左边的分支，那么前进会操作12000多次，回溯也差不多这个数，这是导致时间增大的主要原因。我没有想好如何在几个分支要选择的时候选择最优分支……毕竟我觉得去选择最优分支也要消耗时间，考虑太多意义不大……于是我就简单的尝试了一下随机分支，当程序运行到一个节点需要继续往下分支的时候随机选择一个分支，随机就用的最简单的随机方法，结果效果惊人，最快的时候可以达到：\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\nFinished! Time consuming: 1.8991 Seconds\n```\n\n当然由于采用了随机，所以时间并不稳定……在这种最优解的情况下只要前进5000次就能到达最终解。如何有一个稳定的最优算法也许永远会是个谜吧。\n随机选择分支的代码如下：\n\n```\nnext_item_array = solutionArray[next_item_cord['x']][next_item_cord['y']]\n                next_item = next_item_array[randint(0,len(next_item_array)-1)]\n                solutionNow[next_item_cord['x']][next_item_cord['y']] = next_item\n\n                # solutionArray_tmp = get_solution_array(solutionNow)\n                solutionArray_tmp = copy.deepcopy(solutionArray)\n                solutionArray_tmp = self.get_resolution_array_new(solutionArray_tmp, next_item_cord['x'], next_item_cord['y'],\n                                                             next_item)\n                if next_item in solutionArray[next_item_cord['x']][next_item_cord['y']]:\n                    solutionArray[next_item_cord['x']][next_item_cord['y']].remove(\n                        next_item)\n```\n\n-->又找出一个问题\n在获取下一个最优节点的过程中，没有算上当前矩阵中的那个值，所以会导致一个点连续的用了两次，最后可能还要回溯，所以修改了一下代码后，效率继续提升：\n\n```\ndef get_first_possible_item(self, solution_array, solutionNow = None):\n        is_finished = True\n        shortest_item_length = 9\n        shortest_item_x = 0\n        shortest_item_y = 0\n        for i in range(0, 9, 1):\n            for j in range(0, 9, 1):\n                tmp_length = len(solution_array[i][j])\n                if tmp_length != 0:\n                    is_finished = False\n                    if solutionNow[i][j] != 0:\n                        tmp_length += 1\n                    if tmp_length < shortest_item_length:\n                        shortest_item_length = tmp_length\n                        shortest_item_x = i\n                        shortest_item_y = j\n\n        # print 'shortest item is:',shortest_item_length,shortest_item_x,shortest_item_y\n        if is_finished:\n            return False\n        else:\n            return {'x': shortest_item_x, 'y': shortest_item_y}\n```\n\n在这种情况下，如果不用随机选择节点的方法，前进的次数稳定在9100次左右，比之前少了3000次左右，因此速度也提升到了3.6S，比4.8S提升了1.2S左右，变化显著。然后，尝试了一下随机选择节点的方式，目前计算出的最优解精确的是4142次，耗时1.6262S。另外，如何选择最优节点，继续减少解的路径应该是最终的优化办法了吧……\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\ntotal forward: 4142\nFinished! Time consuming: 1.6262 Seconds\n```","source":"_posts/Python利用深度优先搜索解数独程序的实现.md","raw":"title: Python利用深度优先搜索解数独程序的实现\ndate: 2015-5-19 21:30:29\ncategories: Python学习\nauthor: Sergio Chan\ntags: [python, python数独， 深度优先搜索]\n---\n\n\n> 本文附带项目Github仓库地址，随手star是个好习惯：\n> [https://github.com/SergioChan/Python-Sudoku](https://github.com/SergioChan/Python-Sudoku)\n\n前两天吃饭的时候听到旁边一桌估计是搜狐或者网易的程序猿在说要是新员工给我面试我就让他写个解数独的Python程序，他二十分钟就能连伪代码加实现一起搞定……我上网一看，解数独这个问题确实挺有趣的，主要是纯凭自己好像很偶尔才能解出一个数独来的样子，于是根据以前学的数据结构的基础和最近新学的Python功底，小试牛刀一下，就使用最简单的回溯方法来实现，我知道百度上其实挺多的，但是说实话那些乱七八糟的代码我也看不太懂，自己想自己写可能思路属于自己，会比较清晰吧。回溯搜索是深度优先搜索（DFS）的一种\n对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。\n“芬兰数学家因卡拉，花费3个月时间设计出的世界上迄今难度最大的数独游戏，而且它只有一个答案。因卡拉说只有思考能力最快、头脑最聪明的人才能破解这个游戏。”这是英国《每日邮报》2012年6月30日的一篇报道。我接下来就会用这个数独来做示范，说明利用回溯解决这个问题的思路。\n\n![image](http://chenyh-blog.com/wp-content/uploads/2015/05/soduku.png)\n\n解决数独的关键思想在于找到一个入口点，将解决树一层层撸下去，遇到无法继续生长下去的结点，就往上回溯，回溯之后从上一个结点的其他分支继续往下走，如果没有其他分支则继续往上回溯。\n先将整个数独矩阵用二维数组存储：\n\n```\nproblem = \\\n    [\n        [8,0,0,0,0,0,0,0,0],\n        [0,0,3,6,0,0,0,0,0],\n        [0,7,0,0,9,0,2,0,0],\n        [0,5,0,0,0,7,0,0,0],\n        [0,0,0,0,4,5,7,0,0],\n        [0,0,0,1,0,0,0,3,0],\n        [0,0,1,0,0,0,0,6,8],\n        [0,0,8,5,0,0,0,1,0],\n        [0,9,0,0,0,0,4,0,0]\n]\n```\n\n之后，在解的过程中，由于需要回溯，所以需要把经历过的节点记录下来，我并不知道有没有更好的处理方式，这里用的是栈的存储方式，将经历过的节点存储在solutionStack中，当需要回溯的时候，直接pop掉栈顶的solution，如果解完了，则栈顶就是最后的结果。当经历了一个新的分支，在矩阵中添加了一个新的值，则随之产生一个新的节点，压入栈中。\n然后，每个节点的数据并不只限于当前的矩阵状态（我其实觉得这里换成一个节点的数据结构会比较好），还包括矩阵中每个点可能的分支，这个栈的压入和弹出是和solutionStack同步的。每当进入新的分支，都需要将这个节点的可能解中修改过的值去掉，这样在往下走并且回溯的时候，就可以回到这个节点的修改后的可能解情况，即刚刚走过的那个分支不会再重复走一遍。\n主方法：\n\n```\nimport time\nimport copy\ndef resolve(problem):\n    solutionStack = [problem]\n    tmp = get_solution_array(problem)\n    solutionArrayStack = [tmp]\n    # problem = [[0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0],\n    # [0,0,0,0,0,0,0,0,0]]\n    while 1:\n        # fetch the last solution in solution stack\n        next_item_cord = {}\n        solutionArray = []\n        # print 'still ',len(solutionStack),'in stack'\n        solutionNow = copy.deepcopy(solutionStack[len(solutionStack)-1])\n        solutionArray = solutionArrayStack[len(solutionArrayStack)-1]\n\n        flag = check_if_need_to_back(solutionNow,solutionArray)\n        if flag is True:\n            # print 'pop!'\n            solutionArrayStack.pop()\n            solutionStack.pop()\n        else:\n\n            next_item_cord = get_first_possible_item(solutionArray)\n            if next_item_cord == False:\n                break\n            # print 'next_item_cord:',next_item_cord\n            next_item_array = solutionArray[next_item_cord['x']][next_item_cord['y']]\n            solutionNow[next_item_cord['x']][next_item_cord['y']]=next_item_array[0]\n\n            solutionArray_tmp = get_solution_array(solutionNow)\n            if solutionArray[next_item_cord['x']][next_item_cord['y']].count(solutionNow[next_item_cord['x']][next_item_cord['y']])>0:\n                solutionArray[next_item_cord['x']][next_item_cord['y']].remove(solutionNow[next_item_cord['x']][next_item_cord['y']])\n            solutionStack.append(solutionNow)\n            solutionArrayStack.append(solutionArray_tmp)\n    for i in range(0,9,1):\n            print solutionStack[len(solutionStack)-1][i]\n```\n\n在开始循环之前，需要先获得初始状态的分支情况，因此独立的获取分支状况的方法如下：\n\n```\ndef get_solution_array(problem):\n    startTime=time.time()\n    tmp = []\n    for i in range(0,9,1):\n        tmp_line_array = []\n        for j in range(0,9,1):\n            # print '['+bytes(i)+','+bytes(j)+']: '+ bytes(problem[i][j])\n            if problem[i][j]==0:\n                # no value, get possible value array\n                tmp_value = [1,2,3,4,5,6,7,8,9]\n\n                # remove the existed value in line\n                for tmp_j in range(0,9,1):\n                    if problem[i][tmp_j]!=0:\n                        if problem[i][tmp_j] in tmp_value:\n                            tmp_value.remove(problem[i][tmp_j])\n\n                # remove the existed value in column\n                for tmp_i in range(0,9,1):\n                    if problem[tmp_i][j]!=0:\n                        if problem[tmp_i][j] in tmp_value:\n                            tmp_value.remove(problem[tmp_i][j])\n\n                # remove the existed value in the rectangle\n                for x in range(i/3*3,i/3*3+3):\n                    for y in range(j/3*3,j/3*3+3):\n                        if problem[x][y]!=0:\n                            if problem[x][y] in tmp_value:\n                                tmp_value.remove(problem[x][y])\n\n                tmp_line_array.append(tmp_value)\n            else:\n                tmp_line_array.append([])\n        tmp.append(tmp_line_array)\n        #print tmp_line_array\n    # print tmp\n    endTime=time.time()\n    print \"get_solution_array! Time consuming: \" + \"%.4f\" % (endTime-startTime) + \" Seconds\"\n    return tmp\n```\n\n这里需要说一点，其实每次压栈的时候节点状态做局部更新就好了，这样会减少很大的计算量，这个优化会在之后进行。每次到了新节点都要寻找下一个修改的坐标，这里就寻找的是下一个可能解最少的元素作为下一个节点。\n\n```\ndef get_first_possible_item(solution_array):\n    startTime=time.time()\n    is_finished = True\n    shortest_item_length = 9\n    shortest_item_x = 0\n    shortest_item_y = 0\n    for i in range(0,9,1):\n        for j in range(0,9,1):\n            tmp_length = len(solution_array[i][j])\n            if tmp_length!=0:\n                is_finished = False\n                if tmp_length<shortest_item_length:\n                    shortest_item_length = tmp_length\n                    shortest_item_x = i\n                    shortest_item_y = j\n\n    # print 'shortest item is:',shortest_item_length,shortest_item_x,shortest_item_y\n    endTime=time.time()\n    print \"get_first_possible_item! Time consuming: \" + \"%.4f\" % (endTime-startTime) + \" Seconds\"\n    if is_finished:\n        return False\n    else:\n        return {'x':shortest_item_x,'y':shortest_item_y}\n```\n\n补充一个判断是否需要回溯的方法：\n\n```\ndef check_if_need_to_back(solutionNow,solutionArray):\n    for i in range(0,9,1):\n        for j in range(0,9,1):\n            if len(solutionArray[i][j]) == 0 and solutionNow[i][j] == 0:\n                return True\n    return False\n```\n\n最后的输出：\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\nFinished! Time consuming: 5.2055 Seconds\n```\n\n这里的一处细节是最后的运行时间是5.2055秒，这相对于其他人的实现方式慢了一些，我在get_solution_array中用来判断所获取的值是否在可能解的候选数组中的时候，之前用的是list.count(object)这个方法来判断，后来改成了in，事实证明如果使用.count的话总消耗大概在5.6秒左右，会比in多出0.4S。\n\n恩。我改成局部更新数据了。新的获取可能解的方法：\n\n```\ndef get_resolution_array_new(solutionArray,x,y,value):\n    for tmp_j in range(0,9,1):\n        if value in solutionArray[x][tmp_j]:\n            solutionArray[x][tmp_j].remove(value)\n    for tmp_i in range(0,9,1):\n        if value in solutionArray[tmp_i][y]:\n            solutionArray[tmp_i][y].remove(value)\n    for tmp_i in range(x/3*3,x/3*3+3):\n        for tmp_j in range(y/3*3,y/3*3+3):\n            if value in solutionArray[tmp_i][tmp_j]:\n                solutionArray[tmp_i][tmp_j].remove(value)\n    return solutionArray\n```\n\n将主方法中38行代码改为：\n\n```\nsolutionArray_tmp = copy.deepcopy(solutionArray)\nsolutionArray_tmp = get_resolution_array_new(solutionArray_tmp,next_item_cord['x'],next_item_cord['y'],next_item_array[0])\n```\n\n最后的结果如下……也不咋地嘛，只是快了0.4S……看来还有优化空间吧\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\nFinished! Time consuming: 4.8577 Seconds\n```\n\n-->继续补充\n早上起来想了想又监控了一下，发现最主要耗时的还是在走的分支数量上，如果按照每次往下都默认走最左边的分支，那么前进会操作12000多次，回溯也差不多这个数，这是导致时间增大的主要原因。我没有想好如何在几个分支要选择的时候选择最优分支……毕竟我觉得去选择最优分支也要消耗时间，考虑太多意义不大……于是我就简单的尝试了一下随机分支，当程序运行到一个节点需要继续往下分支的时候随机选择一个分支，随机就用的最简单的随机方法，结果效果惊人，最快的时候可以达到：\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\nFinished! Time consuming: 1.8991 Seconds\n```\n\n当然由于采用了随机，所以时间并不稳定……在这种最优解的情况下只要前进5000次就能到达最终解。如何有一个稳定的最优算法也许永远会是个谜吧。\n随机选择分支的代码如下：\n\n```\nnext_item_array = solutionArray[next_item_cord['x']][next_item_cord['y']]\n                next_item = next_item_array[randint(0,len(next_item_array)-1)]\n                solutionNow[next_item_cord['x']][next_item_cord['y']] = next_item\n\n                # solutionArray_tmp = get_solution_array(solutionNow)\n                solutionArray_tmp = copy.deepcopy(solutionArray)\n                solutionArray_tmp = self.get_resolution_array_new(solutionArray_tmp, next_item_cord['x'], next_item_cord['y'],\n                                                             next_item)\n                if next_item in solutionArray[next_item_cord['x']][next_item_cord['y']]:\n                    solutionArray[next_item_cord['x']][next_item_cord['y']].remove(\n                        next_item)\n```\n\n-->又找出一个问题\n在获取下一个最优节点的过程中，没有算上当前矩阵中的那个值，所以会导致一个点连续的用了两次，最后可能还要回溯，所以修改了一下代码后，效率继续提升：\n\n```\ndef get_first_possible_item(self, solution_array, solutionNow = None):\n        is_finished = True\n        shortest_item_length = 9\n        shortest_item_x = 0\n        shortest_item_y = 0\n        for i in range(0, 9, 1):\n            for j in range(0, 9, 1):\n                tmp_length = len(solution_array[i][j])\n                if tmp_length != 0:\n                    is_finished = False\n                    if solutionNow[i][j] != 0:\n                        tmp_length += 1\n                    if tmp_length < shortest_item_length:\n                        shortest_item_length = tmp_length\n                        shortest_item_x = i\n                        shortest_item_y = j\n\n        # print 'shortest item is:',shortest_item_length,shortest_item_x,shortest_item_y\n        if is_finished:\n            return False\n        else:\n            return {'x': shortest_item_x, 'y': shortest_item_y}\n```\n\n在这种情况下，如果不用随机选择节点的方法，前进的次数稳定在9100次左右，比之前少了3000次左右，因此速度也提升到了3.6S，比4.8S提升了1.2S左右，变化显著。然后，尝试了一下随机选择节点的方式，目前计算出的最优解精确的是4142次，耗时1.6262S。另外，如何选择最优节点，继续减少解的路径应该是最终的优化办法了吧……\n\n```\n[8, 1, 2, 7, 5, 3, 6, 4, 9]\n[9, 4, 3, 6, 8, 2, 1, 7, 5]\n[6, 7, 5, 4, 9, 1, 2, 8, 3]\n[1, 5, 4, 2, 3, 7, 8, 9, 6]\n[3, 6, 9, 8, 4, 5, 7, 2, 1]\n[2, 8, 7, 1, 6, 9, 5, 3, 4]\n[5, 2, 1, 9, 7, 4, 3, 6, 8]\n[4, 3, 8, 5, 2, 6, 9, 1, 7]\n[7, 9, 6, 3, 1, 8, 4, 5, 2]\ntotal forward: 4142\nFinished! Time consuming: 1.6262 Seconds\n```","slug":"Python利用深度优先搜索解数独程序的实现","published":1,"updated":"2015-12-18T13:13:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciibs3sa60010evs6vrz41f4e"},{"title":"PHP图片处理 透明水印的处理和添加","date":"2014-12-26T01:11:25.000Z","_content":"\n最近玩了下PHP的图片处理，实现了一个给图片添加水印或者是重叠两张图片的功能，把自己的解决过程记录下来。\n\n首先我需要将图片resize到640*480的尺寸，重绘的代码如下：\n\n```\n$thumb = imagecreatetruecolor($newwidth, $newheight);\n$source = imagecreatefromjpeg($filename);\nimagecopyresampled($thumb, $source, 0, 0, 0, 0, $newwidth, $newheight, $width, $height);\nimagejpeg($thumb, $filename);\n```\n\n在这段重绘的代码里，包含了几个很基本的东西：\n\n第一个是imagecreatetruecolor和imagecreate\n用imagecreatetruecolor(int x,int y)建立的是一幅大小为x和y的黑色图像(默认为黑色)，如想改变背景颜色则需要用填充颜色函数imagefill($img,0,0,$color)，imagecreate 新建一个空白图像资源，用imagecolorAllocate()添加背景色：\n\n```\n$img = imagecreatetruecolor(100,100);\n$color = imagecolorAllocate($img,200,200,200);\nimagefill($img,0,0,$color);\nheader('content-type:image/jpeg');\nimagejpeg($img);\n$img = imagecreate(100,100);\n$color = imagecolorallocate($img,200,200,200);\nheader('content-type:image/jpeg');\nimagejpeg($img);\n```\n\n第二个是imagecreatefromjpeg，这个是从图片文件创建一个新图像。\n支持下面这些格式的图片文件。\n\n```\nfunction imagecreatefrompng ($filename) {}\nfunction imagecreatefromgif ($filename) {}\nfunction imagecreatefromjpeg ($filename) {}\nfunction imagecreatefromwbmp ($filename) {}\nfunction imagecreatefromxbm ($filename) {}\nfunction imagecreatefromxpm ($filename) {}\nfunction imagecreatefromgd ($filename) {}\nfunction imagecreatefromgd2 ($filename) {}\n```\n\n第三个是imagecopyresampled，这个函数在裁剪，缩放图像时都特别有用：\n\n```\n/**\n* (PHP 4 &gt;= 4.0.6, PHP 5)\n* Copy and resize part of an image with resampling\n* @link http://php.net/manual/en/function.imagecopyresampled.php\n* @param resource $dst_image\n* @param resource $src_image\n* @param int $dst_x\n* x-coordinate of destination point.\n*\n* @param int $dst_y\n* y-coordinate of destination point.\n*\n* @param int $src_x\n* x-coordinate of source point.\n*\n* @param int $src_y\n* y-coordinate of source point.\n*\n* @param int $dst_w\n* Destination width.\n*\n* @param int $dst_h\n* Destination height.\n*\n* @param int $src_w\n* Source width.\n*\n* @param int $src_h\n* Source height.\n*\n* @return bool true on success or false on failure.\n*/\nfunction imagecopyresampled ($dst_image, $src_image, $dst_x, $dst_y, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h) {}\n```\n\n第四个是imagejpeg，这个函数如果不提供第二个filename的参数，会将图片文件直接输出出来，加上了这个参数就会按照方法名里的文件格式输出到文件中去。返回的是BOOL值。\n\n接下去就是加上水印的这个函数了，我添加了一个newwidth的参数，是希望在进入这个函数前计算出需要的水印大小，传入函数，这样生成的水印大小就会不一样了，可以根据不同的需要变化。\n\n```\nfunction mark_pic($background, $waterpic, $x, $y, $new_width)\n{\n$back = imagecreatefromjpeg($background);\n$water = imagecreatefrompng($waterpic);\n$w_w = imagesx($water);\n$w_h = imagesy($water);\nimagesavealpha($water, true);\nif ($new_width != $w_w)\n{\n$new_height = $w_h * ($new_width / $w_w);\n$thumb = imagecreatetruecolor($new_width, $new_height);\n$c = imagecolorallocatealpha($thumb, 0, 0, 0, 127);\n//拾取一个完全透明的颜色\nimagealphablending($thumb, false);\n//关闭混合模式，以便透明颜色能覆盖原画布\nimagefill($thumb, 0, 0, $c); //填充\nimagesavealpha($thumb, true); //设置保存PNG时保留透明通道信息\nimagecopyresampled($thumb, $water, 0, 0, 0, 0, $new_width, $new_height, $w_w, $w_h);\nimagepng($thumb, $waterpic);\nimagedestroy($water);\n$water = imagecreatefrompng($waterpic);\n$w_w = imagesx($water);\n$w_h = imagesy($water);\n}\n$b_w = imagesx($back);\n$b_h = imagesy($back);\nimagecopy($back, $water, $x, $y - $w_h , 0, 0, $w_w, $w_h);\nimagejpeg($back, \"./files/test.jpg\");\nimagedestroy($back);\nimagedestroy($water);\n}\n```\n\n在这个函数里，最重要的一个事情其实在于重绘一个具有透明通道的图像。如果使用imagecreate，透明通道就会被消灭掉，因此我最后只能采用了以上的办法，通过imagecreatetruecolor，往上面覆盖一个完全透明的颜色，来保留图片的透明通道，这对于添加水印这个功能应该是至关重要的。\n","source":"_posts/PHP图片处理-透明水印的处理和添加.md","raw":"title: PHP图片处理 透明水印的处理和添加\ndate: 2014-12-26 9:11:25\ncategories: PHP大神养成\ntags: [PHP图片处理，水印]\n---\n\n最近玩了下PHP的图片处理，实现了一个给图片添加水印或者是重叠两张图片的功能，把自己的解决过程记录下来。\n\n首先我需要将图片resize到640*480的尺寸，重绘的代码如下：\n\n```\n$thumb = imagecreatetruecolor($newwidth, $newheight);\n$source = imagecreatefromjpeg($filename);\nimagecopyresampled($thumb, $source, 0, 0, 0, 0, $newwidth, $newheight, $width, $height);\nimagejpeg($thumb, $filename);\n```\n\n在这段重绘的代码里，包含了几个很基本的东西：\n\n第一个是imagecreatetruecolor和imagecreate\n用imagecreatetruecolor(int x,int y)建立的是一幅大小为x和y的黑色图像(默认为黑色)，如想改变背景颜色则需要用填充颜色函数imagefill($img,0,0,$color)，imagecreate 新建一个空白图像资源，用imagecolorAllocate()添加背景色：\n\n```\n$img = imagecreatetruecolor(100,100);\n$color = imagecolorAllocate($img,200,200,200);\nimagefill($img,0,0,$color);\nheader('content-type:image/jpeg');\nimagejpeg($img);\n$img = imagecreate(100,100);\n$color = imagecolorallocate($img,200,200,200);\nheader('content-type:image/jpeg');\nimagejpeg($img);\n```\n\n第二个是imagecreatefromjpeg，这个是从图片文件创建一个新图像。\n支持下面这些格式的图片文件。\n\n```\nfunction imagecreatefrompng ($filename) {}\nfunction imagecreatefromgif ($filename) {}\nfunction imagecreatefromjpeg ($filename) {}\nfunction imagecreatefromwbmp ($filename) {}\nfunction imagecreatefromxbm ($filename) {}\nfunction imagecreatefromxpm ($filename) {}\nfunction imagecreatefromgd ($filename) {}\nfunction imagecreatefromgd2 ($filename) {}\n```\n\n第三个是imagecopyresampled，这个函数在裁剪，缩放图像时都特别有用：\n\n```\n/**\n* (PHP 4 &gt;= 4.0.6, PHP 5)\n* Copy and resize part of an image with resampling\n* @link http://php.net/manual/en/function.imagecopyresampled.php\n* @param resource $dst_image\n* @param resource $src_image\n* @param int $dst_x\n* x-coordinate of destination point.\n*\n* @param int $dst_y\n* y-coordinate of destination point.\n*\n* @param int $src_x\n* x-coordinate of source point.\n*\n* @param int $src_y\n* y-coordinate of source point.\n*\n* @param int $dst_w\n* Destination width.\n*\n* @param int $dst_h\n* Destination height.\n*\n* @param int $src_w\n* Source width.\n*\n* @param int $src_h\n* Source height.\n*\n* @return bool true on success or false on failure.\n*/\nfunction imagecopyresampled ($dst_image, $src_image, $dst_x, $dst_y, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h) {}\n```\n\n第四个是imagejpeg，这个函数如果不提供第二个filename的参数，会将图片文件直接输出出来，加上了这个参数就会按照方法名里的文件格式输出到文件中去。返回的是BOOL值。\n\n接下去就是加上水印的这个函数了，我添加了一个newwidth的参数，是希望在进入这个函数前计算出需要的水印大小，传入函数，这样生成的水印大小就会不一样了，可以根据不同的需要变化。\n\n```\nfunction mark_pic($background, $waterpic, $x, $y, $new_width)\n{\n$back = imagecreatefromjpeg($background);\n$water = imagecreatefrompng($waterpic);\n$w_w = imagesx($water);\n$w_h = imagesy($water);\nimagesavealpha($water, true);\nif ($new_width != $w_w)\n{\n$new_height = $w_h * ($new_width / $w_w);\n$thumb = imagecreatetruecolor($new_width, $new_height);\n$c = imagecolorallocatealpha($thumb, 0, 0, 0, 127);\n//拾取一个完全透明的颜色\nimagealphablending($thumb, false);\n//关闭混合模式，以便透明颜色能覆盖原画布\nimagefill($thumb, 0, 0, $c); //填充\nimagesavealpha($thumb, true); //设置保存PNG时保留透明通道信息\nimagecopyresampled($thumb, $water, 0, 0, 0, 0, $new_width, $new_height, $w_w, $w_h);\nimagepng($thumb, $waterpic);\nimagedestroy($water);\n$water = imagecreatefrompng($waterpic);\n$w_w = imagesx($water);\n$w_h = imagesy($water);\n}\n$b_w = imagesx($back);\n$b_h = imagesy($back);\nimagecopy($back, $water, $x, $y - $w_h , 0, 0, $w_w, $w_h);\nimagejpeg($back, \"./files/test.jpg\");\nimagedestroy($back);\nimagedestroy($water);\n}\n```\n\n在这个函数里，最重要的一个事情其实在于重绘一个具有透明通道的图像。如果使用imagecreate，透明通道就会被消灭掉，因此我最后只能采用了以上的办法，通过imagecreatetruecolor，往上面覆盖一个完全透明的颜色，来保留图片的透明通道，这对于添加水印这个功能应该是至关重要的。\n","slug":"PHP图片处理-透明水印的处理和添加","published":1,"updated":"2015-12-18T13:13:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciibs3sa80017evs61epknamo"}],"PostAsset":[],"PostCategory":[{"post_id":"ciibs3s9h0004evs6qvjhg8tq","category_id":"ciibs3s9l0005evs67k092hmo","_id":"ciibs3s9o0008evs6ir2bif49"},{"post_id":"ciibs3s9t000devs6hv6u0l9e","category_id":"ciibs3s9l0005evs67k092hmo","_id":"ciibs3s9w000eevs6vwj76trn"},{"post_id":"ciibs3s9y000levs62z2mlrhl","category_id":"ciibs3s9l0005evs67k092hmo","_id":"ciibs3s9y000mevs6ubij6wyl"},{"post_id":"ciibs3s9z000pevs6sn05ahdw","category_id":"ciibs3sa0000qevs698w63ux2","_id":"ciibs3sa1000tevs6yqcjwj5i"},{"post_id":"ciibs3sa2000wevs643i6a305","category_id":"ciibs3s9l0005evs67k092hmo","_id":"ciibs3sa4000xevs625rutzmf"},{"post_id":"ciibs3sa60010evs6vrz41f4e","category_id":"ciibs3sa60011evs6f192nr1f","_id":"ciibs3sa70014evs693sg2nop"},{"post_id":"ciibs3sa80017evs61epknamo","category_id":"ciibs3saa0018evs6uq7zw1jm","_id":"ciibs3sab001bevs6ote9yzww"}],"PostTag":[{"post_id":"ciibs3s9h0004evs6qvjhg8tq","tag_id":"ciibs3s9m0006evs6vsrrxk0b","_id":"ciibs3s9p000aevs6jo0br4o9"},{"post_id":"ciibs3s9h0004evs6qvjhg8tq","tag_id":"ciibs3s9o0007evs6z64fk0ua","_id":"ciibs3s9p000bevs6ksnj9t57"},{"post_id":"ciibs3s9h0004evs6qvjhg8tq","tag_id":"ciibs3s9o0009evs6by516rv3","_id":"ciibs3s9p000cevs6wkjoixnq"},{"post_id":"ciibs3s9t000devs6hv6u0l9e","tag_id":"ciibs3s9w000fevs63yh0zjxi","_id":"ciibs3s9w000ievs6x3ncejbi"},{"post_id":"ciibs3s9t000devs6hv6u0l9e","tag_id":"ciibs3s9w000gevs6czsh51bc","_id":"ciibs3s9w000jevs6na8oq5sv"},{"post_id":"ciibs3s9t000devs6hv6u0l9e","tag_id":"ciibs3s9w000hevs6d1swoyn9","_id":"ciibs3s9w000kevs6atrngktl"},{"post_id":"ciibs3s9y000levs62z2mlrhl","tag_id":"ciibs3s9y000nevs6nzxz1l5b","_id":"ciibs3s9z000oevs6zrhsfqj5"},{"post_id":"ciibs3s9z000pevs6sn05ahdw","tag_id":"ciibs3sa0000revs6hguqfwz2","_id":"ciibs3sa1000uevs66lfgah0w"},{"post_id":"ciibs3s9z000pevs6sn05ahdw","tag_id":"ciibs3sa1000sevs6cd6rj5uc","_id":"ciibs3sa1000vevs64wnjovhr"},{"post_id":"ciibs3sa2000wevs643i6a305","tag_id":"ciibs3sa4000yevs6p431per9","_id":"ciibs3sa4000zevs68bmfh55y"},{"post_id":"ciibs3sa60010evs6vrz41f4e","tag_id":"ciibs3sa60012evs6axx27sij","_id":"ciibs3sa70015evs62widqe37"},{"post_id":"ciibs3sa60010evs6vrz41f4e","tag_id":"ciibs3sa70013evs6lqal3hnz","_id":"ciibs3sa70016evs6f2gxwoh6"},{"post_id":"ciibs3sa80017evs61epknamo","tag_id":"ciibs3saa0019evs6as0xamnt","_id":"ciibs3saa001aevs6kqxo7lua"}],"Tag":[{"name":"iOS","_id":"ciibs3s9m0006evs6vsrrxk0b"},{"name":"runloop","_id":"ciibs3s9o0007evs6z64fk0ua"},{"name":"NSThread","_id":"ciibs3s9o0009evs6by516rv3"},{"name":"runtime","_id":"ciibs3s9w000fevs63yh0zjxi"},{"name":"Objective-C","_id":"ciibs3s9w000gevs6czsh51bc"},{"name":"objc_msgSend","_id":"ciibs3s9w000hevs6d1swoyn9"},{"name":"iOS静态库","_id":"ciibs3s9y000nevs6nzxz1l5b"},{"name":"Ubuntu","_id":"ciibs3sa0000revs6hguqfwz2"},{"name":"MySQL","_id":"ciibs3sa1000sevs6cd6rj5uc"},{"name":"UIColor","_id":"ciibs3sa4000yevs6p431per9"},{"name":"python","_id":"ciibs3sa60012evs6axx27sij"},{"name":"python数独， 深度优先搜索","_id":"ciibs3sa70013evs6lqal3hnz"},{"name":"PHP图片处理，水印","_id":"ciibs3saa0019evs6as0xamnt"}]}}